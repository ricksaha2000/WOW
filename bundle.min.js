! function () {
    "use strict";

    function e(e, t) {
        for (var i = 0; i < t.length; i++) {
            var s = t[i];
            s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
        }
    }

    function t(t, i, s) {
        return i && e(t.prototype, i), s && e(t, s), t
    }

    function i() {
        return (i = Object.assign || function (e) {
            for (var t = 1; t < arguments.length; t++) {
                var i = arguments[t];
                for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s])
            }
            return e
        }).apply(this, arguments)
    }

    function s(e, t) {
        e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
    }

    function n(e) {
        return (n = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        })(e)
    }

    function a(e, t) {
        return (a = Object.setPrototypeOf || function (e, t) {
            return e.__proto__ = t, e
        })(e, t)
    }

    function r(e, t, i) {
        return (r = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {}))), !0
            } catch (e) {
                return !1
            }
        }() ? Reflect.construct : function (e, t, i) {
            var s = [null];
            s.push.apply(s, t);
            var n = new(Function.bind.apply(e, s));
            return i && a(n, i.prototype), n
        }).apply(null, arguments)
    }

    function o(e) {
        var t = "function" == typeof Map ? new Map : void 0;
        return (o = function (e) {
            if (null === e || -1 === Function.toString.call(e).indexOf("[native code]")) return e;
            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t) {
                if (t.has(e)) return t.get(e);
                t.set(e, i)
            }

            function i() {
                return r(e, arguments, n(this).constructor)
            }
            return i.prototype = Object.create(e.prototype, {
                constructor: {
                    value: i,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }), a(i, e)
        })(e)
    }

    function l(e, t) {
        try {
            var i = e()
        } catch (e) {
            return t(e)
        }
        return i && i.then ? i.then(void 0, t) : i
    }
    "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
    var d, c = "2.8.0";
    ! function (e) {
        e[e.off = 0] = "off", e[e.error = 1] = "error", e[e.warning = 2] = "warning", e[e.info = 3] = "info", e[e.debug = 4] = "debug"
    }(d || (d = {}));
    var h = d.off,
        u = function () {
            function e(e) {
                this.t = e
            }
            e.getLevel = function () {
                return h
            }, e.setLevel = function (e) {
                return h = d[e]
            };
            var t = e.prototype;
            return t.error = function () {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                this.i(console.error, d.error, t)
            }, t.warn = function () {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                this.i(console.warn, d.warning, t)
            }, t.info = function () {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                this.i(console.info, d.info, t)
            }, t.debug = function () {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                this.i(console.log, d.debug, t)
            }, t.i = function (t, i, s) {
                i <= e.getLevel() && t.apply(console, ["[" + this.t + "] "].concat(s))
            }, e
        }(),
        p = function e(t, i, s) {
            return t instanceof RegExp ? function (e, t) {
                if (!t) return e;
                var i = e.source.match(/\((?!\?)/g);
                if (i)
                    for (var s = 0; s < i.length; s++) t.push({
                        name: s,
                        prefix: null,
                        delimiter: null,
                        optional: !1,
                        repeat: !1,
                        pattern: null
                    });
                return e
            }(t, i) : Array.isArray(t) ? function (t, i, s) {
                for (var n = [], a = 0; a < t.length; a++) n.push(e(t[a], i, s).source);
                return new RegExp("(?:" + n.join("|") + ")", S(s))
            }(t, i, s) : function (e, t, i) {
                return C(b(e, i), t, i)
            }(t, i, s)
        },
        m = b,
        f = w,
        g = C,
        v = "/",
        y = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

    function b(e, t) {
        for (var i, s = [], n = 0, a = 0, r = "", o = t && t.delimiter || v, l = t && t.whitelist || void 0, d = !1; null !== (i = y.exec(e));) {
            var c = i[0],
                h = i[1],
                u = i.index;
            if (r += e.slice(a, u), a = u + c.length, h) r += h[1], d = !0;
            else {
                var p = "",
                    m = i[2],
                    f = i[3],
                    g = i[4],
                    b = i[5];
                if (!d && r.length) {
                    var w = r.length - 1,
                        S = r[w];
                    (!l || l.indexOf(S) > -1) && (p = S, r = r.slice(0, w))
                }
                r && (s.push(r), r = "", d = !1);
                var C = f || g,
                    T = p || o;
                s.push({
                    name: m || n++,
                    prefix: p,
                    delimiter: T,
                    optional: "?" === b || "*" === b,
                    repeat: "+" === b || "*" === b,
                    pattern: C ? E(C) : "[^" + x(T === o ? T : T + o) + "]+?"
                })
            }
        }
        return (r || a < e.length) && s.push(r + e.substr(a)), s
    }

    function w(e) {
        for (var t = new Array(e.length), i = 0; i < e.length; i++) "object" == typeof e[i] && (t[i] = new RegExp("^(?:" + e[i].pattern + ")$"));
        return function (i, s) {
            for (var n = "", a = s && s.encode || encodeURIComponent, r = 0; r < e.length; r++) {
                var o = e[r];
                if ("string" != typeof o) {
                    var l, d = i ? i[o.name] : void 0;
                    if (Array.isArray(d)) {
                        if (!o.repeat) throw new TypeError('Expected "' + o.name + '" to not repeat, but got array');
                        if (0 === d.length) {
                            if (o.optional) continue;
                            throw new TypeError('Expected "' + o.name + '" to not be empty')
                        }
                        for (var c = 0; c < d.length; c++) {
                            if (l = a(d[c], o), !t[r].test(l)) throw new TypeError('Expected all "' + o.name + '" to match "' + o.pattern + '"');
                            n += (0 === c ? o.prefix : o.delimiter) + l
                        }
                    } else if ("string" != typeof d && "number" != typeof d && "boolean" != typeof d) {
                        if (!o.optional) throw new TypeError('Expected "' + o.name + '" to be ' + (o.repeat ? "an array" : "a string"))
                    } else {
                        if (l = a(String(d), o), !t[r].test(l)) throw new TypeError('Expected "' + o.name + '" to match "' + o.pattern + '", but got "' + l + '"');
                        n += o.prefix + l
                    }
                } else n += o
            }
            return n
        }
    }

    function x(e) {
        return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1")
    }

    function E(e) {
        return e.replace(/([=!:$\/()])/g, "\\$1")
    }

    function S(e) {
        return e && e.sensitive ? "" : "i"
    }

    function C(e, t, i) {
        for (var s = (i = i || {}).strict, n = !1 !== i.start, a = !1 !== i.end, r = i.delimiter || v, o = [].concat(i.endsWith || []).map(x).concat("$").join("|"), l = n ? "^" : "", d = 0; d < e.length; d++) {
            var c = e[d];
            if ("string" == typeof c) l += x(c);
            else {
                var h = c.repeat ? "(?:" + c.pattern + ")(?:" + x(c.delimiter) + "(?:" + c.pattern + "))*" : c.pattern;
                t && t.push(c), l += c.optional ? c.prefix ? "(?:" + x(c.prefix) + "(" + h + "))?" : "(" + h + ")?" : x(c.prefix) + "(" + h + ")"
            }
        }
        if (a) s || (l += "(?:" + x(r) + ")?"), l += "$" === o ? "$" : "(?=" + o + ")";
        else {
            var u = e[e.length - 1],
                p = "string" == typeof u ? u[u.length - 1] === r : void 0 === u;
            s || (l += "(?:" + x(r) + "(?=" + o + "))?"), p || (l += "(?=" + x(r) + "|" + o + ")")
        }
        return new RegExp(l, S(i))
    }
    p.parse = m, p.compile = function (e, t) {
        return w(b(e, t))
    }, p.tokensToFunction = f, p.tokensToRegExp = g;
    var T = {
            container: "container",
            namespace: "namespace",
            prefix: "data-barba",
            prevent: "prevent",
            wrapper: "wrapper"
        },
        L = new(function () {
            function e() {
                this.o = T, this.u = new DOMParser
            }
            var t = e.prototype;
            return t.toString = function (e) {
                return e.outerHTML
            }, t.toDocument = function (e) {
                return this.u.parseFromString(e, "text/html")
            }, t.toElement = function (e) {
                var t = document.createElement("div");
                return t.innerHTML = e, t
            }, t.getHtml = function (e) {
                return void 0 === e && (e = document), this.toString(e.documentElement)
            }, t.getWrapper = function (e) {
                return void 0 === e && (e = document), e.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
            }, t.getContainer = function (e) {
                return void 0 === e && (e = document), e.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
            }, t.removeContainer = function (e) {
                document.body.contains(e) && e.parentNode.removeChild(e)
            }, t.addContainer = function (e, t) {
                var i = this.getContainer();
                i ? this.s(e, i) : t.appendChild(e)
            }, t.getNamespace = function (e) {
                void 0 === e && (e = document);
                var t = e.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
                return t ? t.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
            }, t.getHref = function (e) {
                if (e.tagName && "a" === e.tagName.toLowerCase()) {
                    if ("string" == typeof e.href) return e.href;
                    var t = e.getAttribute("href") || e.getAttribute("xlink:href");
                    if (t) return this.resolveUrl(t.baseVal || t)
                }
                return null
            }, t.resolveUrl = function () {
                for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
                var s = t.length;
                if (0 === s) throw new Error("resolveUrl requires at least one argument; got none.");
                var n = document.createElement("base");
                if (n.href = arguments[0], 1 === s) return n.href;
                var a = document.getElementsByTagName("head")[0];
                a.insertBefore(n, a.firstChild);
                for (var r, o = document.createElement("a"), l = 1; l < s; l++) o.href = arguments[l], n.href = r = o.href;
                return a.removeChild(n), r
            }, t.s = function (e, t) {
                t.parentNode.insertBefore(e, t.nextSibling)
            }, e
        }()),
        I = new(function () {
            function e() {
                this.h = []
            }
            var s = e.prototype;
            return s.init = function (e, t) {
                var i = {
                    index: 0,
                    ns: t,
                    scroll: {
                        x: window.scrollX,
                        y: window.scrollY
                    },
                    url: e
                };
                this.h.push(i), window.history && window.history.replaceState(i, "", i.url)
            }, s.add = function (e, t, i, s) {
                void 0 === i && (i = null), void 0 === s && (s = !0);
                var n = {
                    index: i || this.size,
                    ns: t,
                    scroll: {
                        x: window.scrollX,
                        y: window.scrollY
                    },
                    url: e
                };
                this.h.push(n), s && window.history && window.history.pushState(n, "", n.url)
            }, s.remove = function () {
                this.h.pop()
            }, s.clear = function () {
                this.h = []
            }, s.update = function (e) {
                var t = i({}, this.current, {}, e);
                this.current = t, window.history && window.history.replaceState(t, "", t.url)
            }, s.cancel = function () {
                this.remove(), window.history && window.history.back()
            }, s.get = function (e) {
                return this.h[e]
            }, s.getDirection = function (e) {
                var t = "popstate";
                return e < this.current.index ? t = "back" : e > this.current.index && (t = "forward"), t
            }, t(e, [{
                key: "current",
                get: function () {
                    return this.h[this.h.length - 1]
                },
                set: function (e) {
                    this.h[this.h.length - 1] = e
                }
            }, {
                key: "previous",
                get: function () {
                    return this.h.length < 2 ? null : this.h[this.h.length - 2]
                }
            }, {
                key: "size",
                get: function () {
                    return this.h.length
                }
            }]), e
        }()),
        $ = function (e, t) {
            try {
                var i = function () {
                    if (!t.next.html) return Promise.resolve(e).then((function (e) {
                        var i = t.next;
                        if (e) {
                            var s = L.toElement(e);
                            i.namespace = L.getNamespace(s), i.container = L.getContainer(s), i.html = e, I.update({
                                ns: i.namespace
                            });
                            var n = L.toDocument(e);
                            document.title = n.title
                        }
                    }))
                }();
                return Promise.resolve(i && i.then ? i.then((function () {})) : void 0)
            } catch (e) {
                return Promise.reject(e)
            }
        },
        z = p,
        M = {
            update: $,
            nextTick: function () {
                return new Promise((function (e) {
                    window.requestAnimationFrame(e)
                }))
            },
            pathToRegexp: z
        },
        P = function () {
            return window.location.origin
        },
        k = function (e) {
            return void 0 === e && (e = window.location.href), O(e).port
        },
        O = function (e) {
            var t, i = e.match(/:\d+/);
            if (null === i) /^http/.test(e) && (t = 80), /^https/.test(e) && (t = 443);
            else {
                var s = i[0].substring(1);
                t = parseInt(s, 10)
            }
            var n, a = e.replace(P(), ""),
                r = {},
                o = a.indexOf("#");
            o >= 0 && (n = a.slice(o + 1), a = a.slice(0, o));
            var l = a.indexOf("?");
            return l >= 0 && (r = A(a.slice(l + 1)), a = a.slice(0, l)), {
                hash: n,
                path: a,
                port: t,
                query: r
            }
        },
        A = function (e) {
            return e.split("&").reduce((function (e, t) {
                var i = t.split("=");
                return e[i[0]] = i[1], e
            }), {})
        },
        D = function (e) {
            return void 0 === e && (e = window.location.href), e.replace(/(\/#.*|\/|#.*)$/, "")
        },
        _ = {
            getHref: function () {
                return window.location.href
            },
            getOrigin: P,
            getPort: k,
            getPath: function (e) {
                return void 0 === e && (e = window.location.href), O(e).path
            },
            parse: O,
            parseQuery: A,
            clean: D
        };

    function H(e, t, i) {
        return void 0 === t && (t = 2e3), new Promise((function (s, n) {
            var a = new XMLHttpRequest;
            a.onreadystatechange = function () {
                if (a.readyState === XMLHttpRequest.DONE)
                    if (200 === a.status) s(a.responseText);
                    else if (a.status) {
                    var t = {
                        status: a.status,
                        statusText: a.statusText
                    };
                    i(e, t), n(t)
                }
            }, a.ontimeout = function () {
                var s = new Error("Timeout error [" + t + "]");
                i(e, s), n(s)
            }, a.onerror = function () {
                var t = new Error("Fetch error");
                i(e, t), n(t)
            }, a.open("GET", e), a.timeout = t, a.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), a.setRequestHeader("x-barba", "yes"), a.send()
        }))
    }
    var B = function (e) {
        return !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then
    };

    function q(e, t) {
        return void 0 === t && (t = {}),
            function () {
                for (var i = arguments.length, s = new Array(i), n = 0; n < i; n++) s[n] = arguments[n];
                var a = !1,
                    r = new Promise((function (i, n) {
                        t.async = function () {
                            return a = !0,
                                function (e, t) {
                                    e ? n(e) : i(t)
                                }
                        };
                        var r = e.apply(t, s);
                        a || (B(r) ? r.then(i, n) : i(r))
                    }));
                return r
            }
    }
    var N = new(function (e) {
            function t() {
                var t;
                return (t = e.call(this) || this).logger = new u("@barba/core"), t.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], t.registered = new Map, t.init(), t
            }
            s(t, e);
            var i = t.prototype;
            return i.init = function () {
                var e = this;
                this.registered.clear(), this.all.forEach((function (t) {
                    e[t] || (e[t] = function (i, s) {
                        void 0 === s && (s = {}), e.registered.has(t) || e.registered.set(t, new Set), e.registered.get(t).add({
                            ctx: s,
                            fn: i
                        })
                    })
                }))
            }, i.do = function (e) {
                for (var t = this, i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++) s[n - 1] = arguments[n];
                if (this.registered.has(e)) {
                    var a = Promise.resolve();
                    return this.registered.get(e).forEach((function (e) {
                        a = a.then((function () {
                            return q(e.fn, e.ctx).apply(void 0, s)
                        }))
                    })), a.catch((function (i) {
                        t.logger.debug("Hook error [" + e + "]"), t.logger.error(i)
                    }))
                }
                return Promise.resolve()
            }, i.clear = function () {
                var e = this;
                this.all.forEach((function (t) {
                    delete e[t]
                })), this.init()
            }, i.help = function () {
                this.logger.info("Available hooks: " + this.all.join(","));
                var e = [];
                this.registered.forEach((function (t, i) {
                    return e.push(i)
                })), this.logger.info("Registered hooks: " + e.join(","))
            }, t
        }((function () {}))),
        R = function () {
            function e(e) {
                if (this.v = [], "boolean" == typeof e) this.l = e;
                else {
                    var t = Array.isArray(e) ? e : [e];
                    this.v = t.map((function (e) {
                        return z(e)
                    }))
                }
            }
            return e.prototype.checkHref = function (e) {
                if ("boolean" == typeof this.l) return this.l;
                var t = O(e).path;
                return this.v.some((function (e) {
                    return null !== e.exec(t)
                }))
            }, e
        }(),
        W = function (e) {
            function t(t) {
                var i;
                return (i = e.call(this, t) || this).h = new Map, i
            }
            s(t, e);
            var n = t.prototype;
            return n.set = function (e, t, i) {
                return this.checkHref(e) || this.h.set(e, {
                    action: i,
                    request: t
                }), {
                    action: i,
                    request: t
                }
            }, n.get = function (e) {
                return this.h.get(e)
            }, n.getRequest = function (e) {
                return this.h.get(e).request
            }, n.getAction = function (e) {
                return this.h.get(e).action
            }, n.has = function (e) {
                return this.h.has(e)
            }, n.delete = function (e) {
                return this.h.delete(e)
            }, n.update = function (e, t) {
                var s = i({}, this.h.get(e), {}, t);
                return this.h.set(e, s), s
            }, t
        }(R),
        F = function () {
            return !window.history.pushState
        },
        G = function (e) {
            return !e.el || !e.href
        },
        Y = function (e) {
            var t = e.event;
            return t.which > 1 || t.metaKey || t.ctrlKey || t.shiftKey || t.altKey
        },
        V = function (e) {
            var t = e.el;
            return t.hasAttribute("target") && "_blank" === t.target
        },
        j = function (e) {
            var t = e.el;
            return void 0 !== t.protocol && window.location.protocol !== t.protocol || void 0 !== t.hostname && window.location.hostname !== t.hostname
        },
        X = function (e) {
            var t = e.el;
            return void 0 !== t.port && k() !== k(t.href)
        },
        U = function (e) {
            var t = e.el;
            return t.getAttribute && "string" == typeof t.getAttribute("download")
        },
        K = function (e) {
            return e.el.hasAttribute(T.prefix + "-" + T.prevent)
        },
        Q = function (e) {
            return Boolean(e.el.closest("[" + T.prefix + "-" + T.prevent + '="all"]'))
        },
        J = function (e) {
            var t = e.href;
            return D(t) === D() && k(t) === k()
        },
        Z = function (e) {
            function t(t) {
                var i;
                return (i = e.call(this, t) || this).suite = [], i.tests = new Map, i.init(), i
            }
            s(t, e);
            var i = t.prototype;
            return i.init = function () {
                this.add("pushState", F), this.add("exists", G), this.add("newTab", Y), this.add("blank", V), this.add("corsDomain", j), this.add("corsPort", X), this.add("download", U), this.add("preventSelf", K), this.add("preventAll", Q), this.add("sameUrl", J, !1)
            }, i.add = function (e, t, i) {
                void 0 === i && (i = !0), this.tests.set(e, t), i && this.suite.push(e)
            }, i.run = function (e, t, i, s) {
                return this.tests.get(e)({
                    el: t,
                    event: i,
                    href: s
                })
            }, i.checkLink = function (e, t, i) {
                var s = this;
                return this.suite.some((function (n) {
                    return s.run(n, e, t, i)
                }))
            }, t
        }(R),
        ee = function (e) {
            function t(i, s) {
                var n;
                void 0 === s && (s = "Barba error");
                for (var a = arguments.length, r = new Array(a > 2 ? a - 2 : 0), o = 2; o < a; o++) r[o - 2] = arguments[o];
                return (n = e.call.apply(e, [this].concat(r)) || this).error = i, n.label = s, Error.captureStackTrace && Error.captureStackTrace(function (e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }(n), t), n.name = "BarbaError", n
            }
            return s(t, e), t
        }(o(Error)),
        te = function () {
            function e(e) {
                void 0 === e && (e = []), this.logger = new u("@barba/core"), this.all = [], this.once = [], this.m = [{
                    name: "namespace",
                    type: "strings"
                }, {
                    name: "custom",
                    type: "function"
                }], e && (this.all = this.all.concat(e)), this.update()
            }
            var t = e.prototype;
            return t.add = function (e, t) {
                switch (e) {
                    case "rule":
                        this.m.splice(t.position || 0, 0, t.value);
                        break;
                    case "transition":
                    default:
                        this.all.push(t)
                }
                this.update()
            }, t.resolve = function (e, t) {
                var i = this;
                void 0 === t && (t = {});
                var s = t.once ? this.once : this.all;
                s = s.filter(t.self ? function (e) {
                    return e.name && "self" === e.name
                } : function (e) {
                    return !e.name || "self" !== e.name
                });
                var n = new Map,
                    a = s.find((function (s) {
                        var a = !0,
                            r = {};
                        return !(!t.self || "self" !== s.name) || (i.m.reverse().forEach((function (t) {
                            a && (a = i.p(s, t, e, r), s.from && s.to && (a = i.p(s, t, e, r, "from") && i.p(s, t, e, r, "to")), s.from && !s.to && (a = i.p(s, t, e, r, "from")), !s.from && s.to && (a = i.p(s, t, e, r, "to")))
                        })), n.set(s, r), a)
                    })),
                    r = n.get(a),
                    o = [];
                if (o.push(t.once ? "once" : "page"), t.self && o.push("self"), r) {
                    var l, d = [a];
                    Object.keys(r).length > 0 && d.push(r), (l = this.logger).info.apply(l, ["Transition found [" + o.join(",") + "]"].concat(d))
                } else this.logger.info("No transition found [" + o.join(",") + "]");
                return a
            }, t.update = function () {
                var e = this;
                this.all = this.all.map((function (t) {
                    return e.P(t)
                })).sort((function (e, t) {
                    return e.priority - t.priority
                })).reverse().map((function (e) {
                    return delete e.priority, e
                })), this.once = this.all.filter((function (e) {
                    return void 0 !== e.once
                }))
            }, t.p = function (e, t, i, s, n) {
                var a = !0,
                    r = !1,
                    o = e,
                    l = t.name,
                    d = l,
                    c = l,
                    h = l,
                    u = n ? o[n] : o,
                    p = "to" === n ? i.next : i.current;
                if (n ? u && u[l] : u[l]) {
                    switch (t.type) {
                        case "strings":
                        default:
                            var m = Array.isArray(u[d]) ? u[d] : [u[d]];
                            p[d] && -1 !== m.indexOf(p[d]) && (r = !0), -1 === m.indexOf(p[d]) && (a = !1);
                            break;
                        case "object":
                            var f = Array.isArray(u[c]) ? u[c] : [u[c]];
                            p[c] && (p[c].name && -1 !== f.indexOf(p[c].name) && (r = !0), -1 === f.indexOf(p[c].name) && (a = !1));
                            break;
                        case "function":
                            u[h](i) ? r = !0 : a = !1
                    }
                    r && (n ? (s[n] = s[n] || {}, s[n][l] = o[n][l]) : s[l] = o[l])
                }
                return a
            }, t.g = function (e, t, i) {
                var s = 0;
                return (e[t] || e.from && e.from[t] || e.to && e.to[t]) && (s += Math.pow(10, i), e.from && e.from[t] && (s += 1), e.to && e.to[t] && (s += 2)), s
            }, t.P = function (e) {
                var t = this;
                e.priority = 0;
                var i = 0;
                return this.m.forEach((function (s, n) {
                    i += t.g(e, s.name, n + 1)
                })), e.priority = i, e
            }, e
        }(),
        ie = function () {
            function e(e) {
                void 0 === e && (e = []), this.logger = new u("@barba/core"), this.k = !1, this.store = new te(e)
            }
            var i = e.prototype;
            return i.get = function (e, t) {
                return this.store.resolve(e, t)
            }, i.doOnce = function (e) {
                var t = e.data,
                    i = e.transition;
                try {
                    var s = function () {
                            n.k = !1
                        },
                        n = this,
                        a = i || {};
                    n.k = !0;
                    var r = l((function () {
                        return Promise.resolve(n.A("beforeOnce", t, a)).then((function () {
                            return Promise.resolve(n.once(t, a)).then((function () {
                                return Promise.resolve(n.A("afterOnce", t, a)).then((function () {}))
                            }))
                        }))
                    }), (function (e) {
                        n.k = !1, n.logger.debug("Transition error [before/after/once]"), n.logger.error(e)
                    }));
                    return Promise.resolve(r && r.then ? r.then(s) : s())
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.doPage = function (e) {
                var t = e.data,
                    i = e.transition,
                    s = e.page,
                    n = e.wrapper;
                try {
                    var a = function (e) {
                            if (r) return e;
                            o.k = !1
                        },
                        r = !1,
                        o = this,
                        d = i || {},
                        c = !0 === d.sync || !1;
                    o.k = !0;
                    var h = l((function () {
                        function e() {
                            return Promise.resolve(o.A("before", t, d)).then((function () {
                                var e = !1;

                                function i(i) {
                                    return e ? i : Promise.resolve(o.remove(t)).then((function () {
                                        return Promise.resolve(o.A("after", t, d)).then((function () {}))
                                    }))
                                }
                                var a = function () {
                                    if (c) return l((function () {
                                        return Promise.resolve(o.add(t, n)).then((function () {
                                            return Promise.resolve(o.A("beforeLeave", t, d)).then((function () {
                                                return Promise.resolve(o.A("beforeEnter", t, d)).then((function () {
                                                    return Promise.resolve(Promise.all([o.leave(t, d), o.enter(t, d)])).then((function () {
                                                        return Promise.resolve(o.A("afterLeave", t, d)).then((function () {
                                                            return Promise.resolve(o.A("afterEnter", t, d)).then((function () {}))
                                                        }))
                                                    }))
                                                }))
                                            }))
                                        }))
                                    }), (function (e) {
                                        throw new ee(e, "Transition error [sync]")
                                    }));
                                    var i = function (i) {
                                            return e ? i : l((function () {
                                                var e = function () {
                                                    if (!1 !== a) return Promise.resolve(o.add(t, n)).then((function () {
                                                        return Promise.resolve(o.A("beforeEnter", t, d)).then((function () {
                                                            return Promise.resolve(o.enter(t, d, a)).then((function () {
                                                                return Promise.resolve(o.A("afterEnter", t, d)).then((function () {}))
                                                            }))
                                                        }))
                                                    }))
                                                }();
                                                if (e && e.then) return e.then((function () {}))
                                            }), (function (e) {
                                                throw new ee(e, "Transition error [before/after/enter]")
                                            }))
                                        },
                                        a = !1,
                                        r = l((function () {
                                            return Promise.resolve(o.A("beforeLeave", t, d)).then((function () {
                                                return Promise.resolve(Promise.all([o.leave(t, d), $(s, t)]).then((function (e) {
                                                    return e[0]
                                                }))).then((function (e) {
                                                    return a = e, Promise.resolve(o.A("afterLeave", t, d)).then((function () {}))
                                                }))
                                            }))
                                        }), (function (e) {
                                            throw new ee(e, "Transition error [before/after/leave]")
                                        }));
                                    return r && r.then ? r.then(i) : i(r)
                                }();
                                return a && a.then ? a.then(i) : i(a)
                            }))
                        }
                        var i = function () {
                            if (c) return Promise.resolve($(s, t)).then((function () {}))
                        }();
                        return i && i.then ? i.then(e) : e()
                    }), (function (e) {
                        if (o.k = !1, e.name && "BarbaError" === e.name) throw o.logger.debug(e.label), o.logger.error(e.error), e;
                        throw o.logger.debug("Transition error [page]"), o.logger.error(e), e
                    }));
                    return Promise.resolve(h && h.then ? h.then(a) : a(h))
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.once = function (e, t) {
                try {
                    return Promise.resolve(N.do("once", e, t)).then((function () {
                        return t.once ? q(t.once, t)(e) : Promise.resolve()
                    }))
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.leave = function (e, t) {
                try {
                    return Promise.resolve(N.do("leave", e, t)).then((function () {
                        return t.leave ? q(t.leave, t)(e) : Promise.resolve()
                    }))
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.enter = function (e, t, i) {
                try {
                    return Promise.resolve(N.do("enter", e, t)).then((function () {
                        return t.enter ? q(t.enter, t)(e, i) : Promise.resolve()
                    }))
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.add = function (e, t) {
                try {
                    return L.addContainer(e.next.container, t), N.do("nextAdded", e), Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.remove = function (e) {
                try {
                    return L.removeContainer(e.current.container), N.do("currentRemoved", e), Promise.resolve()
                } catch (e) {
                    return Promise.reject(e)
                }
            }, i.A = function (e, t, i) {
                try {
                    return Promise.resolve(N.do(e, t, i)).then((function () {
                        return i[e] ? q(i[e], i)(t) : Promise.resolve()
                    }))
                } catch (e) {
                    return Promise.reject(e)
                }
            }, t(e, [{
                key: "isRunning",
                get: function () {
                    return this.k
                },
                set: function (e) {
                    this.k = e
                }
            }, {
                key: "hasOnce",
                get: function () {
                    return this.store.once.length > 0
                }
            }, {
                key: "hasSelf",
                get: function () {
                    return this.store.all.some((function (e) {
                        return "self" === e.name
                    }))
                }
            }, {
                key: "shouldWait",
                get: function () {
                    return this.store.all.some((function (e) {
                        return e.to && !e.to.route || e.sync
                    }))
                }
            }]), e
        }(),
        se = function () {
            function e(e) {
                var t = this;
                this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== e.length && (e.forEach((function (e) {
                    t.byNamespace.set(e.namespace, e)
                })), this.names.forEach((function (e) {
                    N[e](t.R(e))
                })))
            }
            return e.prototype.R = function (e) {
                var t = this;
                return function (i) {
                    var s = e.match(/enter/i) ? i.next : i.current,
                        n = t.byNamespace.get(s.namespace);
                    return n && n[e] ? q(n[e], n)(i) : Promise.resolve()
                }
            }, e
        }();
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function (e) {
        var t = this;
        do {
            if (t.matches(e)) return t;
            t = t.parentElement || t.parentNode
        } while (null !== t && 1 === t.nodeType);
        return null
    });
    var ne = {
            container: void 0,
            html: void 0,
            namespace: void 0,
            url: {
                hash: void 0,
                href: void 0,
                path: void 0,
                port: void 0,
                query: {}
            }
        },
        ae = new(function () {
            function e() {
                this.version = c, this.schemaPage = ne, this.Logger = u, this.logger = new u("@barba/core"), this.plugins = [], this.hooks = N, this.dom = L, this.helpers = M, this.history = I, this.request = H, this.url = _
            }
            var s = e.prototype;
            return s.use = function (e, t) {
                var i = this.plugins;
                i.indexOf(e) > -1 ? this.logger.warn("Plugin [" + e.name + "] already installed.") : "function" == typeof e.install ? (e.install(this, t), i.push(e)) : this.logger.warn("Plugin [" + e.name + '] has no "install" method.')
            }, s.init = function (e) {
                var t = void 0 === e ? {} : e,
                    s = t.transitions,
                    n = void 0 === s ? [] : s,
                    a = t.views,
                    r = void 0 === a ? [] : a,
                    o = t.schema,
                    l = void 0 === o ? T : o,
                    d = t.requestError,
                    c = t.timeout,
                    h = void 0 === c ? 2e3 : c,
                    p = t.cacheIgnore,
                    m = void 0 !== p && p,
                    f = t.prefetchIgnore,
                    g = void 0 !== f && f,
                    v = t.preventRunning,
                    y = void 0 !== v && v,
                    b = t.prevent,
                    w = void 0 === b ? null : b,
                    x = t.debug,
                    E = t.logLevel;
                if (u.setLevel(!0 === (void 0 !== x && x) ? "debug" : void 0 === E ? "off" : E), this.logger.info(this.version), Object.keys(l).forEach((function (e) {
                        T[e] && (T[e] = l[e])
                    })), this.O = d, this.timeout = h, this.cacheIgnore = m, this.prefetchIgnore = g, this.preventRunning = y, this.T = this.dom.getWrapper(), !this.T) throw new Error("[@barba/core] No Barba wrapper found");
                this.T.setAttribute("aria-live", "polite"), this.S();
                var S = this.data.current;
                if (!S.container) throw new Error("[@barba/core] No Barba container found");
                if (this.cache = new W(m), this.prevent = new Z(g), this.transitions = new ie(n), this.views = new se(r), null !== w) {
                    if ("function" != typeof w) throw new Error("[@barba/core] Prevent should be a function");
                    this.prevent.add("preventCustom", w)
                }
                this.history.init(S.url.href, S.namespace), this.j = this.j.bind(this), this.M = this.M.bind(this), this.L = this.L.bind(this), this.$(), this.plugins.forEach((function (e) {
                    return e.init()
                }));
                var C = this.data;
                C.trigger = "barba", C.next = C.current, C.current = i({}, this.schemaPage), this.hooks.do("ready", C), this.once(C), this.S()
            }, s.destroy = function () {
                this.S(), this.q(), this.history.clear(), this.hooks.clear(), this.plugins = []
            }, s.force = function (e) {
                window.location.assign(e)
            }, s.go = function (e, t, i) {
                var s;
                if (void 0 === t && (t = "barba"), this.transitions.isRunning) this.force(e);
                else if (!(s = "popstate" === t ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(e) : this.prevent.run("sameUrl", null, null, e)) || this.transitions.hasSelf) {
                    if ("popstate" === t) {
                        var n = i.state;
                        null === n ? this.history.add(e, "tmp", null, !1) : (t = this.history.getDirection(n.index), this.history.add(e, n.ns, n.index, !1))
                    } else this.history.add(e, "tmp");
                    return i && (i.stopPropagation(), i.preventDefault()), this.page(e, t, s)
                }
            }, s.once = function (e) {
                try {
                    var t = this;
                    return Promise.resolve(t.hooks.do("beforeEnter", e)).then((function () {
                        function i() {
                            return Promise.resolve(t.hooks.do("afterEnter", e)).then((function () {}))
                        }
                        var s = function () {
                            if (t.transitions.hasOnce) {
                                var i = t.transitions.get(e, {
                                    once: !0
                                });
                                return Promise.resolve(t.transitions.doOnce({
                                    transition: i,
                                    data: e
                                })).then((function () {}))
                            }
                        }();
                        return s && s.then ? s.then(i) : i()
                    }))
                } catch (e) {
                    return Promise.reject(e)
                }
            }, s.page = function (e, t, s) {
                try {
                    var n = function () {
                            var e = a.data;
                            return Promise.resolve(a.hooks.do("page", e)).then((function () {
                                var t = l((function () {
                                    var t = a.transitions.get(e, {
                                        once: !1,
                                        self: s
                                    });
                                    return Promise.resolve(a.transitions.doPage({
                                        data: e,
                                        page: r,
                                        transition: t,
                                        wrapper: a.T
                                    })).then((function () {
                                        a.S()
                                    }))
                                }), (function () {
                                    0 === u.getLevel() && a.force(e.current.url.href)
                                }));
                                if (t && t.then) return t.then((function () {}))
                            }))
                        },
                        a = this;
                    a.data.next.url = i({
                        href: e
                    }, a.url.parse(e)), a.data.trigger = t;
                    var r = a.cache.has(e) ? a.cache.update(e, {
                            action: "click"
                        }).request : a.cache.set(e, a.request(e, a.timeout, a.onRequestError.bind(a, t)), "click").request,
                        o = function () {
                            if (a.transitions.shouldWait) return Promise.resolve($(r, a.data)).then((function () {}))
                        }();
                    return Promise.resolve(o && o.then ? o.then(n) : n())
                } catch (e) {
                    return Promise.reject(e)
                }
            }, s.onRequestError = function (e) {
                this.transitions.isRunning = !1;
                for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) i[s - 1] = arguments[s];
                var n = i[0],
                    a = i[1],
                    r = this.cache.getAction(n);
                return this.cache.delete(n), !(this.O && !1 === this.O(e, r, n, a) || ("click" === r && this.force(n), 1))
            }, s.prefetch = function (e) {
                var t = this;
                this.cache.has(e) || this.cache.set(e, this.request(e, this.timeout, this.onRequestError.bind(this, "barba")).catch((function (e) {
                    t.logger.error(e)
                })), "prefetch")
            }, s.$ = function () {
                !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.j), document.addEventListener("touchstart", this.j)), document.addEventListener("click", this.M), window.addEventListener("popstate", this.L)
            }, s.q = function () {
                !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.j), document.removeEventListener("touchstart", this.j)), document.removeEventListener("click", this.M), window.removeEventListener("popstate", this.L)
            }, s.j = function (e) {
                var t = this,
                    i = this.B(e);
                if (i) {
                    var s = this.dom.getHref(i);
                    this.prevent.checkHref(s) || this.cache.has(s) || this.cache.set(s, this.request(s, this.timeout, this.onRequestError.bind(this, i)).catch((function (e) {
                        t.logger.error(e)
                    })), "enter")
                }
            }, s.M = function (e) {
                var t = this.B(e);
                if (t) return this.transitions.isRunning && this.preventRunning ? (e.preventDefault(), void e.stopPropagation()) : void this.go(this.dom.getHref(t), t, e)
            }, s.L = function (e) {
                this.go(this.url.getHref(), "popstate", e)
            }, s.B = function (e) {
                for (var t = e.target; t && !this.dom.getHref(t);) t = t.parentNode;
                if (t && !this.prevent.checkLink(t, e, this.dom.getHref(t))) return t
            }, s.S = function () {
                var e = this.url.getHref(),
                    t = {
                        container: this.dom.getContainer(),
                        html: this.dom.getHtml(),
                        namespace: this.dom.getNamespace(),
                        url: i({
                            href: e
                        }, this.url.parse(e))
                    };
                this.D = {
                    current: t,
                    next: i({}, this.schemaPage),
                    trigger: void 0
                }, this.hooks.do("reset", this.data)
            }, t(e, [{
                key: "data",
                get: function () {
                    return this.D
                }
            }, {
                key: "wrapper",
                get: function () {
                    return this.T
                }
            }]), e
        }());
    const re = () => {
        ! function (e, t, i) {
            i = i || window;
            var s = !1;
            i.addEventListener(e, (function () {
                s || (s = !0, requestAnimationFrame((function () {
                    i.dispatchEvent(new CustomEvent(t)), s = !1
                })))
            }))
        }("resize", "optimizedResize")
    };
    class oe {
        constructor({
            beforeImage: e = "sz-before-image",
            afterImage: t = "sz-after-image",
            compareSliderClass: i = "sz-compare-slider",
            compareSliderIcon: s = !0
        } = {}) {
            this.beforeImage = e, this.afterImage = t, this.compareSliderClass = i, this.compareSliderIcon = s, this.isSliding = !1, this.compareSlider = "", this.sliderDivider = "", this.images = []
        }
        init() {
            this.afterImage = document.querySelector(`.${this.afterImage}`), this.beforeImage = document.querySelector(`.${this.beforeImage}`), this.images = document.querySelectorAll(".sz-compare-image img"), this.didLoadImages()
        }
        didLoadImages() {
            var e = 0;
            this.images.forEach((t, i) => {
                t.complete ? ++e === this.images.length && this.setInitialState() : t.addEventListener("error", (function () {
                    console.log("ComparisonSlider: Your images are not loaded correctly")
                }))
            })
        }
        setInitialState() {
            this.createCompareSlider()
        }
        createCompareSlider() {
            this.sliderDivider = document.createElement("DIV"), this.compareSlider = document.createElement("DIV");
            const e = this.afterImage.parentElement.offsetWidth,
                t = this.afterImage.parentElement.offsetHeight;
            if (this.compareSlider.setAttribute("class", this.compareSliderClass), this.sliderDivider.setAttribute("class", "sz-slider-divider"), this.afterImage.style.width = `${e/2}px`, this.afterImage.querySelector("img").style.height = `${t}px`, this.afterImage.parentElement.insertBefore(this.compareSlider, this.afterImage), this.afterImage.parentElement.insertBefore(this.sliderDivider, this.afterImage), !0 === this.compareSliderIcon) {
                const e = new Image,
                    t = this.compareSlider;
                e.src = "../../images/tempoteam/evolution/slider.svg", e.onload = function () {
                    t.appendChild(e), t.children[0].setAttribute("class", "sz-compare-slider-icon")
                }
            }
            this.compareSlider.style.top = `${t/2-this.compareSlider.offsetHeight/2}px`, this.compareSlider.style.left = `${e/2-this.compareSlider.offsetWidth/2}px`, this.sliderDivider.style.left = `${e/2-this.compareSlider.offsetWidth/2+23}px`, this.attachSliderEventListeners()
        }
        resizeHandler() {
            this.afterImage.style.width = `${this.afterImage.parentElement.offsetWidth/2}px`, this.afterImage.querySelector("img").style.height = `${this.afterImage.parentElement.offsetHeight}px`, this.compareSlider.style.top = `${this.afterImage.parentElement.offsetHeight/2-this.compareSlider.offsetHeight/2}px`, this.compareSlider.style.left = `${this.afterImage.parentElement.offsetWidth/2-this.compareSlider.offsetWidth/2}px`, this.sliderDivider.style.left = `${this.afterImage.parentElement.offsetWidth/2-this.compareSlider.offsetWidth/2+23}px`
        }
        attachSliderEventListeners() {
            this.compareSlider.addEventListener("mousedown", this.didClickSlider.bind(this)), window.addEventListener("mouseup", this.didReleaseSlider.bind(this)), this.compareSlider.addEventListener("touchstart", this.didClickSlider.bind(this)), window.addEventListener("touchend", this.didReleaseSlider.bind(this)), re(), window.addEventListener("optimizedResize", () => {
                this.resizeHandler()
            })
        }
        didClickSlider(e) {
            e.preventDefault(), this.isSliding = !0, window.addEventListener("mousemove", this.didMoveSlider.bind(this)), window.addEventListener("touchmove", this.didMoveSlider.bind(this))
        }
        didReleaseSlider() {
            this.isSliding = !1
        }
        didMoveSlider(e) {
            if (this.isSliding) {
                var t = this.getCursorPosition(e);
                t < 0 && (t = 0), t > this.beforeImage.offsetWidth && (t = this.beforeImage.offsetWidth), this.resizeImage(t)
            }
        }
        getCursorPosition(e) {
            var t = (void 0 !== (e = e || window.event).pageX ? e.pageX : e.touches[0].pageX) - this.afterImage.getBoundingClientRect().left;
            return t -= window.pageXOffset
        }
        resizeImage(e) {
            this.afterImage.style.width = `${e}px`, this.afterImage.querySelector("img").style.height = `${this.afterImage.parentElement.getBoundingClientRect().height}px`, this.compareSlider.style.left = `${this.afterImage.offsetWidth-this.compareSlider.offsetWidth/2}px`, this.sliderDivider.style.left = `${this.afterImage.offsetWidth-this.compareSlider.offsetWidth/2+23}px`
        }
    }
    var le = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

    function de(e, t) {
        return e(t = {
            exports: {}
        }, t.exports), t.exports
    }
    var ce = de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i() : t.EvEmitter = i()
            }("undefined" != typeof window ? window : le, (function () {
                function e() {}
                var t = e.prototype;
                return t.on = function (e, t) {
                    if (e && t) {
                        var i = this._events = this._events || {},
                            s = i[e] = i[e] || [];
                        return -1 == s.indexOf(t) && s.push(t), this
                    }
                }, t.once = function (e, t) {
                    if (e && t) {
                        this.on(e, t);
                        var i = this._onceEvents = this._onceEvents || {};
                        return (i[e] = i[e] || {})[t] = !0, this
                    }
                }, t.off = function (e, t) {
                    var i = this._events && this._events[e];
                    if (i && i.length) {
                        var s = i.indexOf(t);
                        return -1 != s && i.splice(s, 1), this
                    }
                }, t.emitEvent = function (e, t) {
                    var i = this._events && this._events[e];
                    if (i && i.length) {
                        i = i.slice(0), t = t || [];
                        for (var s = this._onceEvents && this._onceEvents[e], n = 0; n < i.length; n++) {
                            var a = i[n];
                            s && s[a] && (this.off(e, a), delete s[a]), a.apply(this, t)
                        }
                        return this
                    }
                }, t.allOff = function () {
                    delete this._events, delete this._onceEvents
                }, e
            }))
        })),
        he = de((function (e) {
            /*!
             * getSize v2.0.3
             * measure size of elements
             * MIT license
             */
            ! function (t, i) {
                e.exports ? e.exports = i() : t.getSize = i()
            }(window, (function () {
                function e(e) {
                    var t = parseFloat(e);
                    return -1 == e.indexOf("%") && !isNaN(t) && t
                }
                var t = "undefined" == typeof console ? function () {} : function (e) {
                        console.error(e)
                    },
                    i = ["paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "borderBottomWidth"],
                    s = i.length;

                function n(e) {
                    var i = getComputedStyle(e);
                    return i || t("Style returned " + i + ". Are you running this code in a hidden iframe on Firefox? See https://bit.ly/getsizebug1"), i
                }
                var a, r = !1;

                function o(t) {
                    if (function () {
                            if (!r) {
                                r = !0;
                                var t = document.createElement("div");
                                t.style.width = "200px", t.style.padding = "1px 2px 3px 4px", t.style.borderStyle = "solid", t.style.borderWidth = "1px 2px 3px 4px", t.style.boxSizing = "border-box";
                                var i = document.body || document.documentElement;
                                i.appendChild(t);
                                var s = n(t);
                                a = 200 == Math.round(e(s.width)), o.isBoxSizeOuter = a, i.removeChild(t)
                            }
                        }(), "string" == typeof t && (t = document.querySelector(t)), t && "object" == typeof t && t.nodeType) {
                        var l = n(t);
                        if ("none" == l.display) return function () {
                            for (var e = {
                                    width: 0,
                                    height: 0,
                                    innerWidth: 0,
                                    innerHeight: 0,
                                    outerWidth: 0,
                                    outerHeight: 0
                                }, t = 0; t < s; t++) {
                                e[i[t]] = 0
                            }
                            return e
                        }();
                        var d = {};
                        d.width = t.offsetWidth, d.height = t.offsetHeight;
                        for (var c = d.isBorderBox = "border-box" == l.boxSizing, h = 0; h < s; h++) {
                            var u = i[h],
                                p = l[u],
                                m = parseFloat(p);
                            d[u] = isNaN(m) ? 0 : m
                        }
                        var f = d.paddingLeft + d.paddingRight,
                            g = d.paddingTop + d.paddingBottom,
                            v = d.marginLeft + d.marginRight,
                            y = d.marginTop + d.marginBottom,
                            b = d.borderLeftWidth + d.borderRightWidth,
                            w = d.borderTopWidth + d.borderBottomWidth,
                            x = c && a,
                            E = e(l.width);
                        !1 !== E && (d.width = E + (x ? 0 : f + b));
                        var S = e(l.height);
                        return !1 !== S && (d.height = S + (x ? 0 : g + w)), d.innerWidth = d.width - (f + b), d.innerHeight = d.height - (g + w), d.outerWidth = d.width + v, d.outerHeight = d.height + y, d
                    }
                }
                return o
            }))
        })),
        ue = de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i() : t.matchesSelector = i()
            }(window, (function () {
                var e = function () {
                    var e = window.Element.prototype;
                    if (e.matches) return "matches";
                    if (e.matchesSelector) return "matchesSelector";
                    for (var t = ["webkit", "moz", "ms", "o"], i = 0; i < t.length; i++) {
                        var s = t[i] + "MatchesSelector";
                        if (e[s]) return s
                    }
                }();
                return function (t, i) {
                    return t[e](i)
                }
            }))
        })),
        pe = de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i(t, ue) : t.fizzyUIUtils = i(t, t.matchesSelector)
            }(window, (function (e, t) {
                var i = {
                        extend: function (e, t) {
                            for (var i in t) e[i] = t[i];
                            return e
                        },
                        modulo: function (e, t) {
                            return (e % t + t) % t
                        }
                    },
                    s = Array.prototype.slice;
                i.makeArray = function (e) {
                    return Array.isArray(e) ? e : null == e ? [] : "object" == typeof e && "number" == typeof e.length ? s.call(e) : [e]
                }, i.removeFrom = function (e, t) {
                    var i = e.indexOf(t); - 1 != i && e.splice(i, 1)
                }, i.getParent = function (e, i) {
                    for (; e.parentNode && e != document.body;)
                        if (e = e.parentNode, t(e, i)) return e
                }, i.getQueryElement = function (e) {
                    return "string" == typeof e ? document.querySelector(e) : e
                }, i.handleEvent = function (e) {
                    var t = "on" + e.type;
                    this[t] && this[t](e)
                }, i.filterFindElements = function (e, s) {
                    e = i.makeArray(e);
                    var n = [];
                    return e.forEach((function (e) {
                        if (e instanceof HTMLElement)
                            if (s) {
                                t(e, s) && n.push(e);
                                for (var i = e.querySelectorAll(s), a = 0; a < i.length; a++) n.push(i[a])
                            } else n.push(e)
                    })), n
                }, i.debounceMethod = function (e, t, i) {
                    i = i || 100;
                    var s = e.prototype[t],
                        n = t + "Timeout";
                    e.prototype[t] = function () {
                        var e = this[n];
                        clearTimeout(e);
                        var t = arguments,
                            a = this;
                        this[n] = setTimeout((function () {
                            s.apply(a, t), delete a[n]
                        }), i)
                    }
                }, i.docReady = function (e) {
                    var t = document.readyState;
                    "complete" == t || "interactive" == t ? setTimeout(e) : document.addEventListener("DOMContentLoaded", e)
                }, i.toDashed = function (e) {
                    return e.replace(/(.)([A-Z])/g, (function (e, t, i) {
                        return t + "-" + i
                    })).toLowerCase()
                };
                var n = e.console;
                return i.htmlInit = function (t, s) {
                    i.docReady((function () {
                        var a = i.toDashed(s),
                            r = "data-" + a,
                            o = document.querySelectorAll("[" + r + "]"),
                            l = document.querySelectorAll(".js-" + a),
                            d = i.makeArray(o).concat(i.makeArray(l)),
                            c = r + "-options",
                            h = e.jQuery;
                        d.forEach((function (e) {
                            var i, a = e.getAttribute(r) || e.getAttribute(c);
                            try {
                                i = a && JSON.parse(a)
                            } catch (t) {
                                return void(n && n.error("Error parsing " + r + " on " + e.className + ": " + t))
                            }
                            var o = new t(e, i);
                            h && h.data(e, s, o)
                        }))
                    }))
                }, i
            }))
        })),
        me = de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i(ce, he) : (t.Outlayer = {}, t.Outlayer.Item = i(t.EvEmitter, t.getSize))
            }(window, (function (e, t) {
                var i = document.documentElement.style,
                    s = "string" == typeof i.transition ? "transition" : "WebkitTransition",
                    n = "string" == typeof i.transform ? "transform" : "WebkitTransform",
                    a = {
                        WebkitTransition: "webkitTransitionEnd",
                        transition: "transitionend"
                    } [s],
                    r = {
                        transform: n,
                        transition: s,
                        transitionDuration: s + "Duration",
                        transitionProperty: s + "Property",
                        transitionDelay: s + "Delay"
                    };

                function o(e, t) {
                    e && (this.element = e, this.layout = t, this.position = {
                        x: 0,
                        y: 0
                    }, this._create())
                }
                var l = o.prototype = Object.create(e.prototype);
                l.constructor = o, l._create = function () {
                    this._transn = {
                        ingProperties: {},
                        clean: {},
                        onEnd: {}
                    }, this.css({
                        position: "absolute"
                    })
                }, l.handleEvent = function (e) {
                    var t = "on" + e.type;
                    this[t] && this[t](e)
                }, l.getSize = function () {
                    this.size = t(this.element)
                }, l.css = function (e) {
                    var t = this.element.style;
                    for (var i in e) {
                        t[r[i] || i] = e[i]
                    }
                }, l.getPosition = function () {
                    var e = getComputedStyle(this.element),
                        t = this.layout._getOption("originLeft"),
                        i = this.layout._getOption("originTop"),
                        s = e[t ? "left" : "right"],
                        n = e[i ? "top" : "bottom"],
                        a = parseFloat(s),
                        r = parseFloat(n),
                        o = this.layout.size; - 1 != s.indexOf("%") && (a = a / 100 * o.width), -1 != n.indexOf("%") && (r = r / 100 * o.height), a = isNaN(a) ? 0 : a, r = isNaN(r) ? 0 : r, a -= t ? o.paddingLeft : o.paddingRight, r -= i ? o.paddingTop : o.paddingBottom, this.position.x = a, this.position.y = r
                }, l.layoutPosition = function () {
                    var e = this.layout.size,
                        t = {},
                        i = this.layout._getOption("originLeft"),
                        s = this.layout._getOption("originTop"),
                        n = i ? "paddingLeft" : "paddingRight",
                        a = i ? "left" : "right",
                        r = i ? "right" : "left",
                        o = this.position.x + e[n];
                    t[a] = this.getXValue(o), t[r] = "";
                    var l = s ? "paddingTop" : "paddingBottom",
                        d = s ? "top" : "bottom",
                        c = s ? "bottom" : "top",
                        h = this.position.y + e[l];
                    t[d] = this.getYValue(h), t[c] = "", this.css(t), this.emitEvent("layout", [this])
                }, l.getXValue = function (e) {
                    var t = this.layout._getOption("horizontal");
                    return this.layout.options.percentPosition && !t ? e / this.layout.size.width * 100 + "%" : e + "px"
                }, l.getYValue = function (e) {
                    var t = this.layout._getOption("horizontal");
                    return this.layout.options.percentPosition && t ? e / this.layout.size.height * 100 + "%" : e + "px"
                }, l._transitionTo = function (e, t) {
                    this.getPosition();
                    var i = this.position.x,
                        s = this.position.y,
                        n = e == this.position.x && t == this.position.y;
                    if (this.setPosition(e, t), !n || this.isTransitioning) {
                        var a = e - i,
                            r = t - s,
                            o = {};
                        o.transform = this.getTranslate(a, r), this.transition({
                            to: o,
                            onTransitionEnd: {
                                transform: this.layoutPosition
                            },
                            isCleaning: !0
                        })
                    } else this.layoutPosition()
                }, l.getTranslate = function (e, t) {
                    return "translate3d(" + (e = this.layout._getOption("originLeft") ? e : -e) + "px, " + (t = this.layout._getOption("originTop") ? t : -t) + "px, 0)"
                }, l.goTo = function (e, t) {
                    this.setPosition(e, t), this.layoutPosition()
                }, l.moveTo = l._transitionTo, l.setPosition = function (e, t) {
                    this.position.x = parseFloat(e), this.position.y = parseFloat(t)
                }, l._nonTransition = function (e) {
                    for (var t in this.css(e.to), e.isCleaning && this._removeStyles(e.to), e.onTransitionEnd) e.onTransitionEnd[t].call(this)
                }, l.transition = function (e) {
                    if (parseFloat(this.layout.options.transitionDuration)) {
                        var t = this._transn;
                        for (var i in e.onTransitionEnd) t.onEnd[i] = e.onTransitionEnd[i];
                        for (i in e.to) t.ingProperties[i] = !0, e.isCleaning && (t.clean[i] = !0);
                        if (e.from) {
                            this.css(e.from);
                            this.element.offsetHeight;
                            null
                        }
                        this.enableTransition(e.to), this.css(e.to), this.isTransitioning = !0
                    } else this._nonTransition(e)
                };
                var d = "opacity," + n.replace(/([A-Z])/g, (function (e) {
                    return "-" + e.toLowerCase()
                }));
                l.enableTransition = function () {
                    if (!this.isTransitioning) {
                        var e = this.layout.options.transitionDuration;
                        e = "number" == typeof e ? e + "ms" : e, this.css({
                            transitionProperty: d,
                            transitionDuration: e,
                            transitionDelay: this.staggerDelay || 0
                        }), this.element.addEventListener(a, this, !1)
                    }
                }, l.onwebkitTransitionEnd = function (e) {
                    this.ontransitionend(e)
                }, l.onotransitionend = function (e) {
                    this.ontransitionend(e)
                };
                var c = {
                    "-webkit-transform": "transform"
                };
                l.ontransitionend = function (e) {
                    if (e.target === this.element) {
                        var t = this._transn,
                            i = c[e.propertyName] || e.propertyName;
                        if (delete t.ingProperties[i], function (e) {
                                for (var t in e) return !1;
                                return null, !0
                            }(t.ingProperties) && this.disableTransition(), i in t.clean && (this.element.style[e.propertyName] = "", delete t.clean[i]), i in t.onEnd) t.onEnd[i].call(this), delete t.onEnd[i];
                        this.emitEvent("transitionEnd", [this])
                    }
                }, l.disableTransition = function () {
                    this.removeTransitionStyles(), this.element.removeEventListener(a, this, !1), this.isTransitioning = !1
                }, l._removeStyles = function (e) {
                    var t = {};
                    for (var i in e) t[i] = "";
                    this.css(t)
                };
                var h = {
                    transitionProperty: "",
                    transitionDuration: "",
                    transitionDelay: ""
                };
                return l.removeTransitionStyles = function () {
                    this.css(h)
                }, l.stagger = function (e) {
                    e = isNaN(e) ? 0 : e, this.staggerDelay = e + "ms"
                }, l.removeElem = function () {
                    this.element.parentNode.removeChild(this.element), this.css({
                        display: ""
                    }), this.emitEvent("remove", [this])
                }, l.remove = function () {
                    s && parseFloat(this.layout.options.transitionDuration) ? (this.once("transitionEnd", (function () {
                        this.removeElem()
                    })), this.hide()) : this.removeElem()
                }, l.reveal = function () {
                    delete this.isHidden, this.css({
                        display: ""
                    });
                    var e = this.layout.options,
                        t = {};
                    t[this.getHideRevealTransitionEndProperty("visibleStyle")] = this.onRevealTransitionEnd, this.transition({
                        from: e.hiddenStyle,
                        to: e.visibleStyle,
                        isCleaning: !0,
                        onTransitionEnd: t
                    })
                }, l.onRevealTransitionEnd = function () {
                    this.isHidden || this.emitEvent("reveal")
                }, l.getHideRevealTransitionEndProperty = function (e) {
                    var t = this.layout.options[e];
                    if (t.opacity) return "opacity";
                    for (var i in t) return i
                }, l.hide = function () {
                    this.isHidden = !0, this.css({
                        display: ""
                    });
                    var e = this.layout.options,
                        t = {};
                    t[this.getHideRevealTransitionEndProperty("hiddenStyle")] = this.onHideTransitionEnd, this.transition({
                        from: e.visibleStyle,
                        to: e.hiddenStyle,
                        isCleaning: !0,
                        onTransitionEnd: t
                    })
                }, l.onHideTransitionEnd = function () {
                    this.isHidden && (this.css({
                        display: "none"
                    }), this.emitEvent("hide"))
                }, l.destroy = function () {
                    this.css({
                        position: "",
                        left: "",
                        right: "",
                        top: "",
                        bottom: "",
                        transition: "",
                        transform: ""
                    })
                }, o
            }))
        })),
        fe = de((function (e) {
            /*!
             * Outlayer v2.1.1
             * the brains and guts of a layout library
             * MIT license
             */
            ! function (t, i) {
                e.exports ? e.exports = i(t, ce, he, pe, me) : t.Outlayer = i(t, t.EvEmitter, t.getSize, t.fizzyUIUtils, t.Outlayer.Item)
            }(window, (function (e, t, i, s, n) {
                var a = e.console,
                    r = e.jQuery,
                    o = function () {},
                    l = 0,
                    d = {};

                function c(e, t) {
                    var i = s.getQueryElement(e);
                    if (i) {
                        this.element = i, r && (this.$element = r(this.element)), this.options = s.extend({}, this.constructor.defaults), this.option(t);
                        var n = ++l;
                        this.element.outlayerGUID = n, d[n] = this, this._create(), this._getOption("initLayout") && this.layout()
                    } else a && a.error("Bad element for " + this.constructor.namespace + ": " + (i || e))
                }
                c.namespace = "outlayer", c.Item = n, c.defaults = {
                    containerStyle: {
                        position: "relative"
                    },
                    initLayout: !0,
                    originLeft: !0,
                    originTop: !0,
                    resize: !0,
                    resizeContainer: !0,
                    transitionDuration: "0.4s",
                    hiddenStyle: {
                        opacity: 0,
                        transform: "scale(0.001)"
                    },
                    visibleStyle: {
                        opacity: 1,
                        transform: "scale(1)"
                    }
                };
                var h = c.prototype;

                function u(e) {
                    function t() {
                        e.apply(this, arguments)
                    }
                    return t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t
                }
                s.extend(h, t.prototype), h.option = function (e) {
                    s.extend(this.options, e)
                }, h._getOption = function (e) {
                    var t = this.constructor.compatOptions[e];
                    return t && void 0 !== this.options[t] ? this.options[t] : this.options[e]
                }, c.compatOptions = {
                    initLayout: "isInitLayout",
                    horizontal: "isHorizontal",
                    layoutInstant: "isLayoutInstant",
                    originLeft: "isOriginLeft",
                    originTop: "isOriginTop",
                    resize: "isResizeBound",
                    resizeContainer: "isResizingContainer"
                }, h._create = function () {
                    this.reloadItems(), this.stamps = [], this.stamp(this.options.stamp), s.extend(this.element.style, this.options.containerStyle), this._getOption("resize") && this.bindResize()
                }, h.reloadItems = function () {
                    this.items = this._itemize(this.element.children)
                }, h._itemize = function (e) {
                    for (var t = this._filterFindItemElements(e), i = this.constructor.Item, s = [], n = 0; n < t.length; n++) {
                        var a = new i(t[n], this);
                        s.push(a)
                    }
                    return s
                }, h._filterFindItemElements = function (e) {
                    return s.filterFindElements(e, this.options.itemSelector)
                }, h.getItemElements = function () {
                    return this.items.map((function (e) {
                        return e.element
                    }))
                }, h.layout = function () {
                    this._resetLayout(), this._manageStamps();
                    var e = this._getOption("layoutInstant"),
                        t = void 0 !== e ? e : !this._isLayoutInited;
                    this.layoutItems(this.items, t), this._isLayoutInited = !0
                }, h._init = h.layout, h._resetLayout = function () {
                    this.getSize()
                }, h.getSize = function () {
                    this.size = i(this.element)
                }, h._getMeasurement = function (e, t) {
                    var s, n = this.options[e];
                    n ? ("string" == typeof n ? s = this.element.querySelector(n) : n instanceof HTMLElement && (s = n), this[e] = s ? i(s)[t] : n) : this[e] = 0
                }, h.layoutItems = function (e, t) {
                    e = this._getItemsForLayout(e), this._layoutItems(e, t), this._postLayout()
                }, h._getItemsForLayout = function (e) {
                    return e.filter((function (e) {
                        return !e.isIgnored
                    }))
                }, h._layoutItems = function (e, t) {
                    if (this._emitCompleteOnItems("layout", e), e && e.length) {
                        var i = [];
                        e.forEach((function (e) {
                            var s = this._getItemLayoutPosition(e);
                            s.item = e, s.isInstant = t || e.isLayoutInstant, i.push(s)
                        }), this), this._processLayoutQueue(i)
                    }
                }, h._getItemLayoutPosition = function () {
                    return {
                        x: 0,
                        y: 0
                    }
                }, h._processLayoutQueue = function (e) {
                    this.updateStagger(), e.forEach((function (e, t) {
                        this._positionItem(e.item, e.x, e.y, e.isInstant, t)
                    }), this)
                }, h.updateStagger = function () {
                    var e = this.options.stagger;
                    if (null != e) return this.stagger = function (e) {
                        if ("number" == typeof e) return e;
                        var t = e.match(/(^\d*\.?\d*)(\w*)/),
                            i = t && t[1],
                            s = t && t[2];
                        if (!i.length) return 0;
                        i = parseFloat(i);
                        var n = p[s] || 1;
                        return i * n
                    }(e), this.stagger;
                    this.stagger = 0
                }, h._positionItem = function (e, t, i, s, n) {
                    s ? e.goTo(t, i) : (e.stagger(n * this.stagger), e.moveTo(t, i))
                }, h._postLayout = function () {
                    this.resizeContainer()
                }, h.resizeContainer = function () {
                    if (this._getOption("resizeContainer")) {
                        var e = this._getContainerSize();
                        e && (this._setContainerMeasure(e.width, !0), this._setContainerMeasure(e.height, !1))
                    }
                }, h._getContainerSize = o, h._setContainerMeasure = function (e, t) {
                    if (void 0 !== e) {
                        var i = this.size;
                        i.isBorderBox && (e += t ? i.paddingLeft + i.paddingRight + i.borderLeftWidth + i.borderRightWidth : i.paddingBottom + i.paddingTop + i.borderTopWidth + i.borderBottomWidth), e = Math.max(e, 0), this.element.style[t ? "width" : "height"] = e + "px"
                    }
                }, h._emitCompleteOnItems = function (e, t) {
                    var i = this;

                    function s() {
                        i.dispatchEvent(e + "Complete", null, [t])
                    }
                    var n = t.length;
                    if (t && n) {
                        var a = 0;
                        t.forEach((function (t) {
                            t.once(e, r)
                        }))
                    } else s();

                    function r() {
                        ++a == n && s()
                    }
                }, h.dispatchEvent = function (e, t, i) {
                    var s = t ? [t].concat(i) : i;
                    if (this.emitEvent(e, s), r)
                        if (this.$element = this.$element || r(this.element), t) {
                            var n = r.Event(t);
                            n.type = e, this.$element.trigger(n, i)
                        } else this.$element.trigger(e, i)
                }, h.ignore = function (e) {
                    var t = this.getItem(e);
                    t && (t.isIgnored = !0)
                }, h.unignore = function (e) {
                    var t = this.getItem(e);
                    t && delete t.isIgnored
                }, h.stamp = function (e) {
                    (e = this._find(e)) && (this.stamps = this.stamps.concat(e), e.forEach(this.ignore, this))
                }, h.unstamp = function (e) {
                    (e = this._find(e)) && e.forEach((function (e) {
                        s.removeFrom(this.stamps, e), this.unignore(e)
                    }), this)
                }, h._find = function (e) {
                    if (e) return "string" == typeof e && (e = this.element.querySelectorAll(e)), e = s.makeArray(e)
                }, h._manageStamps = function () {
                    this.stamps && this.stamps.length && (this._getBoundingRect(), this.stamps.forEach(this._manageStamp, this))
                }, h._getBoundingRect = function () {
                    var e = this.element.getBoundingClientRect(),
                        t = this.size;
                    this._boundingRect = {
                        left: e.left + t.paddingLeft + t.borderLeftWidth,
                        top: e.top + t.paddingTop + t.borderTopWidth,
                        right: e.right - (t.paddingRight + t.borderRightWidth),
                        bottom: e.bottom - (t.paddingBottom + t.borderBottomWidth)
                    }
                }, h._manageStamp = o, h._getElementOffset = function (e) {
                    var t = e.getBoundingClientRect(),
                        s = this._boundingRect,
                        n = i(e);
                    return {
                        left: t.left - s.left - n.marginLeft,
                        top: t.top - s.top - n.marginTop,
                        right: s.right - t.right - n.marginRight,
                        bottom: s.bottom - t.bottom - n.marginBottom
                    }
                }, h.handleEvent = s.handleEvent, h.bindResize = function () {
                    e.addEventListener("resize", this), this.isResizeBound = !0
                }, h.unbindResize = function () {
                    e.removeEventListener("resize", this), this.isResizeBound = !1
                }, h.onresize = function () {
                    this.resize()
                }, s.debounceMethod(c, "onresize", 100), h.resize = function () {
                    this.isResizeBound && this.needsResizeLayout() && this.layout()
                }, h.needsResizeLayout = function () {
                    var e = i(this.element);
                    return this.size && e && e.innerWidth !== this.size.innerWidth
                }, h.addItems = function (e) {
                    var t = this._itemize(e);
                    return t.length && (this.items = this.items.concat(t)), t
                }, h.appended = function (e) {
                    var t = this.addItems(e);
                    t.length && (this.layoutItems(t, !0), this.reveal(t))
                }, h.prepended = function (e) {
                    var t = this._itemize(e);
                    if (t.length) {
                        var i = this.items.slice(0);
                        this.items = t.concat(i), this._resetLayout(), this._manageStamps(), this.layoutItems(t, !0), this.reveal(t), this.layoutItems(i)
                    }
                }, h.reveal = function (e) {
                    if (this._emitCompleteOnItems("reveal", e), e && e.length) {
                        var t = this.updateStagger();
                        e.forEach((function (e, i) {
                            e.stagger(i * t), e.reveal()
                        }))
                    }
                }, h.hide = function (e) {
                    if (this._emitCompleteOnItems("hide", e), e && e.length) {
                        var t = this.updateStagger();
                        e.forEach((function (e, i) {
                            e.stagger(i * t), e.hide()
                        }))
                    }
                }, h.revealItemElements = function (e) {
                    var t = this.getItems(e);
                    this.reveal(t)
                }, h.hideItemElements = function (e) {
                    var t = this.getItems(e);
                    this.hide(t)
                }, h.getItem = function (e) {
                    for (var t = 0; t < this.items.length; t++) {
                        var i = this.items[t];
                        if (i.element == e) return i
                    }
                }, h.getItems = function (e) {
                    e = s.makeArray(e);
                    var t = [];
                    return e.forEach((function (e) {
                        var i = this.getItem(e);
                        i && t.push(i)
                    }), this), t
                }, h.remove = function (e) {
                    var t = this.getItems(e);
                    this._emitCompleteOnItems("remove", t), t && t.length && t.forEach((function (e) {
                        e.remove(), s.removeFrom(this.items, e)
                    }), this)
                }, h.destroy = function () {
                    var e = this.element.style;
                    e.height = "", e.position = "", e.width = "", this.items.forEach((function (e) {
                        e.destroy()
                    })), this.unbindResize();
                    var t = this.element.outlayerGUID;
                    delete d[t], delete this.element.outlayerGUID, r && r.removeData(this.element, this.constructor.namespace)
                }, c.data = function (e) {
                    var t = (e = s.getQueryElement(e)) && e.outlayerGUID;
                    return t && d[t]
                }, c.create = function (e, t) {
                    var i = u(c);
                    return i.defaults = s.extend({}, c.defaults), s.extend(i.defaults, t), i.compatOptions = s.extend({}, c.compatOptions), i.namespace = e, i.data = c.data, i.Item = u(n), s.htmlInit(i, e), r && r.bridget && r.bridget(e, i), i
                };
                var p = {
                    ms: 1,
                    s: 1e3
                };
                return c.Item = n, c
            }))
        })),
        ge = de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i(fe) : (t.Isotope = t.Isotope || {}, t.Isotope.Item = i(t.Outlayer))
            }(window, (function (e) {
                function t() {
                    e.Item.apply(this, arguments)
                }
                var i = t.prototype = Object.create(e.Item.prototype),
                    s = i._create;
                i._create = function () {
                    this.id = this.layout.itemGUID++, s.call(this), this.sortData = {}
                }, i.updateSortData = function () {
                    if (!this.isIgnored) {
                        this.sortData.id = this.id, this.sortData["original-order"] = this.id, this.sortData.random = Math.random();
                        var e = this.layout.options.getSortData,
                            t = this.layout._sorters;
                        for (var i in e) {
                            var s = t[i];
                            this.sortData[i] = s(this.element, this)
                        }
                    }
                };
                var n = i.destroy;
                return i.destroy = function () {
                    n.apply(this, arguments), this.css({
                        display: ""
                    })
                }, t
            }))
        })),
        ve = de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i(he, fe) : (t.Isotope = t.Isotope || {}, t.Isotope.LayoutMode = i(t.getSize, t.Outlayer))
            }(window, (function (e, t) {
                function i(e) {
                    this.isotope = e, e && (this.options = e.options[this.namespace], this.element = e.element, this.items = e.filteredItems, this.size = e.size)
                }
                var s = i.prototype;
                return ["_resetLayout", "_getItemLayoutPosition", "_manageStamp", "_getContainerSize", "_getElementOffset", "needsResizeLayout", "_getOption"].forEach((function (e) {
                    s[e] = function () {
                        return t.prototype[e].apply(this.isotope, arguments)
                    }
                })), s.needsVerticalResizeLayout = function () {
                    var t = e(this.isotope.element);
                    return this.isotope.size && t && t.innerHeight != this.isotope.size.innerHeight
                }, s._getMeasurement = function () {
                    this.isotope._getMeasurement.apply(this, arguments)
                }, s.getColumnWidth = function () {
                    this.getSegmentSize("column", "Width")
                }, s.getRowHeight = function () {
                    this.getSegmentSize("row", "Height")
                }, s.getSegmentSize = function (e, t) {
                    var i = e + t,
                        s = "outer" + t;
                    if (this._getMeasurement(i, s), !this[i]) {
                        var n = this.getFirstItemSize();
                        this[i] = n && n[s] || this.isotope.size["inner" + t]
                    }
                }, s.getFirstItemSize = function () {
                    var t = this.isotope.filteredItems[0];
                    return t && t.element && e(t.element)
                }, s.layout = function () {
                    this.isotope.layout.apply(this.isotope, arguments)
                }, s.getSize = function () {
                    this.isotope.getSize(), this.size = this.isotope.size
                }, i.modes = {}, i.create = function (e, t) {
                    function n() {
                        i.apply(this, arguments)
                    }
                    return n.prototype = Object.create(s), n.prototype.constructor = n, t && (n.options = t), n.prototype.namespace = e, i.modes[e] = n, n
                }, i
            }))
        })),
        ye = de((function (e) {
            /*!
             * Masonry v4.2.2
             * Cascading grid layout library
             * https://masonry.desandro.com
             * MIT License
             * by David DeSandro
             */
            ! function (t, i) {
                e.exports ? e.exports = i(fe, he) : t.Masonry = i(t.Outlayer, t.getSize)
            }(window, (function (e, t) {
                var i = e.create("masonry");
                i.compatOptions.fitWidth = "isFitWidth";
                var s = i.prototype;
                return s._resetLayout = function () {
                    this.getSize(), this._getMeasurement("columnWidth", "outerWidth"), this._getMeasurement("gutter", "outerWidth"), this.measureColumns(), this.colYs = [];
                    for (var e = 0; e < this.cols; e++) this.colYs.push(0);
                    this.maxY = 0, this.horizontalColIndex = 0
                }, s.measureColumns = function () {
                    if (this.getContainerWidth(), !this.columnWidth) {
                        var e = this.items[0],
                            i = e && e.element;
                        this.columnWidth = i && t(i).outerWidth || this.containerWidth
                    }
                    var s = this.columnWidth += this.gutter,
                        n = this.containerWidth + this.gutter,
                        a = n / s,
                        r = s - n % s;
                    a = Math[r && r < 1 ? "round" : "floor"](a), this.cols = Math.max(a, 1)
                }, s.getContainerWidth = function () {
                    var e = this._getOption("fitWidth") ? this.element.parentNode : this.element,
                        i = t(e);
                    this.containerWidth = i && i.innerWidth
                }, s._getItemLayoutPosition = function (e) {
                    e.getSize();
                    var t = e.size.outerWidth % this.columnWidth,
                        i = Math[t && t < 1 ? "round" : "ceil"](e.size.outerWidth / this.columnWidth);
                    i = Math.min(i, this.cols);
                    for (var s = this[this.options.horizontalOrder ? "_getHorizontalColPosition" : "_getTopColPosition"](i, e), n = {
                            x: this.columnWidth * s.col,
                            y: s.y
                        }, a = s.y + e.size.outerHeight, r = i + s.col, o = s.col; o < r; o++) this.colYs[o] = a;
                    return n
                }, s._getTopColPosition = function (e) {
                    var t = this._getTopColGroup(e),
                        i = Math.min.apply(Math, t);
                    return {
                        col: t.indexOf(i),
                        y: i
                    }
                }, s._getTopColGroup = function (e) {
                    if (e < 2) return this.colYs;
                    for (var t = [], i = this.cols + 1 - e, s = 0; s < i; s++) t[s] = this._getColGroupY(s, e);
                    return t
                }, s._getColGroupY = function (e, t) {
                    if (t < 2) return this.colYs[e];
                    var i = this.colYs.slice(e, e + t);
                    return Math.max.apply(Math, i)
                }, s._getHorizontalColPosition = function (e, t) {
                    var i = this.horizontalColIndex % this.cols;
                    i = e > 1 && i + e > this.cols ? 0 : i;
                    var s = t.size.outerWidth && t.size.outerHeight;
                    return this.horizontalColIndex = s ? i + e : this.horizontalColIndex, {
                        col: i,
                        y: this._getColGroupY(i, e)
                    }
                }, s._manageStamp = function (e) {
                    var i = t(e),
                        s = this._getElementOffset(e),
                        n = this._getOption("originLeft") ? s.left : s.right,
                        a = n + i.outerWidth,
                        r = Math.floor(n / this.columnWidth);
                    r = Math.max(0, r);
                    var o = Math.floor(a / this.columnWidth);
                    o -= a % this.columnWidth ? 0 : 1, o = Math.min(this.cols - 1, o);
                    for (var l = (this._getOption("originTop") ? s.top : s.bottom) + i.outerHeight, d = r; d <= o; d++) this.colYs[d] = Math.max(l, this.colYs[d])
                }, s._getContainerSize = function () {
                    this.maxY = Math.max.apply(Math, this.colYs);
                    var e = {
                        height: this.maxY
                    };
                    return this._getOption("fitWidth") && (e.width = this._getContainerFitWidth()), e
                }, s._getContainerFitWidth = function () {
                    for (var e = 0, t = this.cols; --t && 0 === this.colYs[t];) e++;
                    return (this.cols - e) * this.columnWidth - this.gutter
                }, s.needsResizeLayout = function () {
                    var e = this.containerWidth;
                    return this.getContainerWidth(), e != this.containerWidth
                }, i
            }))
        })),
        be = (de((function (e) {
            /*!
             * Masonry layout mode
             * sub-classes Masonry
             * https://masonry.desandro.com
             */
            ! function (t, i) {
                e.exports ? e.exports = i(ve, ye) : i(t.Isotope.LayoutMode, t.Masonry)
            }(window, (function (e, t) {
                var i = e.create("masonry"),
                    s = i.prototype,
                    n = {
                        _getElementOffset: !0,
                        layout: !0,
                        _getMeasurement: !0
                    };
                for (var a in t.prototype) n[a] || (s[a] = t.prototype[a]);
                var r = s.measureColumns;
                s.measureColumns = function () {
                    this.items = this.isotope.filteredItems, r.call(this)
                };
                var o = s._getOption;
                return s._getOption = function (e) {
                    return "fitWidth" == e ? void 0 !== this.options.isFitWidth ? this.options.isFitWidth : this.options.fitWidth : o.apply(this.isotope, arguments)
                }, i
            }))
        })), de((function (e, t) {
            var i, s;
            window, e.exports = (i = ve.create("fitRows"), (s = i.prototype)._resetLayout = function () {
                this.x = 0, this.y = 0, this.maxY = 0, this._getMeasurement("gutter", "outerWidth")
            }, s._getItemLayoutPosition = function (e) {
                e.getSize();
                var t = e.size.outerWidth + this.gutter,
                    i = this.isotope.size.innerWidth + this.gutter;
                0 !== this.x && t + this.x > i && (this.x = 0, this.y = this.maxY);
                var s = {
                    x: this.x,
                    y: this.y
                };
                return this.maxY = Math.max(this.maxY, this.y + e.size.outerHeight), this.x += t, s
            }, s._getContainerSize = function () {
                return {
                    height: this.maxY
                }
            }, i)
        })), de((function (e) {
            ! function (t, i) {
                e.exports ? e.exports = i(ve) : i(t.Isotope.LayoutMode)
            }(window, (function (e) {
                var t = e.create("vertical", {
                        horizontalAlignment: 0
                    }),
                    i = t.prototype;
                return i._resetLayout = function () {
                    this.y = 0
                }, i._getItemLayoutPosition = function (e) {
                    e.getSize();
                    var t = (this.isotope.size.innerWidth - e.size.outerWidth) * this.options.horizontalAlignment,
                        i = this.y;
                    return this.y += e.size.outerHeight, {
                        x: t,
                        y: i
                    }
                }, i._getContainerSize = function () {
                    return {
                        height: this.y
                    }
                }, t
            }))
        })), de((function (e) {
            /*!
             * Isotope v3.0.6
             *
             * Licensed GPLv3 for open source use
             * or Isotope Commercial License for commercial use
             *
             * https://isotope.metafizzy.co
             * Copyright 2010-2018 Metafizzy
             */
            ! function (t, i) {
                e.exports ? e.exports = i(t, fe, he, ue, pe, ge, ve) : t.Isotope = i(t, t.Outlayer, t.getSize, t.matchesSelector, t.fizzyUIUtils, t.Isotope.Item, t.Isotope.LayoutMode)
            }(window, (function (e, t, i, s, n, a, r) {
                var o = e.jQuery,
                    l = String.prototype.trim ? function (e) {
                        return e.trim()
                    } : function (e) {
                        return e.replace(/^\s+|\s+$/g, "")
                    },
                    d = t.create("isotope", {
                        layoutMode: "masonry",
                        isJQueryFiltering: !0,
                        sortAscending: !0
                    });
                d.Item = a, d.LayoutMode = r;
                var c = d.prototype;
                c._create = function () {
                    for (var e in this.itemGUID = 0, this._sorters = {}, this._getSorters(), t.prototype._create.call(this), this.modes = {}, this.filteredItems = this.items, this.sortHistory = ["original-order"], r.modes) this._initLayoutMode(e)
                }, c.reloadItems = function () {
                    this.itemGUID = 0, t.prototype.reloadItems.call(this)
                }, c._itemize = function () {
                    for (var e = t.prototype._itemize.apply(this, arguments), i = 0; i < e.length; i++) {
                        var s = e[i];
                        s.id = this.itemGUID++
                    }
                    return this._updateItemsSortData(e), e
                }, c._initLayoutMode = function (e) {
                    var t = r.modes[e],
                        i = this.options[e] || {};
                    this.options[e] = t.options ? n.extend(t.options, i) : i, this.modes[e] = new t(this)
                }, c.layout = function () {
                    this._isLayoutInited || !this._getOption("initLayout") ? this._layout() : this.arrange()
                }, c._layout = function () {
                    var e = this._getIsInstant();
                    this._resetLayout(), this._manageStamps(), this.layoutItems(this.filteredItems, e), this._isLayoutInited = !0
                }, c.arrange = function (e) {
                    this.option(e), this._getIsInstant();
                    var t = this._filter(this.items);
                    this.filteredItems = t.matches, this._bindArrangeComplete(), this._isInstant ? this._noTransition(this._hideReveal, [t]) : this._hideReveal(t), this._sort(), this._layout()
                }, c._init = c.arrange, c._hideReveal = function (e) {
                    this.reveal(e.needReveal), this.hide(e.needHide)
                }, c._getIsInstant = function () {
                    var e = this._getOption("layoutInstant"),
                        t = void 0 !== e ? e : !this._isLayoutInited;
                    return this._isInstant = t, t
                }, c._bindArrangeComplete = function () {
                    var e, t, i, s = this;

                    function n() {
                        e && t && i && s.dispatchEvent("arrangeComplete", null, [s.filteredItems])
                    }
                    this.once("layoutComplete", (function () {
                        e = !0, n()
                    })), this.once("hideComplete", (function () {
                        t = !0, n()
                    })), this.once("revealComplete", (function () {
                        i = !0, n()
                    }))
                }, c._filter = function (e) {
                    var t = this.options.filter;
                    t = t || "*";
                    for (var i = [], s = [], n = [], a = this._getFilterTest(t), r = 0; r < e.length; r++) {
                        var o = e[r];
                        if (!o.isIgnored) {
                            var l = a(o);
                            l && i.push(o), l && o.isHidden ? s.push(o) : l || o.isHidden || n.push(o)
                        }
                    }
                    return {
                        matches: i,
                        needReveal: s,
                        needHide: n
                    }
                }, c._getFilterTest = function (e) {
                    return o && this.options.isJQueryFiltering ? function (t) {
                        return o(t.element).is(e)
                    } : "function" == typeof e ? function (t) {
                        return e(t.element)
                    } : function (t) {
                        return s(t.element, e)
                    }
                }, c.updateSortData = function (e) {
                    var t;
                    e ? (e = n.makeArray(e), t = this.getItems(e)) : t = this.items, this._getSorters(), this._updateItemsSortData(t)
                }, c._getSorters = function () {
                    var e = this.options.getSortData;
                    for (var t in e) {
                        var i = e[t];
                        this._sorters[t] = h(i)
                    }
                }, c._updateItemsSortData = function (e) {
                    for (var t = e && e.length, i = 0; t && i < t; i++) {
                        e[i].updateSortData()
                    }
                };
                var h = function (e) {
                    if ("string" != typeof e) return e;
                    var t = l(e).split(" "),
                        i = t[0],
                        s = i.match(/^\[(.+)\]$/),
                        n = function (e, t) {
                            return e ? function (t) {
                                return t.getAttribute(e)
                            } : function (e) {
                                var i = e.querySelector(t);
                                return i && i.textContent
                            }
                        }(s && s[1], i),
                        a = d.sortDataParsers[t[1]];
                    return e = a ? function (e) {
                        return e && a(n(e))
                    } : function (e) {
                        return e && n(e)
                    }
                };
                d.sortDataParsers = {
                    parseInt: function (e) {
                        return parseInt(e, 10)
                    },
                    parseFloat: function (e) {
                        return parseFloat(e)
                    }
                }, c._sort = function () {
                    if (this.options.sortBy) {
                        var e = n.makeArray(this.options.sortBy);
                        this._getIsSameSortBy(e) || (this.sortHistory = e.concat(this.sortHistory));
                        var t = function (e, t) {
                            return function (i, s) {
                                for (var n = 0; n < e.length; n++) {
                                    var a = e[n],
                                        r = i.sortData[a],
                                        o = s.sortData[a];
                                    if (r > o || r < o) return (r > o ? 1 : -1) * ((void 0 !== t[a] ? t[a] : t) ? 1 : -1)
                                }
                                return 0
                            }
                        }(this.sortHistory, this.options.sortAscending);
                        this.filteredItems.sort(t)
                    }
                }, c._getIsSameSortBy = function (e) {
                    for (var t = 0; t < e.length; t++)
                        if (e[t] != this.sortHistory[t]) return !1;
                    return !0
                }, c._mode = function () {
                    var e = this.options.layoutMode,
                        t = this.modes[e];
                    if (!t) throw new Error("No layout mode: " + e);
                    return t.options = this.options[e], t
                }, c._resetLayout = function () {
                    t.prototype._resetLayout.call(this), this._mode()._resetLayout()
                }, c._getItemLayoutPosition = function (e) {
                    return this._mode()._getItemLayoutPosition(e)
                }, c._manageStamp = function (e) {
                    this._mode()._manageStamp(e)
                }, c._getContainerSize = function () {
                    return this._mode()._getContainerSize()
                }, c.needsResizeLayout = function () {
                    return this._mode().needsResizeLayout()
                }, c.appended = function (e) {
                    var t = this.addItems(e);
                    if (t.length) {
                        var i = this._filterRevealAdded(t);
                        this.filteredItems = this.filteredItems.concat(i)
                    }
                }, c.prepended = function (e) {
                    var t = this._itemize(e);
                    if (t.length) {
                        this._resetLayout(), this._manageStamps();
                        var i = this._filterRevealAdded(t);
                        this.layoutItems(this.filteredItems), this.filteredItems = i.concat(this.filteredItems), this.items = t.concat(this.items)
                    }
                }, c._filterRevealAdded = function (e) {
                    var t = this._filter(e);
                    return this.hide(t.needHide), this.reveal(t.matches), this.layoutItems(t.matches, !0), t.matches
                }, c.insert = function (e) {
                    var t = this.addItems(e);
                    if (t.length) {
                        var i, s, n = t.length;
                        for (i = 0; i < n; i++) s = t[i], this.element.appendChild(s.element);
                        var a = this._filter(t).matches;
                        for (i = 0; i < n; i++) t[i].isLayoutInstant = !0;
                        for (this.arrange(), i = 0; i < n; i++) delete t[i].isLayoutInstant;
                        this.reveal(a)
                    }
                };
                var u = c.remove;
                return c.remove = function (e) {
                    e = n.makeArray(e);
                    var t = this.getItems(e);
                    u.call(this, e);
                    for (var i = t && t.length, s = 0; i && s < i; s++) {
                        var a = t[s];
                        n.removeFrom(this.filteredItems, a)
                    }
                }, c.shuffle = function () {
                    for (var e = 0; e < this.items.length; e++) {
                        this.items[e].sortData.random = Math.random()
                    }
                    this.options.sortBy = "random", this._sort(), this._layout()
                }, c._noTransition = function (e, t) {
                    var i = this.options.transitionDuration;
                    this.options.transitionDuration = 0;
                    var s = e.apply(this, t);
                    return this.options.transitionDuration = i, s
                }, c.getFilteredItemElements = function () {
                    return this.filteredItems.map((function (e) {
                        return e.element
                    }))
                }, d
            }))
        })));
    class we {
        constructor(e, t) {
            t = t || document, this.gridContainer = t.querySelector(e), this.animationTimer, setTimeout(() => {
                this.isotope = new be(this.gridContainer, {
                    masonry: {
                        gutter: 64
                    },
                    hiddenStyle: {
                        opacity: 0,
                        transform: "translateY(120px)"
                    },
                    transitionDuration: 0
                }), this.isotope.getFilteredItemElements().forEach((e, t) => {
                    e.dataset.order = t
                }), this.gridTags = document.querySelectorAll(".project-tags .tag"), this.gridTags && this.gridTags.forEach(e => {
                    e.addEventListener("click", this.filter.bind(this, e))
                })
            }, 50)
        }
        filter(e) {
            const t = document.querySelector(".project-tags .tag.active");
            if (e == t) return;
            const i = e.dataset.tag;
            this.gridContainer.classList.add("is-hidden"), t && t.classList.remove("active"), e.classList.add("active"), clearTimeout(this.animationTimer), this.animationTimer = setTimeout(() => {
                this.isotope.arrange({
                    filter: e => "all" === i || e.dataset.tags.indexOf(i) > -1
                }), this.isotope.getFilteredItemElements().forEach((e, t) => {
                    e.dataset.order = t
                }), setTimeout(() => {
                    this.gridContainer.classList.remove("is-hidden")
                }, 50)
            }, 500)
        }
        destroy() {
            this.isotope && this.isotope.destroy()
        }
    }
    var xe = "undefined" == typeof document ? {
            body: {},
            addEventListener: function () {},
            removeEventListener: function () {},
            activeElement: {
                blur: function () {},
                nodeName: ""
            },
            querySelector: function () {
                return null
            },
            querySelectorAll: function () {
                return []
            },
            getElementById: function () {
                return null
            },
            createEvent: function () {
                return {
                    initEvent: function () {}
                }
            },
            createElement: function () {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute: function () {},
                    getElementsByTagName: function () {
                        return []
                    }
                }
            },
            location: {
                hash: ""
            }
        } : document,
        Ee = "undefined" == typeof window ? {
            document: xe,
            navigator: {
                userAgent: ""
            },
            location: {},
            history: {},
            CustomEvent: function () {
                return this
            },
            addEventListener: function () {},
            removeEventListener: function () {},
            getComputedStyle: function () {
                return {
                    getPropertyValue: function () {
                        return ""
                    }
                }
            },
            Image: function () {},
            Date: function () {},
            screen: {},
            setTimeout: function () {},
            clearTimeout: function () {}
        } : window;
    class Se {
        constructor(e) {
            const t = this;
            for (let i = 0; i < e.length; i += 1) t[i] = e[i];
            return t.length = e.length, this
        }
    }

    function Ce(e, t) {
        const i = [];
        let s = 0;
        if (e && !t && e instanceof Se) return e;
        if (e)
            if ("string" == typeof e) {
                let n, a;
                const r = e.trim();
                if (r.indexOf("<") >= 0 && r.indexOf(">") >= 0) {
                    let e = "div";
                    for (0 === r.indexOf("<li") && (e = "ul"), 0 === r.indexOf("<tr") && (e = "tbody"), 0 !== r.indexOf("<td") && 0 !== r.indexOf("<th") || (e = "tr"), 0 === r.indexOf("<tbody") && (e = "table"), 0 === r.indexOf("<option") && (e = "select"), (a = xe.createElement(e)).innerHTML = r, s = 0; s < a.childNodes.length; s += 1) i.push(a.childNodes[s])
                } else
                    for (n = t || "#" !== e[0] || e.match(/[ .<>:~]/) ? (t || xe).querySelectorAll(e.trim()) : [xe.getElementById(e.trim().split("#")[1])], s = 0; s < n.length; s += 1) n[s] && i.push(n[s])
            } else if (e.nodeType || e === Ee || e === xe) i.push(e);
        else if (e.length > 0 && e[0].nodeType)
            for (s = 0; s < e.length; s += 1) i.push(e[s]);
        return new Se(i)
    }

    function Te(e) {
        const t = [];
        for (let i = 0; i < e.length; i += 1) - 1 === t.indexOf(e[i]) && t.push(e[i]);
        return t
    }
    Ce.fn = Se.prototype, Ce.Class = Se, Ce.Dom7 = Se;
    const Le = {
        addClass: function (e) {
            if (void 0 === e) return this;
            const t = e.split(" ");
            for (let e = 0; e < t.length; e += 1)
                for (let i = 0; i < this.length; i += 1) void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.add(t[e]);
            return this
        },
        removeClass: function (e) {
            const t = e.split(" ");
            for (let e = 0; e < t.length; e += 1)
                for (let i = 0; i < this.length; i += 1) void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.remove(t[e]);
            return this
        },
        hasClass: function (e) {
            return !!this[0] && this[0].classList.contains(e)
        },
        toggleClass: function (e) {
            const t = e.split(" ");
            for (let e = 0; e < t.length; e += 1)
                for (let i = 0; i < this.length; i += 1) void 0 !== this[i] && void 0 !== this[i].classList && this[i].classList.toggle(t[e]);
            return this
        },
        attr: function (e, t) {
            if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0;
            for (let i = 0; i < this.length; i += 1)
                if (2 === arguments.length) this[i].setAttribute(e, t);
                else
                    for (const t in e) this[i][t] = e[t], this[i].setAttribute(t, e[t]);
            return this
        },
        removeAttr: function (e) {
            for (let t = 0; t < this.length; t += 1) this[t].removeAttribute(e);
            return this
        },
        data: function (e, t) {
            let i;
            if (void 0 !== t) {
                for (let s = 0; s < this.length; s += 1)(i = this[s]).dom7ElementDataStorage || (i.dom7ElementDataStorage = {}), i.dom7ElementDataStorage[e] = t;
                return this
            }
            if (i = this[0]) {
                if (i.dom7ElementDataStorage && e in i.dom7ElementDataStorage) return i.dom7ElementDataStorage[e];
                const t = i.getAttribute(`data-${e}`);
                return t || void 0
            }
        },
        transform: function (e) {
            for (let t = 0; t < this.length; t += 1) {
                const i = this[t].style;
                i.webkitTransform = e, i.transform = e
            }
            return this
        },
        transition: function (e) {
            "string" != typeof e && (e = `${e}ms`);
            for (let t = 0; t < this.length; t += 1) {
                const i = this[t].style;
                i.webkitTransitionDuration = e, i.transitionDuration = e
            }
            return this
        },
        on: function (...e) {
            let [t, i, s, n] = e;

            function a(e) {
                const t = e.target;
                if (!t) return;
                const n = e.target.dom7EventData || [];
                if (n.indexOf(e) < 0 && n.unshift(e), Ce(t).is(i)) s.apply(t, n);
                else {
                    const e = Ce(t).parents();
                    for (let t = 0; t < e.length; t += 1) Ce(e[t]).is(i) && s.apply(e[t], n)
                }
            }

            function r(e) {
                const t = e && e.target && e.target.dom7EventData || [];
                t.indexOf(e) < 0 && t.unshift(e), s.apply(this, t)
            }
            "function" == typeof e[1] && ([t, s, n] = e, i = void 0), n || (n = !1);
            const o = t.split(" ");
            let l;
            for (let e = 0; e < this.length; e += 1) {
                const t = this[e];
                if (i)
                    for (l = 0; l < o.length; l += 1) {
                        const e = o[l];
                        t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({
                            listener: s,
                            proxyListener: a
                        }), t.addEventListener(e, a, n)
                    } else
                        for (l = 0; l < o.length; l += 1) {
                            const e = o[l];
                            t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({
                                listener: s,
                                proxyListener: r
                            }), t.addEventListener(e, r, n)
                        }
            }
            return this
        },
        off: function (...e) {
            let [t, i, s, n] = e;
            "function" == typeof e[1] && ([t, s, n] = e, i = void 0), n || (n = !1);
            const a = t.split(" ");
            for (let e = 0; e < a.length; e += 1) {
                const t = a[e];
                for (let e = 0; e < this.length; e += 1) {
                    const a = this[e];
                    let r;
                    if (!i && a.dom7Listeners ? r = a.dom7Listeners[t] : i && a.dom7LiveListeners && (r = a.dom7LiveListeners[t]), r && r.length)
                        for (let e = r.length - 1; e >= 0; e -= 1) {
                            const i = r[e];
                            s && i.listener === s ? (a.removeEventListener(t, i.proxyListener, n), r.splice(e, 1)) : s && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === s ? (a.removeEventListener(t, i.proxyListener, n), r.splice(e, 1)) : s || (a.removeEventListener(t, i.proxyListener, n), r.splice(e, 1))
                        }
                }
            }
            return this
        },
        trigger: function (...e) {
            const t = e[0].split(" "),
                i = e[1];
            for (let s = 0; s < t.length; s += 1) {
                const n = t[s];
                for (let t = 0; t < this.length; t += 1) {
                    const s = this[t];
                    let a;
                    try {
                        a = new Ee.CustomEvent(n, {
                            detail: i,
                            bubbles: !0,
                            cancelable: !0
                        })
                    } catch (e) {
                        (a = xe.createEvent("Event")).initEvent(n, !0, !0), a.detail = i
                    }
                    s.dom7EventData = e.filter((e, t) => t > 0), s.dispatchEvent(a), s.dom7EventData = [], delete s.dom7EventData
                }
            }
            return this
        },
        transitionEnd: function (e) {
            const t = ["webkitTransitionEnd", "transitionend"],
                i = this;
            let s;

            function n(a) {
                if (a.target === this)
                    for (e.call(this, a), s = 0; s < t.length; s += 1) i.off(t[s], n)
            }
            if (e)
                for (s = 0; s < t.length; s += 1) i.on(t[s], n);
            return this
        },
        outerWidth: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
                }
                return this[0].offsetWidth
            }
            return null
        },
        outerHeight: function (e) {
            if (this.length > 0) {
                if (e) {
                    const e = this.styles();
                    return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
                }
                return this[0].offsetHeight
            }
            return null
        },
        offset: function () {
            if (this.length > 0) {
                const e = this[0],
                    t = e.getBoundingClientRect(),
                    i = xe.body,
                    s = e.clientTop || i.clientTop || 0,
                    n = e.clientLeft || i.clientLeft || 0,
                    a = e === Ee ? Ee.scrollY : e.scrollTop,
                    r = e === Ee ? Ee.scrollX : e.scrollLeft;
                return {
                    top: t.top + a - s,
                    left: t.left + r - n
                }
            }
            return null
        },
        css: function (e, t) {
            let i;
            if (1 === arguments.length) {
                if ("string" != typeof e) {
                    for (i = 0; i < this.length; i += 1)
                        for (let t in e) this[i].style[t] = e[t];
                    return this
                }
                if (this[0]) return Ee.getComputedStyle(this[0], null).getPropertyValue(e)
            }
            if (2 === arguments.length && "string" == typeof e) {
                for (i = 0; i < this.length; i += 1) this[i].style[e] = t;
                return this
            }
            return this
        },
        each: function (e) {
            if (!e) return this;
            for (let t = 0; t < this.length; t += 1)
                if (!1 === e.call(this[t], t, this[t])) return this;
            return this
        },
        html: function (e) {
            if (void 0 === e) return this[0] ? this[0].innerHTML : void 0;
            for (let t = 0; t < this.length; t += 1) this[t].innerHTML = e;
            return this
        },
        text: function (e) {
            if (void 0 === e) return this[0] ? this[0].textContent.trim() : null;
            for (let t = 0; t < this.length; t += 1) this[t].textContent = e;
            return this
        },
        is: function (e) {
            const t = this[0];
            let i, s;
            if (!t || void 0 === e) return !1;
            if ("string" == typeof e) {
                if (t.matches) return t.matches(e);
                if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e);
                if (t.msMatchesSelector) return t.msMatchesSelector(e);
                for (i = Ce(e), s = 0; s < i.length; s += 1)
                    if (i[s] === t) return !0;
                return !1
            }
            if (e === xe) return t === xe;
            if (e === Ee) return t === Ee;
            if (e.nodeType || e instanceof Se) {
                for (i = e.nodeType ? [e] : e, s = 0; s < i.length; s += 1)
                    if (i[s] === t) return !0;
                return !1
            }
            return !1
        },
        index: function () {
            let e, t = this[0];
            if (t) {
                for (e = 0; null !== (t = t.previousSibling);) 1 === t.nodeType && (e += 1);
                return e
            }
        },
        eq: function (e) {
            if (void 0 === e) return this;
            const t = this.length;
            let i;
            return new Se(e > t - 1 ? [] : e < 0 ? (i = t + e) < 0 ? [] : [this[i]] : [this[e]])
        },
        append: function (...e) {
            let t;
            for (let i = 0; i < e.length; i += 1) {
                t = e[i];
                for (let e = 0; e < this.length; e += 1)
                    if ("string" == typeof t) {
                        const i = xe.createElement("div");
                        for (i.innerHTML = t; i.firstChild;) this[e].appendChild(i.firstChild)
                    } else if (t instanceof Se)
                    for (let i = 0; i < t.length; i += 1) this[e].appendChild(t[i]);
                else this[e].appendChild(t)
            }
            return this
        },
        prepend: function (e) {
            let t, i;
            for (t = 0; t < this.length; t += 1)
                if ("string" == typeof e) {
                    const s = xe.createElement("div");
                    for (s.innerHTML = e, i = s.childNodes.length - 1; i >= 0; i -= 1) this[t].insertBefore(s.childNodes[i], this[t].childNodes[0])
                } else if (e instanceof Se)
                for (i = 0; i < e.length; i += 1) this[t].insertBefore(e[i], this[t].childNodes[0]);
            else this[t].insertBefore(e, this[t].childNodes[0]);
            return this
        },
        next: function (e) {
            return this.length > 0 ? e ? this[0].nextElementSibling && Ce(this[0].nextElementSibling).is(e) ? new Se([this[0].nextElementSibling]) : new Se([]) : this[0].nextElementSibling ? new Se([this[0].nextElementSibling]) : new Se([]) : new Se([])
        },
        nextAll: function (e) {
            const t = [];
            let i = this[0];
            if (!i) return new Se([]);
            for (; i.nextElementSibling;) {
                const s = i.nextElementSibling;
                e ? Ce(s).is(e) && t.push(s) : t.push(s), i = s
            }
            return new Se(t)
        },
        prev: function (e) {
            if (this.length > 0) {
                const t = this[0];
                return e ? t.previousElementSibling && Ce(t.previousElementSibling).is(e) ? new Se([t.previousElementSibling]) : new Se([]) : t.previousElementSibling ? new Se([t.previousElementSibling]) : new Se([])
            }
            return new Se([])
        },
        prevAll: function (e) {
            const t = [];
            let i = this[0];
            if (!i) return new Se([]);
            for (; i.previousElementSibling;) {
                const s = i.previousElementSibling;
                e ? Ce(s).is(e) && t.push(s) : t.push(s), i = s
            }
            return new Se(t)
        },
        parent: function (e) {
            const t = [];
            for (let i = 0; i < this.length; i += 1) null !== this[i].parentNode && (e ? Ce(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode));
            return Ce(Te(t))
        },
        parents: function (e) {
            const t = [];
            for (let i = 0; i < this.length; i += 1) {
                let s = this[i].parentNode;
                for (; s;) e ? Ce(s).is(e) && t.push(s) : t.push(s), s = s.parentNode
            }
            return Ce(Te(t))
        },
        closest: function (e) {
            let t = this;
            return void 0 === e ? new Se([]) : (t.is(e) || (t = t.parents(e).eq(0)), t)
        },
        find: function (e) {
            const t = [];
            for (let i = 0; i < this.length; i += 1) {
                const s = this[i].querySelectorAll(e);
                for (let e = 0; e < s.length; e += 1) t.push(s[e])
            }
            return new Se(t)
        },
        children: function (e) {
            const t = [];
            for (let i = 0; i < this.length; i += 1) {
                const s = this[i].childNodes;
                for (let i = 0; i < s.length; i += 1) e ? 1 === s[i].nodeType && Ce(s[i]).is(e) && t.push(s[i]) : 1 === s[i].nodeType && t.push(s[i])
            }
            return new Se(Te(t))
        },
        filter: function (e) {
            const t = [],
                i = this;
            for (let s = 0; s < i.length; s += 1) e.call(i[s], s, i[s]) && t.push(i[s]);
            return new Se(t)
        },
        remove: function () {
            for (let e = 0; e < this.length; e += 1) this[e].parentNode && this[e].parentNode.removeChild(this[e]);
            return this
        },
        add: function (...e) {
            const t = this;
            let i, s;
            for (i = 0; i < e.length; i += 1) {
                const n = Ce(e[i]);
                for (s = 0; s < n.length; s += 1) t[t.length] = n[s], t.length += 1
            }
            return t
        },
        styles: function () {
            return this[0] ? Ee.getComputedStyle(this[0], null) : {}
        }
    };
    Object.keys(Le).forEach(e => {
        Ce.fn[e] = Ce.fn[e] || Le[e]
    });
    const Ie = {
            deleteProps(e) {
                const t = e;
                Object.keys(t).forEach(e => {
                    try {
                        t[e] = null
                    } catch (e) {}
                    try {
                        delete t[e]
                    } catch (e) {}
                })
            },
            nextTick: (e, t = 0) => setTimeout(e, t),
            now: () => Date.now(),
            getTranslate(e, t = "x") {
                let i, s, n;
                const a = Ee.getComputedStyle(e, null);
                return Ee.WebKitCSSMatrix ? ((s = a.transform || a.webkitTransform).split(",").length > 6 && (s = s.split(", ").map(e => e.replace(",", ".")).join(", ")), n = new Ee.WebKitCSSMatrix("none" === s ? "" : s)) : i = (n = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,")).toString().split(","), "x" === t && (s = Ee.WebKitCSSMatrix ? n.m41 : 16 === i.length ? parseFloat(i[12]) : parseFloat(i[4])), "y" === t && (s = Ee.WebKitCSSMatrix ? n.m42 : 16 === i.length ? parseFloat(i[13]) : parseFloat(i[5])), s || 0
            },
            parseUrlQuery(e) {
                const t = {};
                let i, s, n, a, r = e || Ee.location.href;
                if ("string" == typeof r && r.length)
                    for (a = (s = (r = r.indexOf("?") > -1 ? r.replace(/\S*\?/, "") : "").split("&").filter(e => "" !== e)).length, i = 0; i < a; i += 1) n = s[i].replace(/#\S+/g, "").split("="), t[decodeURIComponent(n[0])] = void 0 === n[1] ? void 0 : decodeURIComponent(n[1]) || "";
                return t
            },
            isObject: e => "object" == typeof e && null !== e && e.constructor && e.constructor === Object,
            extend(...e) {
                const t = Object(e[0]);
                for (let i = 1; i < e.length; i += 1) {
                    const s = e[i];
                    if (null != s) {
                        const e = Object.keys(Object(s));
                        for (let i = 0, n = e.length; i < n; i += 1) {
                            const n = e[i],
                                a = Object.getOwnPropertyDescriptor(s, n);
                            void 0 !== a && a.enumerable && (Ie.isObject(t[n]) && Ie.isObject(s[n]) ? Ie.extend(t[n], s[n]) : !Ie.isObject(t[n]) && Ie.isObject(s[n]) ? (t[n] = {}, Ie.extend(t[n], s[n])) : t[n] = s[n])
                        }
                    }
                }
                return t
            }
        },
        $e = {
            touch: Ee.Modernizr && !0 === Ee.Modernizr.touch || !!(Ee.navigator.maxTouchPoints > 0 || "ontouchstart" in Ee || Ee.DocumentTouch && xe instanceof Ee.DocumentTouch),
            pointerEvents: !!Ee.PointerEvent && "maxTouchPoints" in Ee.navigator && Ee.navigator.maxTouchPoints > 0,
            observer: "MutationObserver" in Ee || "WebkitMutationObserver" in Ee,
            passiveListener: function () {
                let e = !1;
                try {
                    const t = Object.defineProperty({}, "passive", {
                        get() {
                            e = !0
                        }
                    });
                    Ee.addEventListener("testPassiveListener", null, t)
                } catch (e) {}
                return e
            }(),
            gestures: "ongesturestart" in Ee
        };
    class ze {
        constructor(e = {}) {
            const t = this;
            t.params = e, t.eventsListeners = {}, t.params && t.params.on && Object.keys(t.params.on).forEach(e => {
                t.on(e, t.params.on[e])
            })
        }
        on(e, t, i) {
            const s = this;
            if ("function" != typeof t) return s;
            const n = i ? "unshift" : "push";
            return e.split(" ").forEach(e => {
                s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][n](t)
            }), s
        }
        once(e, t, i) {
            const s = this;
            if ("function" != typeof t) return s;

            function n(...i) {
                t.apply(s, i), s.off(e, n), n.f7proxy && delete n.f7proxy
            }
            return n.f7proxy = t, s.on(e, n, i)
        }
        off(e, t) {
            const i = this;
            return i.eventsListeners ? (e.split(" ").forEach(e => {
                void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].length && i.eventsListeners[e].forEach((s, n) => {
                    (s === t || s.f7proxy && s.f7proxy === t) && i.eventsListeners[e].splice(n, 1)
                })
            }), i) : i
        }
        emit(...e) {
            const t = this;
            if (!t.eventsListeners) return t;
            let i, s, n;
            return "string" == typeof e[0] || Array.isArray(e[0]) ? (i = e[0], s = e.slice(1, e.length), n = t) : (i = e[0].events, s = e[0].data, n = e[0].context || t), (Array.isArray(i) ? i : i.split(" ")).forEach(e => {
                if (t.eventsListeners && t.eventsListeners[e]) {
                    const i = [];
                    t.eventsListeners[e].forEach(e => {
                        i.push(e)
                    }), i.forEach(e => {
                        e.apply(n, s)
                    })
                }
            }), t
        }
        useModulesParams(e) {
            const t = this;
            t.modules && Object.keys(t.modules).forEach(i => {
                const s = t.modules[i];
                s.params && Ie.extend(e, s.params)
            })
        }
        useModules(e = {}) {
            const t = this;
            t.modules && Object.keys(t.modules).forEach(i => {
                const s = t.modules[i],
                    n = e[i] || {};
                s.instance && Object.keys(s.instance).forEach(e => {
                    const i = s.instance[e];
                    t[e] = "function" == typeof i ? i.bind(t) : i
                }), s.on && t.on && Object.keys(s.on).forEach(e => {
                    t.on(e, s.on[e])
                }), s.create && s.create.bind(t)(n)
            })
        }
        static set components(e) {
            this.use && this.use(e)
        }
        static installModule(e, ...t) {
            const i = this;
            i.prototype.modules || (i.prototype.modules = {});
            const s = e.name || `${Object.keys(i.prototype.modules).length}_${Ie.now()}`;
            return i.prototype.modules[s] = e, e.proto && Object.keys(e.proto).forEach(t => {
                i.prototype[t] = e.proto[t]
            }), e.static && Object.keys(e.static).forEach(t => {
                i[t] = e.static[t]
            }), e.install && e.install.apply(i, t), i
        }
        static use(e, ...t) {
            const i = this;
            return Array.isArray(e) ? (e.forEach(e => i.installModule(e)), i) : i.installModule(e, ...t)
        }
    }
    var Me = {
        updateSize: function () {
            const e = this;
            let t, i;
            const s = e.$el;
            t = void 0 !== e.params.width ? e.params.width : s[0].clientWidth, i = void 0 !== e.params.height ? e.params.height : s[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(s.css("padding-left"), 10) - parseInt(s.css("padding-right"), 10), i = i - parseInt(s.css("padding-top"), 10) - parseInt(s.css("padding-bottom"), 10), Ie.extend(e, {
                width: t,
                height: i,
                size: e.isHorizontal() ? t : i
            }))
        },
        updateSlides: function () {
            const e = this,
                t = e.params,
                {
                    $wrapperEl: i,
                    size: s,
                    rtlTranslate: n,
                    wrongRTL: a
                } = e,
                r = e.virtual && t.virtual.enabled,
                o = r ? e.virtual.slides.length : e.slides.length,
                l = i.children(`.${e.params.slideClass}`),
                d = r ? e.virtual.slides.length : l.length;
            let c = [];
            const h = [],
                u = [];

            function p(e) {
                return !t.cssMode || e !== l.length - 1
            }
            let m = t.slidesOffsetBefore;
            "function" == typeof m && (m = t.slidesOffsetBefore.call(e));
            let f = t.slidesOffsetAfter;
            "function" == typeof f && (f = t.slidesOffsetAfter.call(e));
            const g = e.snapGrid.length,
                v = e.snapGrid.length;
            let y, b, w = t.spaceBetween,
                x = -m,
                E = 0,
                S = 0;
            if (void 0 === s) return;
            "string" == typeof w && w.indexOf("%") >= 0 && (w = parseFloat(w.replace("%", "")) / 100 * s), e.virtualSize = -w, n ? l.css({
                marginLeft: "",
                marginTop: ""
            }) : l.css({
                marginRight: "",
                marginBottom: ""
            }), t.slidesPerColumn > 1 && (y = Math.floor(d / t.slidesPerColumn) === d / e.params.slidesPerColumn ? d : Math.ceil(d / t.slidesPerColumn) * t.slidesPerColumn, "auto" !== t.slidesPerView && "row" === t.slidesPerColumnFill && (y = Math.max(y, t.slidesPerView * t.slidesPerColumn)));
            const C = t.slidesPerColumn,
                T = y / C,
                L = Math.floor(d / t.slidesPerColumn);
            for (let i = 0; i < d; i += 1) {
                b = 0;
                const n = l.eq(i);
                if (t.slidesPerColumn > 1) {
                    let s, a, r;
                    if ("row" === t.slidesPerColumnFill && t.slidesPerGroup > 1) {
                        const e = Math.floor(i / (t.slidesPerGroup * t.slidesPerColumn)),
                            o = i - t.slidesPerColumn * t.slidesPerGroup * e,
                            l = 0 === e ? t.slidesPerGroup : Math.min(Math.ceil((d - e * C * t.slidesPerGroup) / C), t.slidesPerGroup);
                        s = (a = o - (r = Math.floor(o / l)) * l + e * t.slidesPerGroup) + r * y / C, n.css({
                            "-webkit-box-ordinal-group": s,
                            "-moz-box-ordinal-group": s,
                            "-ms-flex-order": s,
                            "-webkit-order": s,
                            order: s
                        })
                    } else "column" === t.slidesPerColumnFill ? (r = i - (a = Math.floor(i / C)) * C, (a > L || a === L && r === C - 1) && (r += 1) >= C && (r = 0, a += 1)) : a = i - (r = Math.floor(i / T)) * T;
                    n.css(`margin-${e.isHorizontal()?"top":"left"}`, 0 !== r && t.spaceBetween && `${t.spaceBetween}px`)
                }
                if ("none" !== n.css("display")) {
                    if ("auto" === t.slidesPerView) {
                        const i = Ee.getComputedStyle(n[0], null),
                            s = n[0].style.transform,
                            a = n[0].style.webkitTransform;
                        if (s && (n[0].style.transform = "none"), a && (n[0].style.webkitTransform = "none"), t.roundLengths) b = e.isHorizontal() ? n.outerWidth(!0) : n.outerHeight(!0);
                        else if (e.isHorizontal()) {
                            const e = parseFloat(i.getPropertyValue("width")),
                                t = parseFloat(i.getPropertyValue("padding-left")),
                                s = parseFloat(i.getPropertyValue("padding-right")),
                                n = parseFloat(i.getPropertyValue("margin-left")),
                                a = parseFloat(i.getPropertyValue("margin-right")),
                                r = i.getPropertyValue("box-sizing");
                            b = r && "border-box" === r ? e + n + a : e + t + s + n + a
                        } else {
                            const e = parseFloat(i.getPropertyValue("height")),
                                t = parseFloat(i.getPropertyValue("padding-top")),
                                s = parseFloat(i.getPropertyValue("padding-bottom")),
                                n = parseFloat(i.getPropertyValue("margin-top")),
                                a = parseFloat(i.getPropertyValue("margin-bottom")),
                                r = i.getPropertyValue("box-sizing");
                            b = r && "border-box" === r ? e + n + a : e + t + s + n + a
                        }
                        s && (n[0].style.transform = s), a && (n[0].style.webkitTransform = a), t.roundLengths && (b = Math.floor(b))
                    } else b = (s - (t.slidesPerView - 1) * w) / t.slidesPerView, t.roundLengths && (b = Math.floor(b)), l[i] && (e.isHorizontal() ? l[i].style.width = `${b}px` : l[i].style.height = `${b}px`);
                    l[i] && (l[i].swiperSlideSize = b), u.push(b), t.centeredSlides ? (x = x + b / 2 + E / 2 + w, 0 === E && 0 !== i && (x = x - s / 2 - w), 0 === i && (x = x - s / 2 - w), Math.abs(x) < .001 && (x = 0), t.roundLengths && (x = Math.floor(x)), S % t.slidesPerGroup == 0 && c.push(x), h.push(x)) : (t.roundLengths && (x = Math.floor(x)), S % t.slidesPerGroup == 0 && c.push(x), h.push(x), x = x + b + w), e.virtualSize += b + w, E = b, S += 1
                }
            }
            let I;
            if (e.virtualSize = Math.max(e.virtualSize, s) + f, n && a && ("slide" === t.effect || "coverflow" === t.effect) && i.css({
                    width: `${e.virtualSize+t.spaceBetween}px`
                }), t.setWrapperSize && (e.isHorizontal() ? i.css({
                    width: `${e.virtualSize+t.spaceBetween}px`
                }) : i.css({
                    height: `${e.virtualSize+t.spaceBetween}px`
                })), t.slidesPerColumn > 1 && (e.virtualSize = (b + t.spaceBetween) * y, e.virtualSize = Math.ceil(e.virtualSize / t.slidesPerColumn) - t.spaceBetween, e.isHorizontal() ? i.css({
                    width: `${e.virtualSize+t.spaceBetween}px`
                }) : i.css({
                    height: `${e.virtualSize+t.spaceBetween}px`
                }), t.centeredSlides)) {
                I = [];
                for (let i = 0; i < c.length; i += 1) {
                    let s = c[i];
                    t.roundLengths && (s = Math.floor(s)), c[i] < e.virtualSize + c[0] && I.push(s)
                }
                c = I
            }
            if (!t.centeredSlides) {
                I = [];
                for (let i = 0; i < c.length; i += 1) {
                    let n = c[i];
                    t.roundLengths && (n = Math.floor(n)), c[i] <= e.virtualSize - s && I.push(n)
                }
                c = I, Math.floor(e.virtualSize - s) - Math.floor(c[c.length - 1]) > 1 && c.push(e.virtualSize - s)
            }
            if (0 === c.length && (c = [0]), 0 !== t.spaceBetween && (e.isHorizontal() ? n ? l.filter(p).css({
                    marginLeft: `${w}px`
                }) : l.filter(p).css({
                    marginRight: `${w}px`
                }) : l.filter(p).css({
                    marginBottom: `${w}px`
                })), t.centeredSlides && t.centeredSlidesBounds) {
                let e = 0;
                u.forEach(i => {
                    e += i + (t.spaceBetween ? t.spaceBetween : 0)
                });
                const i = (e -= t.spaceBetween) - s;
                c = c.map(e => e < 0 ? -m : e > i ? i + f : e)
            }
            if (t.centerInsufficientSlides) {
                let e = 0;
                if (u.forEach(i => {
                        e += i + (t.spaceBetween ? t.spaceBetween : 0)
                    }), (e -= t.spaceBetween) < s) {
                    const t = (s - e) / 2;
                    c.forEach((e, i) => {
                        c[i] = e - t
                    }), h.forEach((e, i) => {
                        h[i] = e + t
                    })
                }
            }
            Ie.extend(e, {
                slides: l,
                snapGrid: c,
                slidesGrid: h,
                slidesSizesGrid: u
            }), d !== o && e.emit("slidesLengthChange"), c.length !== g && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), h.length !== v && e.emit("slidesGridLengthChange"), (t.watchSlidesProgress || t.watchSlidesVisibility) && e.updateSlidesOffset()
        },
        updateAutoHeight: function (e) {
            const t = this,
                i = [];
            let s, n = 0;
            if ("number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed), "auto" !== t.params.slidesPerView && t.params.slidesPerView > 1)
                for (s = 0; s < Math.ceil(t.params.slidesPerView); s += 1) {
                    const e = t.activeIndex + s;
                    if (e > t.slides.length) break;
                    i.push(t.slides.eq(e)[0])
                } else i.push(t.slides.eq(t.activeIndex)[0]);
            for (s = 0; s < i.length; s += 1)
                if (void 0 !== i[s]) {
                    const e = i[s].offsetHeight;
                    n = e > n ? e : n
                } n && t.$wrapperEl.css("height", `${n}px`)
        },
        updateSlidesOffset: function () {
            const e = this,
                t = e.slides;
            for (let i = 0; i < t.length; i += 1) t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop
        },
        updateSlidesProgress: function (e = this && this.translate || 0) {
            const t = this,
                i = t.params,
                {
                    slides: s,
                    rtlTranslate: n
                } = t;
            if (0 === s.length) return;
            void 0 === s[0].swiperSlideOffset && t.updateSlidesOffset();
            let a = -e;
            n && (a = e), s.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = [];
            for (let e = 0; e < s.length; e += 1) {
                const r = s[e],
                    o = (a + (i.centeredSlides ? t.minTranslate() : 0) - r.swiperSlideOffset) / (r.swiperSlideSize + i.spaceBetween);
                if (i.watchSlidesVisibility) {
                    const n = -(a - r.swiperSlideOffset),
                        o = n + t.slidesSizesGrid[e];
                    (n >= 0 && n < t.size - 1 || o > 1 && o <= t.size || n <= 0 && o >= t.size) && (t.visibleSlides.push(r), t.visibleSlidesIndexes.push(e), s.eq(e).addClass(i.slideVisibleClass))
                }
                r.progress = n ? -o : o
            }
            t.visibleSlides = Ce(t.visibleSlides)
        },
        updateProgress: function (e) {
            const t = this;
            if (void 0 === e) {
                const i = t.rtlTranslate ? -1 : 1;
                e = t && t.translate && t.translate * i || 0
            }
            const i = t.params,
                s = t.maxTranslate() - t.minTranslate();
            let {
                progress: n,
                isBeginning: a,
                isEnd: r
            } = t;
            const o = a,
                l = r;
            0 === s ? (n = 0, a = !0, r = !0) : (a = (n = (e - t.minTranslate()) / s) <= 0, r = n >= 1), Ie.extend(t, {
                progress: n,
                isBeginning: a,
                isEnd: r
            }), (i.watchSlidesProgress || i.watchSlidesVisibility) && t.updateSlidesProgress(e), a && !o && t.emit("reachBeginning toEdge"), r && !l && t.emit("reachEnd toEdge"), (o && !a || l && !r) && t.emit("fromEdge"), t.emit("progress", n)
        },
        updateSlidesClasses: function () {
            const e = this,
                {
                    slides: t,
                    params: i,
                    $wrapperEl: s,
                    activeIndex: n,
                    realIndex: a
                } = e,
                r = e.virtual && i.virtual.enabled;
            let o;
            t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), (o = r ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${n}"]`) : t.eq(n)).addClass(i.slideActiveClass), i.loop && (o.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${a}"]`).addClass(i.slideDuplicateActiveClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${a}"]`).addClass(i.slideDuplicateActiveClass));
            let l = o.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass);
            i.loop && 0 === l.length && (l = t.eq(0)).addClass(i.slideNextClass);
            let d = o.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass);
            i.loop && 0 === d.length && (d = t.eq(-1)).addClass(i.slidePrevClass), i.loop && (l.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), d.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass))
        },
        updateActiveIndex: function (e) {
            const t = this,
                i = t.rtlTranslate ? t.translate : -t.translate,
                {
                    slidesGrid: s,
                    snapGrid: n,
                    params: a,
                    activeIndex: r,
                    realIndex: o,
                    snapIndex: l
                } = t;
            let d, c = e;
            if (void 0 === c) {
                for (let e = 0; e < s.length; e += 1) void 0 !== s[e + 1] ? i >= s[e] && i < s[e + 1] - (s[e + 1] - s[e]) / 2 ? c = e : i >= s[e] && i < s[e + 1] && (c = e + 1) : i >= s[e] && (c = e);
                a.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0)
            }
            if ((d = n.indexOf(i) >= 0 ? n.indexOf(i) : Math.floor(c / a.slidesPerGroup)) >= n.length && (d = n.length - 1), c === r) return void(d !== l && (t.snapIndex = d, t.emit("snapIndexChange")));
            const h = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
            Ie.extend(t, {
                snapIndex: d,
                realIndex: h,
                previousIndex: r,
                activeIndex: c
            }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), o !== h && t.emit("realIndexChange"), (t.initialized || t.runCallbacksOnInit) && t.emit("slideChange")
        },
        updateClickedSlide: function (e) {
            const t = this,
                i = t.params,
                s = Ce(e.target).closest(`.${i.slideClass}`)[0];
            let n = !1;
            if (s)
                for (let e = 0; e < t.slides.length; e += 1) t.slides[e] === s && (n = !0);
            if (!s || !n) return t.clickedSlide = void 0, void(t.clickedIndex = void 0);
            t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(Ce(s).attr("data-swiper-slide-index"), 10) : t.clickedIndex = Ce(s).index(), i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
        }
    };
    var Pe = {
        getTranslate: function (e = (this.isHorizontal() ? "x" : "y")) {
            const {
                params: t,
                rtlTranslate: i,
                translate: s,
                $wrapperEl: n
            } = this;
            if (t.virtualTranslate) return i ? -s : s;
            if (t.cssMode) return s;
            let a = Ie.getTranslate(n[0], e);
            return i && (a = -a), a || 0
        },
        setTranslate: function (e, t) {
            const i = this,
                {
                    rtlTranslate: s,
                    params: n,
                    $wrapperEl: a,
                    wrapperEl: r,
                    progress: o
                } = i;
            let l, d = 0,
                c = 0;
            i.isHorizontal() ? d = s ? -e : e : c = e, n.roundLengths && (d = Math.floor(d), c = Math.floor(c)), n.cssMode ? r[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -d : -c : n.virtualTranslate || a.transform(`translate3d(${d}px, ${c}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? d : c;
            const h = i.maxTranslate() - i.minTranslate();
            (l = 0 === h ? 0 : (e - i.minTranslate()) / h) !== o && i.updateProgress(e), i.emit("setTranslate", i.translate, t)
        },
        minTranslate: function () {
            return -this.snapGrid[0]
        },
        maxTranslate: function () {
            return -this.snapGrid[this.snapGrid.length - 1]
        },
        translateTo: function (e = 0, t = this.params.speed, i = !0, s = !0, n) {
            const a = this,
                {
                    params: r,
                    wrapperEl: o
                } = a;
            if (a.animating && r.preventInteractionOnTransition) return !1;
            const l = a.minTranslate(),
                d = a.maxTranslate();
            let c;
            if (c = s && e > l ? l : s && e < d ? d : e, a.updateProgress(c), r.cssMode) {
                const e = a.isHorizontal();
                return 0 === t ? o[e ? "scrollLeft" : "scrollTop"] = -c : o.scrollTo ? o.scrollTo({
                    [e ? "left" : "top"]: -c,
                    behavior: "smooth"
                }) : o[e ? "scrollLeft" : "scrollTop"] = -c, !0
            }
            return 0 === t ? (a.setTransition(0), a.setTranslate(c), i && (a.emit("beforeTransitionStart", t, n), a.emit("transitionEnd"))) : (a.setTransition(t), a.setTranslate(c), i && (a.emit("beforeTransitionStart", t, n), a.emit("transitionStart")), a.animating || (a.animating = !0, a.onTranslateToWrapperTransitionEnd || (a.onTranslateToWrapperTransitionEnd = function (e) {
                a && !a.destroyed && e.target === this && (a.$wrapperEl[0].removeEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].removeEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd), a.onTranslateToWrapperTransitionEnd = null, delete a.onTranslateToWrapperTransitionEnd, i && a.emit("transitionEnd"))
            }), a.$wrapperEl[0].addEventListener("transitionend", a.onTranslateToWrapperTransitionEnd), a.$wrapperEl[0].addEventListener("webkitTransitionEnd", a.onTranslateToWrapperTransitionEnd))), !0
        }
    };
    var ke = {
        setTransition: function (e, t) {
            const i = this;
            i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t)
        },
        transitionStart: function (e = !0, t) {
            const i = this,
                {
                    activeIndex: s,
                    params: n,
                    previousIndex: a
                } = i;
            if (n.cssMode) return;
            n.autoHeight && i.updateAutoHeight();
            let r = t;
            if (r || (r = s > a ? "next" : s < a ? "prev" : "reset"), i.emit("transitionStart"), e && s !== a) {
                if ("reset" === r) return void i.emit("slideResetTransitionStart");
                i.emit("slideChangeTransitionStart"), "next" === r ? i.emit("slideNextTransitionStart") : i.emit("slidePrevTransitionStart")
            }
        },
        transitionEnd: function (e = !0, t) {
            const i = this,
                {
                    activeIndex: s,
                    previousIndex: n,
                    params: a
                } = i;
            if (i.animating = !1, a.cssMode) return;
            i.setTransition(0);
            let r = t;
            if (r || (r = s > n ? "next" : s < n ? "prev" : "reset"), i.emit("transitionEnd"), e && s !== n) {
                if ("reset" === r) return void i.emit("slideResetTransitionEnd");
                i.emit("slideChangeTransitionEnd"), "next" === r ? i.emit("slideNextTransitionEnd") : i.emit("slidePrevTransitionEnd")
            }
        }
    };
    var Oe = {
        slideTo: function (e = 0, t = this.params.speed, i = !0, s) {
            const n = this;
            let a = e;
            a < 0 && (a = 0);
            const {
                params: r,
                snapGrid: o,
                slidesGrid: l,
                previousIndex: d,
                activeIndex: c,
                rtlTranslate: h,
                wrapperEl: u
            } = n;
            if (n.animating && r.preventInteractionOnTransition) return !1;
            let p = Math.floor(a / r.slidesPerGroup);
            p >= o.length && (p = o.length - 1), (c || r.initialSlide || 0) === (d || 0) && i && n.emit("beforeSlideChangeStart");
            const m = -o[p];
            if (n.updateProgress(m), r.normalizeSlideIndex)
                for (let e = 0; e < l.length; e += 1) - Math.floor(100 * m) >= Math.floor(100 * l[e]) && (a = e);
            if (n.initialized && a !== c) {
                if (!n.allowSlideNext && m < n.translate && m < n.minTranslate()) return !1;
                if (!n.allowSlidePrev && m > n.translate && m > n.maxTranslate() && (c || 0) !== a) return !1
            }
            let f;
            if (f = a > c ? "next" : a < c ? "prev" : "reset", h && -m === n.translate || !h && m === n.translate) return n.updateActiveIndex(a), r.autoHeight && n.updateAutoHeight(), n.updateSlidesClasses(), "slide" !== r.effect && n.setTranslate(m), "reset" !== f && (n.transitionStart(i, f), n.transitionEnd(i, f)), !1;
            if (r.cssMode) {
                const e = n.isHorizontal();
                return 0 === t ? u[e ? "scrollLeft" : "scrollTop"] = -m : u.scrollTo ? u.scrollTo({
                    [e ? "left" : "top"]: -m,
                    behavior: "smooth"
                }) : u[e ? "scrollLeft" : "scrollTop"] = -m, !0
            }
            return 0 === t ? (n.setTransition(0), n.setTranslate(m), n.updateActiveIndex(a), n.updateSlidesClasses(), n.emit("beforeTransitionStart", t, s), n.transitionStart(i, f), n.transitionEnd(i, f)) : (n.setTransition(t), n.setTranslate(m), n.updateActiveIndex(a), n.updateSlidesClasses(), n.emit("beforeTransitionStart", t, s), n.transitionStart(i, f), n.animating || (n.animating = !0, n.onSlideToWrapperTransitionEnd || (n.onSlideToWrapperTransitionEnd = function (e) {
                n && !n.destroyed && e.target === this && (n.$wrapperEl[0].removeEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener("webkitTransitionEnd", n.onSlideToWrapperTransitionEnd), n.onSlideToWrapperTransitionEnd = null, delete n.onSlideToWrapperTransitionEnd, n.transitionEnd(i, f))
            }), n.$wrapperEl[0].addEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener("webkitTransitionEnd", n.onSlideToWrapperTransitionEnd))), !0
        },
        slideToLoop: function (e = 0, t = this.params.speed, i = !0, s) {
            const n = this;
            let a = e;
            return n.params.loop && (a += n.loopedSlides), n.slideTo(a, t, i, s)
        },
        slideNext: function (e = this.params.speed, t = !0, i) {
            const s = this,
                {
                    params: n,
                    animating: a
                } = s;
            return n.loop ? !a && (s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft, s.slideTo(s.activeIndex + n.slidesPerGroup, e, t, i)) : s.slideTo(s.activeIndex + n.slidesPerGroup, e, t, i)
        },
        slidePrev: function (e = this.params.speed, t = !0, i) {
            const s = this,
                {
                    params: n,
                    animating: a,
                    snapGrid: r,
                    slidesGrid: o,
                    rtlTranslate: l
                } = s;
            if (n.loop) {
                if (a) return !1;
                s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft
            }

            function d(e) {
                return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e)
            }
            const c = d(l ? s.translate : -s.translate),
                h = r.map(e => d(e));
            o.map(e => d(e)), r[h.indexOf(c)];
            let u, p = r[h.indexOf(c) - 1];
            return void 0 === p && n.cssMode && r.forEach(e => {
                !p && c >= e && (p = e)
            }), void 0 !== p && (u = o.indexOf(p)) < 0 && (u = s.activeIndex - 1), s.slideTo(u, e, t, i)
        },
        slideReset: function (e = this.params.speed, t = !0, i) {
            return this.slideTo(this.activeIndex, e, t, i)
        },
        slideToClosest: function (e = this.params.speed, t = !0, i, s = .5) {
            const n = this;
            let a = n.activeIndex;
            const r = Math.floor(a / n.params.slidesPerGroup),
                o = n.rtlTranslate ? n.translate : -n.translate;
            if (o >= n.snapGrid[r]) {
                const e = n.snapGrid[r];
                o - e > (n.snapGrid[r + 1] - e) * s && (a += n.params.slidesPerGroup)
            } else {
                const e = n.snapGrid[r - 1];
                o - e <= (n.snapGrid[r] - e) * s && (a -= n.params.slidesPerGroup)
            }
            return a = Math.max(a, 0), a = Math.min(a, n.snapGrid.length - 1), n.slideTo(a, e, t, i)
        },
        slideToClickedSlide: function () {
            const e = this,
                {
                    params: t,
                    $wrapperEl: i
                } = e,
                s = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView;
            let n, a = e.clickedIndex;
            if (t.loop) {
                if (e.animating) return;
                n = parseInt(Ce(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? a < e.loopedSlides - s / 2 || a > e.slides.length - e.loopedSlides + s / 2 ? (e.loopFix(), a = i.children(`.${t.slideClass}[data-swiper-slide-index="${n}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), Ie.nextTick(() => {
                    e.slideTo(a)
                })) : e.slideTo(a) : a > e.slides.length - s ? (e.loopFix(), a = i.children(`.${t.slideClass}[data-swiper-slide-index="${n}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), Ie.nextTick(() => {
                    e.slideTo(a)
                })) : e.slideTo(a)
            } else e.slideTo(a)
        }
    };
    var Ae = {
        loopCreate: function () {
            const e = this,
                {
                    params: t,
                    $wrapperEl: i
                } = e;
            i.children(`.${t.slideClass}.${t.slideDuplicateClass}`).remove();
            let s = i.children(`.${t.slideClass}`);
            if (t.loopFillGroupWithBlank) {
                const e = t.slidesPerGroup - s.length % t.slidesPerGroup;
                if (e !== t.slidesPerGroup) {
                    for (let s = 0; s < e; s += 1) {
                        const e = Ce(xe.createElement("div")).addClass(`${t.slideClass} ${t.slideBlankClass}`);
                        i.append(e)
                    }
                    s = i.children(`.${t.slideClass}`)
                }
            }
            "auto" !== t.slidesPerView || t.loopedSlides || (t.loopedSlides = s.length), e.loopedSlides = Math.ceil(parseFloat(t.loopedSlides || t.slidesPerView, 10)), e.loopedSlides += t.loopAdditionalSlides, e.loopedSlides > s.length && (e.loopedSlides = s.length);
            const n = [],
                a = [];
            s.each((t, i) => {
                const r = Ce(i);
                t < e.loopedSlides && a.push(i), t < s.length && t >= s.length - e.loopedSlides && n.push(i), r.attr("data-swiper-slide-index", t)
            });
            for (let e = 0; e < a.length; e += 1) i.append(Ce(a[e].cloneNode(!0)).addClass(t.slideDuplicateClass));
            for (let e = n.length - 1; e >= 0; e -= 1) i.prepend(Ce(n[e].cloneNode(!0)).addClass(t.slideDuplicateClass))
        },
        loopFix: function () {
            const e = this,
                {
                    activeIndex: t,
                    slides: i,
                    loopedSlides: s,
                    allowSlidePrev: n,
                    allowSlideNext: a,
                    snapGrid: r,
                    rtlTranslate: o
                } = e;
            let l;
            e.allowSlidePrev = !0, e.allowSlideNext = !0;
            const d = -r[t] - e.getTranslate();
            if (t < s) {
                l = i.length - 3 * s + t, l += s, e.slideTo(l, 0, !1, !0) && 0 !== d && e.setTranslate((o ? -e.translate : e.translate) - d)
            } else if (t >= i.length - s) {
                l = -i.length + t + s, l += s, e.slideTo(l, 0, !1, !0) && 0 !== d && e.setTranslate((o ? -e.translate : e.translate) - d)
            }
            e.allowSlidePrev = n, e.allowSlideNext = a
        },
        loopDestroy: function () {
            const {
                $wrapperEl: e,
                params: t,
                slides: i
            } = this;
            e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index")
        }
    };
    var De = {
        setGrabCursor: function (e) {
            if ($e.touch || !this.params.simulateTouch || this.params.watchOverflow && this.isLocked || this.params.cssMode) return;
            const t = this.el;
            t.style.cursor = "move", t.style.cursor = e ? "-webkit-grabbing" : "-webkit-grab", t.style.cursor = e ? "-moz-grabbin" : "-moz-grab", t.style.cursor = e ? "grabbing" : "grab"
        },
        unsetGrabCursor: function () {
            $e.touch || this.params.watchOverflow && this.isLocked || this.params.cssMode || (this.el.style.cursor = "")
        }
    };
    var _e = {
        appendSlide: function (e) {
            const t = this,
                {
                    $wrapperEl: i,
                    params: s
                } = t;
            if (s.loop && t.loopDestroy(), "object" == typeof e && "length" in e)
                for (let t = 0; t < e.length; t += 1) e[t] && i.append(e[t]);
            else i.append(e);
            s.loop && t.loopCreate(), s.observer && $e.observer || t.update()
        },
        prependSlide: function (e) {
            const t = this,
                {
                    params: i,
                    $wrapperEl: s,
                    activeIndex: n
                } = t;
            i.loop && t.loopDestroy();
            let a = n + 1;
            if ("object" == typeof e && "length" in e) {
                for (let t = 0; t < e.length; t += 1) e[t] && s.prepend(e[t]);
                a = n + e.length
            } else s.prepend(e);
            i.loop && t.loopCreate(), i.observer && $e.observer || t.update(), t.slideTo(a, 0, !1)
        },
        addSlide: function (e, t) {
            const i = this,
                {
                    $wrapperEl: s,
                    params: n,
                    activeIndex: a
                } = i;
            let r = a;
            n.loop && (r -= i.loopedSlides, i.loopDestroy(), i.slides = s.children(`.${n.slideClass}`));
            const o = i.slides.length;
            if (e <= 0) return void i.prependSlide(t);
            if (e >= o) return void i.appendSlide(t);
            let l = r > e ? r + 1 : r;
            const d = [];
            for (let t = o - 1; t >= e; t -= 1) {
                const e = i.slides.eq(t);
                e.remove(), d.unshift(e)
            }
            if ("object" == typeof t && "length" in t) {
                for (let e = 0; e < t.length; e += 1) t[e] && s.append(t[e]);
                l = r > e ? r + t.length : r
            } else s.append(t);
            for (let e = 0; e < d.length; e += 1) s.append(d[e]);
            n.loop && i.loopCreate(), n.observer && $e.observer || i.update(), n.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1)
        },
        removeSlide: function (e) {
            const t = this,
                {
                    params: i,
                    $wrapperEl: s,
                    activeIndex: n
                } = t;
            let a = n;
            i.loop && (a -= t.loopedSlides, t.loopDestroy(), t.slides = s.children(`.${i.slideClass}`));
            let r, o = a;
            if ("object" == typeof e && "length" in e) {
                for (let i = 0; i < e.length; i += 1) r = e[i], t.slides[r] && t.slides.eq(r).remove(), r < o && (o -= 1);
                o = Math.max(o, 0)
            } else r = e, t.slides[r] && t.slides.eq(r).remove(), r < o && (o -= 1), o = Math.max(o, 0);
            i.loop && t.loopCreate(), i.observer && $e.observer || t.update(), i.loop ? t.slideTo(o + t.loopedSlides, 0, !1) : t.slideTo(o, 0, !1)
        },
        removeAllSlides: function () {
            const e = this,
                t = [];
            for (let i = 0; i < e.slides.length; i += 1) t.push(i);
            e.removeSlide(t)
        }
    };
    const He = function () {
        const e = Ee.navigator.platform,
            t = Ee.navigator.userAgent,
            i = {
                ios: !1,
                android: !1,
                androidChrome: !1,
                desktop: !1,
                iphone: !1,
                ipod: !1,
                ipad: !1,
                edge: !1,
                ie: !1,
                firefox: !1,
                macos: !1,
                windows: !1,
                cordova: !(!Ee.cordova && !Ee.phonegap),
                phonegap: !(!Ee.cordova && !Ee.phonegap),
                electron: !1
            },
            s = Ee.screen.width,
            n = Ee.screen.height,
            a = t.match(/(Android);?[\s\/]+([\d.]+)?/);
        let r = t.match(/(iPad).*OS\s([\d_]+)/);
        const o = t.match(/(iPod)(.*OS\s([\d_]+))?/),
            l = !r && t.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
            d = t.indexOf("MSIE ") >= 0 || t.indexOf("Trident/") >= 0,
            c = t.indexOf("Edge/") >= 0,
            h = t.indexOf("Gecko/") >= 0 && t.indexOf("Firefox/") >= 0,
            u = "Win32" === e,
            p = t.toLowerCase().indexOf("electron") >= 0;
        let m = "MacIntel" === e;
        return !r && m && $e.touch && (1024 === s && 1366 === n || 834 === s && 1194 === n || 834 === s && 1112 === n || 768 === s && 1024 === n) && (r = t.match(/(Version)\/([\d.]+)/), m = !1), i.ie = d, i.edge = c, i.firefox = h, a && !u && (i.os = "android", i.osVersion = a[2], i.android = !0, i.androidChrome = t.toLowerCase().indexOf("chrome") >= 0), (r || l || o) && (i.os = "ios", i.ios = !0), l && !o && (i.osVersion = l[2].replace(/_/g, "."), i.iphone = !0), r && (i.osVersion = r[2].replace(/_/g, "."), i.ipad = !0), o && (i.osVersion = o[3] ? o[3].replace(/_/g, ".") : null, i.ipod = !0), i.ios && i.osVersion && t.indexOf("Version/") >= 0 && "10" === i.osVersion.split(".")[0] && (i.osVersion = t.toLowerCase().split("version/")[1].split(" ")[0]), i.webView = !(!(l || r || o) || !t.match(/.*AppleWebKit(?!.*Safari)/i) && !Ee.navigator.standalone) || Ee.matchMedia && Ee.matchMedia("(display-mode: standalone)").matches, i.webview = i.webView, i.standalone = i.webView, i.desktop = !(i.ios || i.android) || p, i.desktop && (i.electron = p, i.macos = m, i.windows = u, i.macos && (i.os = "macos"), i.windows && (i.os = "windows")), i.pixelRatio = Ee.devicePixelRatio || 1, i
    }();

    function Be(e) {
        const t = this,
            i = t.touchEventsData,
            {
                params: s,
                touches: n
            } = t;
        if (t.animating && s.preventInteractionOnTransition) return;
        let a = e;
        a.originalEvent && (a = a.originalEvent);
        const r = Ce(a.target);
        if ("wrapper" === s.touchEventsTarget && !r.closest(t.wrapperEl).length) return;
        if (i.isTouchEvent = "touchstart" === a.type, !i.isTouchEvent && "which" in a && 3 === a.which) return;
        if (!i.isTouchEvent && "button" in a && a.button > 0) return;
        if (i.isTouched && i.isMoved) return;
        if (s.noSwiping && r.closest(s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`)[0]) return void(t.allowClick = !0);
        if (s.swipeHandler && !r.closest(s.swipeHandler)[0]) return;
        n.currentX = "touchstart" === a.type ? a.targetTouches[0].pageX : a.pageX, n.currentY = "touchstart" === a.type ? a.targetTouches[0].pageY : a.pageY;
        const o = n.currentX,
            l = n.currentY,
            d = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
            c = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
        if (!d || !(o <= c || o >= Ee.screen.width - c)) {
            if (Ie.extend(i, {
                    isTouched: !0,
                    isMoved: !1,
                    allowTouchCallbacks: !0,
                    isScrolling: void 0,
                    startMoving: void 0
                }), n.startX = o, n.startY = l, i.touchStartTime = Ie.now(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, s.threshold > 0 && (i.allowThresholdMove = !1), "touchstart" !== a.type) {
                let e = !0;
                r.is(i.formElements) && (e = !1), xe.activeElement && Ce(xe.activeElement).is(i.formElements) && xe.activeElement !== r[0] && xe.activeElement.blur();
                const n = e && t.allowTouchMove && s.touchStartPreventDefault;
                (s.touchStartForcePreventDefault || n) && a.preventDefault()
            }
            t.emit("touchStart", a)
        }
    }

    function qe(e) {
        const t = this,
            i = t.touchEventsData,
            {
                params: s,
                touches: n,
                rtlTranslate: a
            } = t;
        let r = e;
        if (r.originalEvent && (r = r.originalEvent), !i.isTouched) return void(i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", r));
        if (i.isTouchEvent && "mousemove" === r.type) return;
        const o = "touchmove" === r.type && r.targetTouches && (r.targetTouches[0] || r.changedTouches[0]),
            l = "touchmove" === r.type ? o.pageX : r.pageX,
            d = "touchmove" === r.type ? o.pageY : r.pageY;
        if (r.preventedByNestedSwiper) return n.startX = l, void(n.startY = d);
        if (!t.allowTouchMove) return t.allowClick = !1, void(i.isTouched && (Ie.extend(n, {
            startX: l,
            startY: d,
            currentX: l,
            currentY: d
        }), i.touchStartTime = Ie.now()));
        if (i.isTouchEvent && s.touchReleaseOnEdges && !s.loop)
            if (t.isVertical()) {
                if (d < n.startY && t.translate <= t.maxTranslate() || d > n.startY && t.translate >= t.minTranslate()) return i.isTouched = !1, void(i.isMoved = !1)
            } else if (l < n.startX && t.translate <= t.maxTranslate() || l > n.startX && t.translate >= t.minTranslate()) return;
        if (i.isTouchEvent && xe.activeElement && r.target === xe.activeElement && Ce(r.target).is(i.formElements)) return i.isMoved = !0, void(t.allowClick = !1);
        if (i.allowTouchCallbacks && t.emit("touchMove", r), r.targetTouches && r.targetTouches.length > 1) return;
        n.currentX = l, n.currentY = d;
        const c = n.currentX - n.startX,
            h = n.currentY - n.startY;
        if (t.params.threshold && Math.sqrt(c ** 2 + h ** 2) < t.params.threshold) return;
        if (void 0 === i.isScrolling) {
            let e;
            t.isHorizontal() && n.currentY === n.startY || t.isVertical() && n.currentX === n.startX ? i.isScrolling = !1 : c * c + h * h >= 25 && (e = 180 * Math.atan2(Math.abs(h), Math.abs(c)) / Math.PI, i.isScrolling = t.isHorizontal() ? e > s.touchAngle : 90 - e > s.touchAngle)
        }
        if (i.isScrolling && t.emit("touchMoveOpposite", r), void 0 === i.startMoving && (n.currentX === n.startX && n.currentY === n.startY || (i.startMoving = !0)), i.isScrolling) return void(i.isTouched = !1);
        if (!i.startMoving) return;
        t.allowClick = !1, s.cssMode || r.preventDefault(), s.touchMoveStopPropagation && !s.nested && r.stopPropagation(), i.isMoved || (s.loop && t.loopFix(), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating && t.$wrapperEl.trigger("webkitTransitionEnd transitionend"), i.allowMomentumBounce = !1, !s.grabCursor || !0 !== t.allowSlideNext && !0 !== t.allowSlidePrev || t.setGrabCursor(!0), t.emit("sliderFirstMove", r)), t.emit("sliderMove", r), i.isMoved = !0;
        let u = t.isHorizontal() ? c : h;
        n.diff = u, u *= s.touchRatio, a && (u = -u), t.swipeDirection = u > 0 ? "prev" : "next", i.currentTranslate = u + i.startTranslate;
        let p = !0,
            m = s.resistanceRatio;
        if (s.touchReleaseOnEdges && (m = 0), u > 0 && i.currentTranslate > t.minTranslate() ? (p = !1, s.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + u) ** m)) : u < 0 && i.currentTranslate < t.maxTranslate() && (p = !1, s.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - u) ** m)), p && (r.preventedByNestedSwiper = !0), !t.allowSlideNext && "next" === t.swipeDirection && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && "prev" === t.swipeDirection && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), s.threshold > 0) {
            if (!(Math.abs(u) > s.threshold || i.allowThresholdMove)) return void(i.currentTranslate = i.startTranslate);
            if (!i.allowThresholdMove) return i.allowThresholdMove = !0, n.startX = n.currentX, n.startY = n.currentY, i.currentTranslate = i.startTranslate, void(n.diff = t.isHorizontal() ? n.currentX - n.startX : n.currentY - n.startY)
        }
        s.followFinger && !s.cssMode && ((s.freeMode || s.watchSlidesProgress || s.watchSlidesVisibility) && (t.updateActiveIndex(), t.updateSlidesClasses()), s.freeMode && (0 === i.velocities.length && i.velocities.push({
            position: n[t.isHorizontal() ? "startX" : "startY"],
            time: i.touchStartTime
        }), i.velocities.push({
            position: n[t.isHorizontal() ? "currentX" : "currentY"],
            time: Ie.now()
        })), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate))
    }

    function Ne(e) {
        const t = this,
            i = t.touchEventsData,
            {
                params: s,
                touches: n,
                rtlTranslate: a,
                $wrapperEl: r,
                slidesGrid: o,
                snapGrid: l
            } = t;
        let d = e;
        if (d.originalEvent && (d = d.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", d), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && s.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
        s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1);
        const c = Ie.now(),
            h = c - i.touchStartTime;
        if (t.allowClick && (t.updateClickedSlide(d), t.emit("tap click", d), h < 300 && c - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", d)), i.lastClickTime = Ie.now(), Ie.nextTick(() => {
                t.destroyed || (t.allowClick = !0)
            }), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === n.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
        let u;
        if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, u = s.followFinger ? a ? t.translate : -t.translate : -i.currentTranslate, s.cssMode) return;
        if (s.freeMode) {
            if (u < -t.minTranslate()) return void t.slideTo(t.activeIndex);
            if (u > -t.maxTranslate()) return void(t.slides.length < l.length ? t.slideTo(l.length - 1) : t.slideTo(t.slides.length - 1));
            if (s.freeModeMomentum) {
                if (i.velocities.length > 1) {
                    const e = i.velocities.pop(),
                        n = i.velocities.pop(),
                        a = e.position - n.position,
                        r = e.time - n.time;
                    t.velocity = a / r, t.velocity /= 2, Math.abs(t.velocity) < s.freeModeMinimumVelocity && (t.velocity = 0), (r > 150 || Ie.now() - e.time > 300) && (t.velocity = 0)
                } else t.velocity = 0;
                t.velocity *= s.freeModeMomentumVelocityRatio, i.velocities.length = 0;
                let e = 1e3 * s.freeModeMomentumRatio;
                const n = t.velocity * e;
                let o = t.translate + n;
                a && (o = -o);
                let d, c = !1;
                const h = 20 * Math.abs(t.velocity) * s.freeModeMomentumBounceRatio;
                let u;
                if (o < t.maxTranslate()) s.freeModeMomentumBounce ? (o + t.maxTranslate() < -h && (o = t.maxTranslate() - h), d = t.maxTranslate(), c = !0, i.allowMomentumBounce = !0) : o = t.maxTranslate(), s.loop && s.centeredSlides && (u = !0);
                else if (o > t.minTranslate()) s.freeModeMomentumBounce ? (o - t.minTranslate() > h && (o = t.minTranslate() + h), d = t.minTranslate(), c = !0, i.allowMomentumBounce = !0) : o = t.minTranslate(), s.loop && s.centeredSlides && (u = !0);
                else if (s.freeModeSticky) {
                    let e;
                    for (let t = 0; t < l.length; t += 1)
                        if (l[t] > -o) {
                            e = t;
                            break
                        } o = -(o = Math.abs(l[e] - o) < Math.abs(l[e - 1] - o) || "next" === t.swipeDirection ? l[e] : l[e - 1])
                }
                if (u && t.once("transitionEnd", () => {
                        t.loopFix()
                    }), 0 !== t.velocity) {
                    if (e = a ? Math.abs((-o - t.translate) / t.velocity) : Math.abs((o - t.translate) / t.velocity), s.freeModeSticky) {
                        const i = Math.abs((a ? -o : o) - t.translate),
                            n = t.slidesSizesGrid[t.activeIndex];
                        e = i < n ? s.speed : i < 2 * n ? 1.5 * s.speed : 2.5 * s.speed
                    }
                } else if (s.freeModeSticky) return void t.slideToClosest();
                s.freeModeMomentumBounce && c ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(o), t.transitionStart(!0, t.swipeDirection), t.animating = !0, r.transitionEnd(() => {
                    t && !t.destroyed && i.allowMomentumBounce && (t.emit("momentumBounce"), t.setTransition(s.speed), t.setTranslate(d), r.transitionEnd(() => {
                        t && !t.destroyed && t.transitionEnd()
                    }))
                })) : t.velocity ? (t.updateProgress(o), t.setTransition(e), t.setTranslate(o), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, r.transitionEnd(() => {
                    t && !t.destroyed && t.transitionEnd()
                }))) : t.updateProgress(o), t.updateActiveIndex(), t.updateSlidesClasses()
            } else if (s.freeModeSticky) return void t.slideToClosest();
            return void((!s.freeModeMomentum || h >= s.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses()))
        }
        let p = 0,
            m = t.slidesSizesGrid[0];
        for (let e = 0; e < o.length; e += s.slidesPerGroup) void 0 !== o[e + s.slidesPerGroup] ? u >= o[e] && u < o[e + s.slidesPerGroup] && (p = e, m = o[e + s.slidesPerGroup] - o[e]) : u >= o[e] && (p = e, m = o[o.length - 1] - o[o.length - 2]);
        const f = (u - o[p]) / m;
        if (h > s.longSwipesMs) {
            if (!s.longSwipes) return void t.slideTo(t.activeIndex);
            "next" === t.swipeDirection && (f >= s.longSwipesRatio ? t.slideTo(p + s.slidesPerGroup) : t.slideTo(p)), "prev" === t.swipeDirection && (f > 1 - s.longSwipesRatio ? t.slideTo(p + s.slidesPerGroup) : t.slideTo(p))
        } else {
            if (!s.shortSwipes) return void t.slideTo(t.activeIndex);
            t.navigation && (d.target === t.navigation.nextEl || d.target === t.navigation.prevEl) ? d.target === t.navigation.nextEl ? t.slideTo(p + s.slidesPerGroup) : t.slideTo(p) : ("next" === t.swipeDirection && t.slideTo(p + s.slidesPerGroup), "prev" === t.swipeDirection && t.slideTo(p))
        }
    }

    function Re() {
        const e = this,
            {
                params: t,
                el: i
            } = e;
        if (i && 0 === i.offsetWidth) return;
        t.breakpoints && e.setBreakpoint();
        const {
            allowSlideNext: s,
            allowSlidePrev: n,
            snapGrid: a
        } = e;
        e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = n, e.allowSlideNext = s, e.params.watchOverflow && a !== e.snapGrid && e.checkOverflow()
    }

    function We(e) {
        const t = this;
        t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))
    }

    function Fe() {
        const e = this,
            {
                wrapperEl: t
            } = e;
        let i;
        e.previousTranslate = e.translate, e.translate = e.isHorizontal() ? -t.scrollLeft : -t.scrollTop, -0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses();
        const s = e.maxTranslate() - e.minTranslate();
        (i = 0 === s ? 0 : (e.translate - e.minTranslate()) / s) !== e.progress && e.updateProgress(e.translate), e.emit("setTranslate", e.translate, !1)
    }
    let Ge = !1;

    function Ye() {}
    var Ve = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "container",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        preventInteractionOnTransition: !1,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        freeMode: !1,
        freeModeMomentum: !0,
        freeModeMomentumRatio: 1,
        freeModeMomentumBounce: !0,
        freeModeMomentumBounceRatio: 1,
        freeModeMomentumVelocityRatio: 1,
        freeModeSticky: !1,
        freeModeMinimumVelocity: .02,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerColumn: 1,
        slidesPerColumnFill: "column",
        slidesPerGroup: 1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !1,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        watchSlidesVisibility: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopFillGroupWithBlank: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        containerModifierClass: "swiper-container-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0
    };
    const je = {
            update: Me,
            translate: Pe,
            transition: ke,
            slide: Oe,
            loop: Ae,
            grabCursor: De,
            manipulation: _e,
            events: {
                attachEvents: function () {
                    const e = this,
                        {
                            params: t,
                            touchEvents: i,
                            el: s,
                            wrapperEl: n
                        } = e;
                    e.onTouchStart = Be.bind(e), e.onTouchMove = qe.bind(e), e.onTouchEnd = Ne.bind(e), t.cssMode && (e.onScroll = Fe.bind(e)), e.onClick = We.bind(e);
                    const a = !!t.nested;
                    if (!$e.touch && $e.pointerEvents) s.addEventListener(i.start, e.onTouchStart, !1), xe.addEventListener(i.move, e.onTouchMove, a), xe.addEventListener(i.end, e.onTouchEnd, !1);
                    else {
                        if ($e.touch) {
                            const n = !("touchstart" !== i.start || !$e.passiveListener || !t.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            s.addEventListener(i.start, e.onTouchStart, n), s.addEventListener(i.move, e.onTouchMove, $e.passiveListener ? {
                                passive: !1,
                                capture: a
                            } : a), s.addEventListener(i.end, e.onTouchEnd, n), i.cancel && s.addEventListener(i.cancel, e.onTouchEnd, n), Ge || (xe.addEventListener("touchstart", Ye), Ge = !0)
                        }(t.simulateTouch && !He.ios && !He.android || t.simulateTouch && !$e.touch && He.ios) && (s.addEventListener("mousedown", e.onTouchStart, !1), xe.addEventListener("mousemove", e.onTouchMove, a), xe.addEventListener("mouseup", e.onTouchEnd, !1))
                    }(t.preventClicks || t.preventClicksPropagation) && s.addEventListener("click", e.onClick, !0), t.cssMode && n.addEventListener("scroll", e.onScroll), e.on(He.ios || He.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Re, !0)
                },
                detachEvents: function () {
                    const e = this,
                        {
                            params: t,
                            touchEvents: i,
                            el: s,
                            wrapperEl: n
                        } = e,
                        a = !!t.nested;
                    if (!$e.touch && $e.pointerEvents) s.removeEventListener(i.start, e.onTouchStart, !1), xe.removeEventListener(i.move, e.onTouchMove, a), xe.removeEventListener(i.end, e.onTouchEnd, !1);
                    else {
                        if ($e.touch) {
                            const n = !("onTouchStart" !== i.start || !$e.passiveListener || !t.passiveListeners) && {
                                passive: !0,
                                capture: !1
                            };
                            s.removeEventListener(i.start, e.onTouchStart, n), s.removeEventListener(i.move, e.onTouchMove, a), s.removeEventListener(i.end, e.onTouchEnd, n), i.cancel && s.removeEventListener(i.cancel, e.onTouchEnd, n)
                        }(t.simulateTouch && !He.ios && !He.android || t.simulateTouch && !$e.touch && He.ios) && (s.removeEventListener("mousedown", e.onTouchStart, !1), xe.removeEventListener("mousemove", e.onTouchMove, a), xe.removeEventListener("mouseup", e.onTouchEnd, !1))
                    }(t.preventClicks || t.preventClicksPropagation) && s.removeEventListener("click", e.onClick, !0), t.cssMode && n.removeEventListener("scroll", e.onScroll), e.off(He.ios || He.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Re)
                }
            },
            breakpoints: {
                setBreakpoint: function () {
                    const e = this,
                        {
                            activeIndex: t,
                            initialized: i,
                            loopedSlides: s = 0,
                            params: n,
                            $el: a
                        } = e,
                        r = n.breakpoints;
                    if (!r || r && 0 === Object.keys(r).length) return;
                    const o = e.getBreakpoint(r);
                    if (o && e.currentBreakpoint !== o) {
                        const l = o in r ? r[o] : void 0;
                        l && ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerColumn"].forEach(e => {
                            const t = l[e];
                            void 0 !== t && (l[e] = "slidesPerView" !== e || "AUTO" !== t && "auto" !== t ? "slidesPerView" === e ? parseFloat(t) : parseInt(t, 10) : "auto")
                        });
                        const d = l || e.originalParams,
                            c = n.slidesPerColumn > 1,
                            h = d.slidesPerColumn > 1;
                        c && !h ? a.removeClass(`${n.containerModifierClass}multirow ${n.containerModifierClass}multirow-column`) : !c && h && (a.addClass(`${n.containerModifierClass}multirow`), "column" === d.slidesPerColumnFill && a.addClass(`${n.containerModifierClass}multirow-column`));
                        const u = d.direction && d.direction !== n.direction,
                            p = n.loop && (d.slidesPerView !== n.slidesPerView || u);
                        u && i && e.changeDirection(), Ie.extend(e.params, d), Ie.extend(e, {
                            allowTouchMove: e.params.allowTouchMove,
                            allowSlideNext: e.params.allowSlideNext,
                            allowSlidePrev: e.params.allowSlidePrev
                        }), e.currentBreakpoint = o, p && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit("breakpoint", d)
                    }
                },
                getBreakpoint: function (e) {
                    if (!e) return;
                    let t = !1;
                    const i = [];
                    Object.keys(e).forEach(e => {
                        i.push(e)
                    }), i.sort((e, t) => parseInt(e, 10) - parseInt(t, 10));
                    for (let e = 0; e < i.length; e += 1) {
                        const s = i[e];
                        s <= Ee.innerWidth && (t = s)
                    }
                    return t || "max"
                }
            },
            checkOverflow: {
                checkOverflow: function () {
                    const e = this,
                        t = e.params,
                        i = e.isLocked,
                        s = e.slides.length > 0 && t.slidesOffsetBefore + t.spaceBetween * (e.slides.length - 1) + e.slides[0].offsetWidth * e.slides.length;
                    t.slidesOffsetBefore && t.slidesOffsetAfter && s ? e.isLocked = s <= e.size : e.isLocked = 1 === e.snapGrid.length, e.allowSlideNext = !e.isLocked, e.allowSlidePrev = !e.isLocked, i !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock"), i && i !== e.isLocked && (e.isEnd = !1, e.navigation.update())
                }
            },
            classes: {
                addClasses: function () {
                    const {
                        classNames: e,
                        params: t,
                        rtl: i,
                        $el: s
                    } = this, n = [];
                    n.push("initialized"), n.push(t.direction), t.freeMode && n.push("free-mode"), t.autoHeight && n.push("autoheight"), i && n.push("rtl"), t.slidesPerColumn > 1 && (n.push("multirow"), "column" === t.slidesPerColumnFill && n.push("multirow-column")), He.android && n.push("android"), He.ios && n.push("ios"), t.cssMode && n.push("css-mode"), n.forEach(i => {
                        e.push(t.containerModifierClass + i)
                    }), s.addClass(e.join(" "))
                },
                removeClasses: function () {
                    const {
                        $el: e,
                        classNames: t
                    } = this;
                    e.removeClass(t.join(" "))
                }
            },
            images: {
                loadImage: function (e, t, i, s, n, a) {
                    let r;

                    function o() {
                        a && a()
                    }
                    e.complete && n ? o() : t ? ((r = new Ee.Image).onload = o, r.onerror = o, s && (r.sizes = s), i && (r.srcset = i), t && (r.src = t)) : o()
                },
                preloadImages: function () {
                    const e = this;

                    function t() {
                        null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady")))
                    }
                    e.imagesToLoad = e.$el.find("img");
                    for (let i = 0; i < e.imagesToLoad.length; i += 1) {
                        const s = e.imagesToLoad[i];
                        e.loadImage(s, s.currentSrc || s.getAttribute("src"), s.srcset || s.getAttribute("srcset"), s.sizes || s.getAttribute("sizes"), !0, t)
                    }
                }
            }
        },
        Xe = {};
    class Ue extends ze {
        constructor(...e) {
            let t, i;
            1 === e.length && e[0].constructor && e[0].constructor === Object ? i = e[0] : [t, i] = e, i || (i = {}), i = Ie.extend({}, i), t && !i.el && (i.el = t), super(i), Object.keys(je).forEach(e => {
                Object.keys(je[e]).forEach(t => {
                    Ue.prototype[t] || (Ue.prototype[t] = je[e][t])
                })
            });
            const s = this;
            void 0 === s.modules && (s.modules = {}), Object.keys(s.modules).forEach(e => {
                const t = s.modules[e];
                if (t.params) {
                    const e = Object.keys(t.params)[0],
                        s = t.params[e];
                    if ("object" != typeof s || null === s) return;
                    if (!(e in i && "enabled" in s)) return;
                    !0 === i[e] && (i[e] = {
                        enabled: !0
                    }), "object" != typeof i[e] || "enabled" in i[e] || (i[e].enabled = !0), i[e] || (i[e] = {
                        enabled: !1
                    })
                }
            });
            const n = Ie.extend({}, Ve);
            s.useModulesParams(n), s.params = Ie.extend({}, n, Xe, i), s.originalParams = Ie.extend({}, s.params), s.passedParams = Ie.extend({}, i), s.$ = Ce;
            const a = Ce(s.params.el);
            if (!(t = a[0])) return;
            if (a.length > 1) {
                const e = [];
                return a.each((t, s) => {
                    const n = Ie.extend({}, i, {
                        el: s
                    });
                    e.push(new Ue(n))
                }), e
            }
            let r;
            return t.swiper = s, a.data("swiper", s), t && t.shadowRoot && t.shadowRoot.querySelector ? (r = Ce(t.shadowRoot.querySelector(`.${s.params.wrapperClass}`))).children = e => a.children(e) : r = a.children(`.${s.params.wrapperClass}`), Ie.extend(s, {
                $el: a,
                el: t,
                $wrapperEl: r,
                wrapperEl: r[0],
                classNames: [],
                slides: Ce(),
                slidesGrid: [],
                snapGrid: [],
                slidesSizesGrid: [],
                isHorizontal: () => "horizontal" === s.params.direction,
                isVertical: () => "vertical" === s.params.direction,
                rtl: "rtl" === t.dir.toLowerCase() || "rtl" === a.css("direction"),
                rtlTranslate: "horizontal" === s.params.direction && ("rtl" === t.dir.toLowerCase() || "rtl" === a.css("direction")),
                wrongRTL: "-webkit-box" === r.css("display"),
                activeIndex: 0,
                realIndex: 0,
                isBeginning: !0,
                isEnd: !1,
                translate: 0,
                previousTranslate: 0,
                progress: 0,
                velocity: 0,
                animating: !1,
                allowSlideNext: s.params.allowSlideNext,
                allowSlidePrev: s.params.allowSlidePrev,
                touchEvents: function () {
                    const e = ["touchstart", "touchmove", "touchend", "touchcancel"];
                    let t = ["mousedown", "mousemove", "mouseup"];
                    return $e.pointerEvents && (t = ["pointerdown", "pointermove", "pointerup"]), s.touchEventsTouch = {
                        start: e[0],
                        move: e[1],
                        end: e[2],
                        cancel: e[3]
                    }, s.touchEventsDesktop = {
                        start: t[0],
                        move: t[1],
                        end: t[2]
                    }, $e.touch || !s.params.simulateTouch ? s.touchEventsTouch : s.touchEventsDesktop
                }(),
                touchEventsData: {
                    isTouched: void 0,
                    isMoved: void 0,
                    allowTouchCallbacks: void 0,
                    touchStartTime: void 0,
                    isScrolling: void 0,
                    currentTranslate: void 0,
                    startTranslate: void 0,
                    allowThresholdMove: void 0,
                    formElements: "input, select, option, textarea, button, video",
                    lastClickTime: Ie.now(),
                    clickTimeout: void 0,
                    velocities: [],
                    allowMomentumBounce: void 0,
                    isTouchEvent: void 0,
                    startMoving: void 0
                },
                allowClick: !0,
                allowTouchMove: s.params.allowTouchMove,
                touches: {
                    startX: 0,
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    diff: 0
                },
                imagesToLoad: [],
                imagesLoaded: 0
            }), s.useModules(), s.params.init && s.init(), s
        }
        slidesPerViewDynamic() {
            const {
                params: e,
                slides: t,
                slidesGrid: i,
                size: s,
                activeIndex: n
            } = this;
            let a = 1;
            if (e.centeredSlides) {
                let e, i = t[n].swiperSlideSize;
                for (let r = n + 1; r < t.length; r += 1) t[r] && !e && (a += 1, (i += t[r].swiperSlideSize) > s && (e = !0));
                for (let r = n - 1; r >= 0; r -= 1) t[r] && !e && (a += 1, (i += t[r].swiperSlideSize) > s && (e = !0))
            } else
                for (let e = n + 1; e < t.length; e += 1) i[e] - i[n] < s && (a += 1);
            return a
        }
        update() {
            const e = this;
            if (!e || e.destroyed) return;
            const {
                snapGrid: t,
                params: i
            } = e;

            function s() {
                const t = e.rtlTranslate ? -1 * e.translate : e.translate,
                    i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate());
                e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses()
            }
            let n;
            i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode ? (s(), e.params.autoHeight && e.updateAutoHeight()) : (n = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0)) || s(), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
        }
        changeDirection(e, t = !0) {
            const i = this,
                s = i.params.direction;
            return e || (e = "horizontal" === s ? "vertical" : "horizontal"), e === s || "horizontal" !== e && "vertical" !== e ? i : (i.$el.removeClass(`${i.params.containerModifierClass}${s}`).addClass(`${i.params.containerModifierClass}${e}`), i.params.direction = e, i.slides.each((t, i) => {
                "vertical" === e ? i.style.width = "" : i.style.height = ""
            }), i.emit("changeDirection"), t && i.update(), i)
        }
        init() {
            const e = this;
            e.initialized || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit), e.attachEvents(), e.initialized = !0, e.emit("init"))
        }
        destroy(e = !0, t = !0) {
            const i = this,
                {
                    params: s,
                    $el: n,
                    $wrapperEl: a,
                    slides: r
                } = i;
            return void 0 === i.params || i.destroyed ? null : (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), n.removeAttr("style"), a.removeAttr("style"), r && r.length && r.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(e => {
                i.off(e)
            }), !1 !== e && (i.$el[0].swiper = null, i.$el.data("swiper", null), Ie.deleteProps(i)), i.destroyed = !0, null)
        }
        static extendDefaults(e) {
            Ie.extend(Xe, e)
        }
        static get extendedDefaults() {
            return Xe
        }
        static get defaults() {
            return Ve
        }
        static get Class() {
            return ze
        }
        static get $() {
            return Ce
        }
    }
    var Ke = {
            name: "device",
            proto: {
                device: He
            },
            static: {
                device: He
            }
        },
        Qe = {
            name: "support",
            proto: {
                support: $e
            },
            static: {
                support: $e
            }
        };
    const Je = {
        isEdge: !!Ee.navigator.userAgent.match(/Edge/g),
        isSafari: function () {
            const e = Ee.navigator.userAgent.toLowerCase();
            return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0
        }(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(Ee.navigator.userAgent)
    };
    var Ze = {
            name: "browser",
            proto: {
                browser: Je
            },
            static: {
                browser: Je
            }
        },
        et = {
            name: "resize",
            create() {
                const e = this;
                Ie.extend(e, {
                    resize: {
                        resizeHandler() {
                            e && !e.destroyed && e.initialized && (e.emit("beforeResize"), e.emit("resize"))
                        },
                        orientationChangeHandler() {
                            e && !e.destroyed && e.initialized && e.emit("orientationchange")
                        }
                    }
                })
            },
            on: {
                init() {
                    Ee.addEventListener("resize", this.resize.resizeHandler), Ee.addEventListener("orientationchange", this.resize.orientationChangeHandler)
                },
                destroy() {
                    Ee.removeEventListener("resize", this.resize.resizeHandler), Ee.removeEventListener("orientationchange", this.resize.orientationChangeHandler)
                }
            }
        };
    const tt = {
        func: Ee.MutationObserver || Ee.WebkitMutationObserver,
        attach(e, t = {}) {
            const i = this,
                s = new(0, tt.func)(e => {
                    if (1 === e.length) return void i.emit("observerUpdate", e[0]);
                    const t = function () {
                        i.emit("observerUpdate", e[0])
                    };
                    Ee.requestAnimationFrame ? Ee.requestAnimationFrame(t) : Ee.setTimeout(t, 0)
                });
            s.observe(e, {
                attributes: void 0 === t.attributes || t.attributes,
                childList: void 0 === t.childList || t.childList,
                characterData: void 0 === t.characterData || t.characterData
            }), i.observer.observers.push(s)
        },
        init() {
            const e = this;
            if ($e.observer && e.params.observer) {
                if (e.params.observeParents) {
                    const t = e.$el.parents();
                    for (let i = 0; i < t.length; i += 1) e.observer.attach(t[i])
                }
                e.observer.attach(e.$el[0], {
                    childList: e.params.observeSlideChildren
                }), e.observer.attach(e.$wrapperEl[0], {
                    attributes: !1
                })
            }
        },
        destroy() {
            this.observer.observers.forEach(e => {
                e.disconnect()
            }), this.observer.observers = []
        }
    };
    var it = {
        name: "observer",
        params: {
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1
        },
        create() {
            Ie.extend(this, {
                observer: {
                    init: tt.init.bind(this),
                    attach: tt.attach.bind(this),
                    destroy: tt.destroy.bind(this),
                    observers: []
                }
            })
        },
        on: {
            init() {
                this.observer.init()
            },
            destroy() {
                this.observer.destroy()
            }
        }
    };
    const st = {
        update(e) {
            const t = this,
                {
                    slidesPerView: i,
                    slidesPerGroup: s,
                    centeredSlides: n
                } = t.params,
                {
                    addSlidesBefore: a,
                    addSlidesAfter: r
                } = t.params.virtual,
                {
                    from: o,
                    to: l,
                    slides: d,
                    slidesGrid: c,
                    renderSlide: h,
                    offset: u
                } = t.virtual;
            t.updateActiveIndex();
            const p = t.activeIndex || 0;
            let m, f, g;
            m = t.rtlTranslate ? "right" : t.isHorizontal() ? "left" : "top", n ? (f = Math.floor(i / 2) + s + a, g = Math.floor(i / 2) + s + r) : (f = i + (s - 1) + a, g = s + r);
            const v = Math.max((p || 0) - g, 0),
                y = Math.min((p || 0) + f, d.length - 1),
                b = (t.slidesGrid[v] || 0) - (t.slidesGrid[0] || 0);

            function w() {
                t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load()
            }
            if (Ie.extend(t.virtual, {
                    from: v,
                    to: y,
                    offset: b,
                    slidesGrid: t.slidesGrid
                }), o === v && l === y && !e) return t.slidesGrid !== c && b !== u && t.slides.css(m, `${b}px`), void t.updateProgress();
            if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, {
                offset: b,
                from: v,
                to: y,
                slides: function () {
                    const e = [];
                    for (let t = v; t <= y; t += 1) e.push(d[t]);
                    return e
                }()
            }), void w();
            const x = [],
                E = [];
            if (e) t.$wrapperEl.find(`.${t.params.slideClass}`).remove();
            else
                for (let e = o; e <= l; e += 1)(e < v || e > y) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`).remove();
            for (let t = 0; t < d.length; t += 1) t >= v && t <= y && (void 0 === l || e ? E.push(t) : (t > l && E.push(t), t < o && x.push(t)));
            E.forEach(e => {
                t.$wrapperEl.append(h(d[e], e))
            }), x.sort((e, t) => t - e).forEach(e => {
                t.$wrapperEl.prepend(h(d[e], e))
            }), t.$wrapperEl.children(".swiper-slide").css(m, `${b}px`), w()
        },
        renderSlide(e, t) {
            const i = this,
                s = i.params.virtual;
            if (s.cache && i.virtual.cache[t]) return i.virtual.cache[t];
            const n = s.renderSlide ? Ce(s.renderSlide.call(i, e, t)) : Ce(`<div class="${i.params.slideClass}" data-swiper-slide-index="${t}">${e}</div>`);
            return n.attr("data-swiper-slide-index") || n.attr("data-swiper-slide-index", t), s.cache && (i.virtual.cache[t] = n), n
        },
        appendSlide(e) {
            const t = this;
            if ("object" == typeof e && "length" in e)
                for (let i = 0; i < e.length; i += 1) e[i] && t.virtual.slides.push(e[i]);
            else t.virtual.slides.push(e);
            t.virtual.update(!0)
        },
        prependSlide(e) {
            const t = this,
                i = t.activeIndex;
            let s = i + 1,
                n = 1;
            if (Array.isArray(e)) {
                for (let i = 0; i < e.length; i += 1) e[i] && t.virtual.slides.unshift(e[i]);
                s = i + e.length, n = e.length
            } else t.virtual.slides.unshift(e);
            if (t.params.virtual.cache) {
                const e = t.virtual.cache,
                    i = {};
                Object.keys(e).forEach(t => {
                    const s = e[t],
                        a = s.attr("data-swiper-slide-index");
                    a && s.attr("data-swiper-slide-index", parseInt(a, 10) + 1), i[parseInt(t, 10) + n] = s
                }), t.virtual.cache = i
            }
            t.virtual.update(!0), t.slideTo(s, 0)
        },
        removeSlide(e) {
            const t = this;
            if (null == e) return;
            let i = t.activeIndex;
            if (Array.isArray(e))
                for (let s = e.length - 1; s >= 0; s -= 1) t.virtual.slides.splice(e[s], 1), t.params.virtual.cache && delete t.virtual.cache[e[s]], e[s] < i && (i -= 1), i = Math.max(i, 0);
            else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < i && (i -= 1), i = Math.max(i, 0);
            t.virtual.update(!0), t.slideTo(i, 0)
        },
        removeAllSlides() {
            const e = this;
            e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), e.virtual.update(!0), e.slideTo(0, 0)
        }
    };
    var nt = {
        name: "virtual",
        params: {
            virtual: {
                enabled: !1,
                slides: [],
                cache: !0,
                renderSlide: null,
                renderExternal: null,
                addSlidesBefore: 0,
                addSlidesAfter: 0
            }
        },
        create() {
            Ie.extend(this, {
                virtual: {
                    update: st.update.bind(this),
                    appendSlide: st.appendSlide.bind(this),
                    prependSlide: st.prependSlide.bind(this),
                    removeSlide: st.removeSlide.bind(this),
                    removeAllSlides: st.removeAllSlides.bind(this),
                    renderSlide: st.renderSlide.bind(this),
                    slides: this.params.virtual.slides,
                    cache: {}
                }
            })
        },
        on: {
            beforeInit() {
                const e = this;
                if (!e.params.virtual.enabled) return;
                e.classNames.push(`${e.params.containerModifierClass}virtual`);
                const t = {
                    watchSlidesProgress: !0
                };
                Ie.extend(e.params, t), Ie.extend(e.originalParams, t), e.params.initialSlide || e.virtual.update()
            },
            setTranslate() {
                this.params.virtual.enabled && this.virtual.update()
            }
        }
    };
    const at = {
        handle(e) {
            const t = this,
                {
                    rtlTranslate: i
                } = t;
            let s = e;
            s.originalEvent && (s = s.originalEvent);
            const n = s.keyCode || s.charCode;
            if (!t.allowSlideNext && (t.isHorizontal() && 39 === n || t.isVertical() && 40 === n || 34 === n)) return !1;
            if (!t.allowSlidePrev && (t.isHorizontal() && 37 === n || t.isVertical() && 38 === n || 33 === n)) return !1;
            if (!(s.shiftKey || s.altKey || s.ctrlKey || s.metaKey || xe.activeElement && xe.activeElement.nodeName && ("input" === xe.activeElement.nodeName.toLowerCase() || "textarea" === xe.activeElement.nodeName.toLowerCase()))) {
                if (t.params.keyboard.onlyInViewport && (33 === n || 34 === n || 37 === n || 39 === n || 38 === n || 40 === n)) {
                    let e = !1;
                    if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return;
                    const s = Ee.innerWidth,
                        n = Ee.innerHeight,
                        a = t.$el.offset();
                    i && (a.left -= t.$el[0].scrollLeft);
                    const r = [[a.left, a.top], [a.left + t.width, a.top], [a.left, a.top + t.height], [a.left + t.width, a.top + t.height]];
                    for (let t = 0; t < r.length; t += 1) {
                        const i = r[t];
                        i[0] >= 0 && i[0] <= s && i[1] >= 0 && i[1] <= n && (e = !0)
                    }
                    if (!e) return
                }
                t.isHorizontal() ? (33 !== n && 34 !== n && 37 !== n && 39 !== n || (s.preventDefault ? s.preventDefault() : s.returnValue = !1), (34 !== n && 39 !== n || i) && (33 !== n && 37 !== n || !i) || t.slideNext(), (33 !== n && 37 !== n || i) && (34 !== n && 39 !== n || !i) || t.slidePrev()) : (33 !== n && 34 !== n && 38 !== n && 40 !== n || (s.preventDefault ? s.preventDefault() : s.returnValue = !1), 34 !== n && 40 !== n || t.slideNext(), 33 !== n && 38 !== n || t.slidePrev()), t.emit("keyPress", n)
            }
        },
        enable() {
            this.keyboard.enabled || (Ce(xe).on("keydown", this.keyboard.handle), this.keyboard.enabled = !0)
        },
        disable() {
            this.keyboard.enabled && (Ce(xe).off("keydown", this.keyboard.handle), this.keyboard.enabled = !1)
        }
    };
    var rt = {
        name: "keyboard",
        params: {
            keyboard: {
                enabled: !1,
                onlyInViewport: !0
            }
        },
        create() {
            Ie.extend(this, {
                keyboard: {
                    enabled: !1,
                    enable: at.enable.bind(this),
                    disable: at.disable.bind(this),
                    handle: at.handle.bind(this)
                }
            })
        },
        on: {
            init() {
                const e = this;
                e.params.keyboard.enabled && e.keyboard.enable()
            },
            destroy() {
                const e = this;
                e.keyboard.enabled && e.keyboard.disable()
            }
        }
    };
    const ot = {
        lastScrollTime: Ie.now(),
        lastEventBeforeSnap: void 0,
        recentWheelEvents: [],
        event: () => Ee.navigator.userAgent.indexOf("firefox") > -1 ? "DOMMouseScroll" : function () {
            let e = "onwheel" in xe;
            if (!e) {
                const t = xe.createElement("div");
                t.setAttribute("onwheel", "return;"), e = "function" == typeof t.onwheel
            }
            return !e && xe.implementation && xe.implementation.hasFeature && !0 !== xe.implementation.hasFeature("", "") && (e = xe.implementation.hasFeature("Events.wheel", "3.0")), e
        }() ? "wheel" : "mousewheel",
        normalize(e) {
            let t = 0,
                i = 0,
                s = 0,
                n = 0;
            return "detail" in e && (i = e.detail), "wheelDelta" in e && (i = -e.wheelDelta / 120), "wheelDeltaY" in e && (i = -e.wheelDeltaY / 120), "wheelDeltaX" in e && (t = -e.wheelDeltaX / 120), "axis" in e && e.axis === e.HORIZONTAL_AXIS && (t = i, i = 0), s = 10 * t, n = 10 * i, "deltaY" in e && (n = e.deltaY), "deltaX" in e && (s = e.deltaX), e.shiftKey && !s && (s = n, n = 0), (s || n) && e.deltaMode && (1 === e.deltaMode ? (s *= 40, n *= 40) : (s *= 800, n *= 800)), s && !t && (t = s < 1 ? -1 : 1), n && !i && (i = n < 1 ? -1 : 1), {
                spinX: t,
                spinY: i,
                pixelX: s,
                pixelY: n
            }
        },
        handleMouseEnter() {
            this.mouseEntered = !0
        },
        handleMouseLeave() {
            this.mouseEntered = !1
        },
        handle(e) {
            let t = e;
            const i = this,
                s = i.params.mousewheel;
            if (i.params.cssMode && t.preventDefault(), !i.mouseEntered && !s.releaseOnEdges) return !0;
            t.originalEvent && (t = t.originalEvent);
            let n = 0;
            const a = i.rtlTranslate ? -1 : 1,
                r = ot.normalize(t);
            if (s.forceToAxis)
                if (i.isHorizontal()) {
                    if (!(Math.abs(r.pixelX) > Math.abs(r.pixelY))) return !0;
                    n = r.pixelX * a
                } else {
                    if (!(Math.abs(r.pixelY) > Math.abs(r.pixelX))) return !0;
                    n = r.pixelY
                }
            else n = Math.abs(r.pixelX) > Math.abs(r.pixelY) ? -r.pixelX * a : -r.pixelY;
            if (0 === n) return !0;
            if (s.invert && (n = -n), i.params.freeMode) {
                const e = {
                        time: Ie.now(),
                        delta: Math.abs(n),
                        direction: Math.sign(n)
                    },
                    {
                        lastEventBeforeSnap: a
                    } = i.mousewheel,
                    r = a && e.time < a.time + 500 && e.delta <= a.delta && e.direction === a.direction;
                if (!r) {
                    i.mousewheel.lastEventBeforeSnap = void 0, i.params.loop && i.loopFix();
                    let a = i.getTranslate() + n * s.sensitivity;
                    const o = i.isBeginning,
                        l = i.isEnd;
                    if (a >= i.minTranslate() && (a = i.minTranslate()), a <= i.maxTranslate() && (a = i.maxTranslate()), i.setTransition(0), i.setTranslate(a), i.updateProgress(), i.updateActiveIndex(), i.updateSlidesClasses(), (!o && i.isBeginning || !l && i.isEnd) && i.updateSlidesClasses(), i.params.freeModeSticky) {
                        clearTimeout(i.mousewheel.timeout), i.mousewheel.timeout = void 0;
                        const t = i.mousewheel.recentWheelEvents;
                        t.length >= 15 && t.shift();
                        const s = t.length ? t[t.length - 1] : void 0,
                            a = t[0];
                        if (t.push(e), s && (e.delta > s.delta || e.direction !== s.direction)) t.splice(0);
                        else if (t.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
                            const s = n > 0 ? .8 : .2;
                            i.mousewheel.lastEventBeforeSnap = e, t.splice(0), i.mousewheel.timeout = Ie.nextTick(() => {
                                i.slideToClosest(i.params.speed, !0, void 0, s)
                            }, 0)
                        }
                        i.mousewheel.timeout || (i.mousewheel.timeout = Ie.nextTick(() => {
                            i.mousewheel.lastEventBeforeSnap = e, t.splice(0), i.slideToClosest(i.params.speed, !0, void 0, .5)
                        }, 500))
                    }
                    if (r || i.emit("scroll", t), i.params.autoplay && i.params.autoplayDisableOnInteraction && i.autoplay.stop(), a === i.minTranslate() || a === i.maxTranslate()) return !0
                }
            } else {
                if (Ie.now() - i.mousewheel.lastScrollTime > 60)
                    if (n < 0)
                        if (i.isEnd && !i.params.loop || i.animating) {
                            if (s.releaseOnEdges) return !0
                        } else i.slideNext(), i.emit("scroll", t);
                else if (i.isBeginning && !i.params.loop || i.animating) {
                    if (s.releaseOnEdges) return !0
                } else i.slidePrev(), i.emit("scroll", t);
                i.mousewheel.lastScrollTime = (new Ee.Date).getTime()
            }
            return t.preventDefault ? t.preventDefault() : t.returnValue = !1, !1
        },
        enable() {
            const e = this,
                t = ot.event();
            if (e.params.cssMode) return e.wrapperEl.removeEventListener(t, e.mousewheel.handle), !0;
            if (!t) return !1;
            if (e.mousewheel.enabled) return !1;
            let i = e.$el;
            return "container" !== e.params.mousewheel.eventsTarged && (i = Ce(e.params.mousewheel.eventsTarged)), i.on("mouseenter", e.mousewheel.handleMouseEnter), i.on("mouseleave", e.mousewheel.handleMouseLeave), i.on(t, e.mousewheel.handle), e.mousewheel.enabled = !0, !0
        },
        disable() {
            const e = this,
                t = ot.event();
            if (e.params.cssMode) return e.wrapperEl.addEventListener(t, e.mousewheel.handle), !0;
            if (!t) return !1;
            if (!e.mousewheel.enabled) return !1;
            let i = e.$el;
            return "container" !== e.params.mousewheel.eventsTarged && (i = Ce(e.params.mousewheel.eventsTarged)), i.off(t, e.mousewheel.handle), e.mousewheel.enabled = !1, !0
        }
    };
    const lt = {
        update() {
            const e = this,
                t = e.params.navigation;
            if (e.params.loop) return;
            const {
                $nextEl: i,
                $prevEl: s
            } = e.navigation;
            s && s.length > 0 && (e.isBeginning ? s.addClass(t.disabledClass) : s.removeClass(t.disabledClass), s[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass)), i && i.length > 0 && (e.isEnd ? i.addClass(t.disabledClass) : i.removeClass(t.disabledClass), i[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](t.lockClass))
        },
        onPrevClick(e) {
            e.preventDefault(), this.isBeginning && !this.params.loop || this.slidePrev()
        },
        onNextClick(e) {
            e.preventDefault(), this.isEnd && !this.params.loop || this.slideNext()
        },
        init() {
            const e = this,
                t = e.params.navigation;
            if (!t.nextEl && !t.prevEl) return;
            let i, s;
            t.nextEl && (i = Ce(t.nextEl), e.params.uniqueNavElements && "string" == typeof t.nextEl && i.length > 1 && 1 === e.$el.find(t.nextEl).length && (i = e.$el.find(t.nextEl))), t.prevEl && (s = Ce(t.prevEl), e.params.uniqueNavElements && "string" == typeof t.prevEl && s.length > 1 && 1 === e.$el.find(t.prevEl).length && (s = e.$el.find(t.prevEl))), i && i.length > 0 && i.on("click", e.navigation.onNextClick), s && s.length > 0 && s.on("click", e.navigation.onPrevClick), Ie.extend(e.navigation, {
                $nextEl: i,
                nextEl: i && i[0],
                $prevEl: s,
                prevEl: s && s[0]
            })
        },
        destroy() {
            const e = this,
                {
                    $nextEl: t,
                    $prevEl: i
                } = e.navigation;
            t && t.length && (t.off("click", e.navigation.onNextClick), t.removeClass(e.params.navigation.disabledClass)), i && i.length && (i.off("click", e.navigation.onPrevClick), i.removeClass(e.params.navigation.disabledClass))
        }
    };
    const dt = {
        update() {
            const e = this,
                t = e.rtl,
                i = e.params.pagination;
            if (!i.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length) return;
            const s = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                n = e.pagination.$el;
            let a;
            const r = e.params.loop ? Math.ceil((s - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
            if (e.params.loop ? ((a = Math.ceil((e.activeIndex - e.loopedSlides) / e.params.slidesPerGroup)) > s - 1 - 2 * e.loopedSlides && (a -= s - 2 * e.loopedSlides), a > r - 1 && (a -= r), a < 0 && "bullets" !== e.params.paginationType && (a = r + a)) : a = void 0 !== e.snapIndex ? e.snapIndex : e.activeIndex || 0, "bullets" === i.type && e.pagination.bullets && e.pagination.bullets.length > 0) {
                const s = e.pagination.bullets;
                let r, o, l;
                if (i.dynamicBullets && (e.pagination.bulletSize = s.eq(0)[e.isHorizontal() ? "outerWidth" : "outerHeight"](!0), n.css(e.isHorizontal() ? "width" : "height", `${e.pagination.bulletSize*(i.dynamicMainBullets+4)}px`), i.dynamicMainBullets > 1 && void 0 !== e.previousIndex && (e.pagination.dynamicBulletIndex += a - e.previousIndex, e.pagination.dynamicBulletIndex > i.dynamicMainBullets - 1 ? e.pagination.dynamicBulletIndex = i.dynamicMainBullets - 1 : e.pagination.dynamicBulletIndex < 0 && (e.pagination.dynamicBulletIndex = 0)), r = a - e.pagination.dynamicBulletIndex, l = ((o = r + (Math.min(s.length, i.dynamicMainBullets) - 1)) + r) / 2), s.removeClass(`${i.bulletActiveClass} ${i.bulletActiveClass}-next ${i.bulletActiveClass}-next-next ${i.bulletActiveClass}-prev ${i.bulletActiveClass}-prev-prev ${i.bulletActiveClass}-main`), n.length > 1) s.each((e, t) => {
                    const s = Ce(t),
                        n = s.index();
                    n === a && s.addClass(i.bulletActiveClass), i.dynamicBullets && (n >= r && n <= o && s.addClass(`${i.bulletActiveClass}-main`), n === r && s.prev().addClass(`${i.bulletActiveClass}-prev`).prev().addClass(`${i.bulletActiveClass}-prev-prev`), n === o && s.next().addClass(`${i.bulletActiveClass}-next`).next().addClass(`${i.bulletActiveClass}-next-next`))
                });
                else {
                    const t = s.eq(a),
                        n = t.index();
                    if (t.addClass(i.bulletActiveClass), i.dynamicBullets) {
                        const t = s.eq(r),
                            a = s.eq(o);
                        for (let e = r; e <= o; e += 1) s.eq(e).addClass(`${i.bulletActiveClass}-main`);
                        if (e.params.loop)
                            if (n >= s.length - i.dynamicMainBullets) {
                                for (let e = i.dynamicMainBullets; e >= 0; e -= 1) s.eq(s.length - e).addClass(`${i.bulletActiveClass}-main`);
                                s.eq(s.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`)
                            } else t.prev().addClass(`${i.bulletActiveClass}-prev`).prev().addClass(`${i.bulletActiveClass}-prev-prev`), a.next().addClass(`${i.bulletActiveClass}-next`).next().addClass(`${i.bulletActiveClass}-next-next`);
                        else t.prev().addClass(`${i.bulletActiveClass}-prev`).prev().addClass(`${i.bulletActiveClass}-prev-prev`), a.next().addClass(`${i.bulletActiveClass}-next`).next().addClass(`${i.bulletActiveClass}-next-next`)
                    }
                }
                if (i.dynamicBullets) {
                    const n = Math.min(s.length, i.dynamicMainBullets + 4),
                        a = (e.pagination.bulletSize * n - e.pagination.bulletSize) / 2 - l * e.pagination.bulletSize,
                        r = t ? "right" : "left";
                    s.css(e.isHorizontal() ? r : "top", `${a}px`)
                }
            }
            if ("fraction" === i.type && (n.find(`.${i.currentClass}`).text(i.formatFractionCurrent(a + 1)), n.find(`.${i.totalClass}`).text(i.formatFractionTotal(r))), "progressbar" === i.type) {
                let t;
                t = i.progressbarOpposite ? e.isHorizontal() ? "vertical" : "horizontal" : e.isHorizontal() ? "horizontal" : "vertical";
                const s = (a + 1) / r;
                let o = 1,
                    l = 1;
                "horizontal" === t ? o = s : l = s, n.find(`.${i.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${o}) scaleY(${l})`).transition(e.params.speed)
            }
            "custom" === i.type && i.renderCustom ? (n.html(i.renderCustom(e, a + 1, r)), e.emit("paginationRender", e, n[0])) : e.emit("paginationUpdate", e, n[0]), n[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](i.lockClass)
        },
        render() {
            const e = this,
                t = e.params.pagination;
            if (!t.el || !e.pagination.el || !e.pagination.$el || 0 === e.pagination.$el.length) return;
            const i = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
                s = e.pagination.$el;
            let n = "";
            if ("bullets" === t.type) {
                const a = e.params.loop ? Math.ceil((i - 2 * e.loopedSlides) / e.params.slidesPerGroup) : e.snapGrid.length;
                for (let i = 0; i < a; i += 1) t.renderBullet ? n += t.renderBullet.call(e, i, t.bulletClass) : n += `<${t.bulletElement} class="${t.bulletClass}"></${t.bulletElement}>`;
                s.html(n), e.pagination.bullets = s.find(`.${t.bulletClass}`)
            }
            "fraction" === t.type && (n = t.renderFraction ? t.renderFraction.call(e, t.currentClass, t.totalClass) : `<span class="${t.currentClass}"></span>` + " / " + `<span class="${t.totalClass}"></span>`, s.html(n)), "progressbar" === t.type && (n = t.renderProgressbar ? t.renderProgressbar.call(e, t.progressbarFillClass) : `<span class="${t.progressbarFillClass}"></span>`, s.html(n)), "custom" !== t.type && e.emit("paginationRender", e.pagination.$el[0])
        },
        init() {
            const e = this,
                t = e.params.pagination;
            if (!t.el) return;
            let i = Ce(t.el);
            0 !== i.length && (e.params.uniqueNavElements && "string" == typeof t.el && i.length > 1 && 1 === e.$el.find(t.el).length && (i = e.$el.find(t.el)), "bullets" === t.type && t.clickable && i.addClass(t.clickableClass), i.addClass(t.modifierClass + t.type), "bullets" === t.type && t.dynamicBullets && (i.addClass(`${t.modifierClass}${t.type}-dynamic`), e.pagination.dynamicBulletIndex = 0, t.dynamicMainBullets < 1 && (t.dynamicMainBullets = 1)), "progressbar" === t.type && t.progressbarOpposite && i.addClass(t.progressbarOppositeClass), t.clickable && i.on("click", `.${t.bulletClass}`, (function (t) {
                t.preventDefault();
                let i = Ce(this).index() * e.params.slidesPerGroup;
                e.params.loop && (i += e.loopedSlides), e.slideTo(i)
            })), Ie.extend(e.pagination, {
                $el: i,
                el: i[0]
            }))
        },
        destroy() {
            const e = this.params.pagination;
            if (!e.el || !this.pagination.el || !this.pagination.$el || 0 === this.pagination.$el.length) return;
            const t = this.pagination.$el;
            t.removeClass(e.hiddenClass), t.removeClass(e.modifierClass + e.type), this.pagination.bullets && this.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && t.off("click", `.${e.bulletClass}`)
        }
    };
    const ct = {
        setTranslate() {
            const e = this;
            if (!e.params.scrollbar.el || !e.scrollbar.el) return;
            const {
                scrollbar: t,
                rtlTranslate: i,
                progress: s
            } = e, {
                dragSize: n,
                trackSize: a,
                $dragEl: r,
                $el: o
            } = t, l = e.params.scrollbar;
            let d = n,
                c = (a - n) * s;
            i ? (c = -c) > 0 ? (d = n - c, c = 0) : -c + n > a && (d = a + c) : c < 0 ? (d = n + c, c = 0) : c + n > a && (d = a - c), e.isHorizontal() ? (r.transform(`translate3d(${c}px, 0, 0)`), r[0].style.width = `${d}px`) : (r.transform(`translate3d(0px, ${c}px, 0)`), r[0].style.height = `${d}px`), l.hide && (clearTimeout(e.scrollbar.timeout), o[0].style.opacity = 1, e.scrollbar.timeout = setTimeout(() => {
                o[0].style.opacity = 0, o.transition(400)
            }, 1e3))
        },
        setTransition(e) {
            this.params.scrollbar.el && this.scrollbar.el && this.scrollbar.$dragEl.transition(e)
        },
        updateSize() {
            const e = this;
            if (!e.params.scrollbar.el || !e.scrollbar.el) return;
            const {
                scrollbar: t
            } = e, {
                $dragEl: i,
                $el: s
            } = t;
            i[0].style.width = "", i[0].style.height = "";
            const n = e.isHorizontal() ? s[0].offsetWidth : s[0].offsetHeight,
                a = e.size / e.virtualSize,
                r = a * (n / e.size);
            let o;
            o = "auto" === e.params.scrollbar.dragSize ? n * a : parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? i[0].style.width = `${o}px` : i[0].style.height = `${o}px`, s[0].style.display = a >= 1 ? "none" : "", e.params.scrollbar.hide && (s[0].style.opacity = 0), Ie.extend(t, {
                trackSize: n,
                divider: a,
                moveDivider: r,
                dragSize: o
            }), t.$el[e.params.watchOverflow && e.isLocked ? "addClass" : "removeClass"](e.params.scrollbar.lockClass)
        },
        getPointerPosition(e) {
            return this.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY
        },
        setDragPosition(e) {
            const {
                scrollbar: t,
                rtlTranslate: i
            } = this, {
                $el: s,
                dragSize: n,
                trackSize: a,
                dragStartPos: r
            } = t;
            let o;
            o = (t.getPointerPosition(e) - s.offset()[this.isHorizontal() ? "left" : "top"] - (null !== r ? r : n / 2)) / (a - n), o = Math.max(Math.min(o, 1), 0), i && (o = 1 - o);
            const l = this.minTranslate() + (this.maxTranslate() - this.minTranslate()) * o;
            this.updateProgress(l), this.setTranslate(l), this.updateActiveIndex(), this.updateSlidesClasses()
        },
        onDragStart(e) {
            const t = this,
                i = t.params.scrollbar,
                {
                    scrollbar: s,
                    $wrapperEl: n
                } = t,
                {
                    $el: a,
                    $dragEl: r
                } = s;
            t.scrollbar.isTouched = !0, t.scrollbar.dragStartPos = e.target === r[0] || e.target === r ? s.getPointerPosition(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), n.transition(100), r.transition(100), s.setDragPosition(e), clearTimeout(t.scrollbar.dragTimeout), a.transition(0), i.hide && a.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), t.emit("scrollbarDragStart", e)
        },
        onDragMove(e) {
            const {
                scrollbar: t,
                $wrapperEl: i
            } = this, {
                $el: s,
                $dragEl: n
            } = t;
            this.scrollbar.isTouched && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, t.setDragPosition(e), i.transition(0), s.transition(0), n.transition(0), this.emit("scrollbarDragMove", e))
        },
        onDragEnd(e) {
            const t = this,
                i = t.params.scrollbar,
                {
                    scrollbar: s,
                    $wrapperEl: n
                } = t,
                {
                    $el: a
                } = s;
            t.scrollbar.isTouched && (t.scrollbar.isTouched = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), n.transition("")), i.hide && (clearTimeout(t.scrollbar.dragTimeout), t.scrollbar.dragTimeout = Ie.nextTick(() => {
                a.css("opacity", 0), a.transition(400)
            }, 1e3)), t.emit("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest())
        },
        enableDraggable() {
            const e = this;
            if (!e.params.scrollbar.el) return;
            const {
                scrollbar: t,
                touchEventsTouch: i,
                touchEventsDesktop: s,
                params: n
            } = e, a = t.$el[0], r = !(!$e.passiveListener || !n.passiveListeners) && {
                passive: !1,
                capture: !1
            }, o = !(!$e.passiveListener || !n.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            $e.touch ? (a.addEventListener(i.start, e.scrollbar.onDragStart, r), a.addEventListener(i.move, e.scrollbar.onDragMove, r), a.addEventListener(i.end, e.scrollbar.onDragEnd, o)) : (a.addEventListener(s.start, e.scrollbar.onDragStart, r), xe.addEventListener(s.move, e.scrollbar.onDragMove, r), xe.addEventListener(s.end, e.scrollbar.onDragEnd, o))
        },
        disableDraggable() {
            const e = this;
            if (!e.params.scrollbar.el) return;
            const {
                scrollbar: t,
                touchEventsTouch: i,
                touchEventsDesktop: s,
                params: n
            } = e, a = t.$el[0], r = !(!$e.passiveListener || !n.passiveListeners) && {
                passive: !1,
                capture: !1
            }, o = !(!$e.passiveListener || !n.passiveListeners) && {
                passive: !0,
                capture: !1
            };
            $e.touch ? (a.removeEventListener(i.start, e.scrollbar.onDragStart, r), a.removeEventListener(i.move, e.scrollbar.onDragMove, r), a.removeEventListener(i.end, e.scrollbar.onDragEnd, o)) : (a.removeEventListener(s.start, e.scrollbar.onDragStart, r), xe.removeEventListener(s.move, e.scrollbar.onDragMove, r), xe.removeEventListener(s.end, e.scrollbar.onDragEnd, o))
        },
        init() {
            const e = this;
            if (!e.params.scrollbar.el) return;
            const {
                scrollbar: t,
                $el: i
            } = e, s = e.params.scrollbar;
            let n = Ce(s.el);
            e.params.uniqueNavElements && "string" == typeof s.el && n.length > 1 && 1 === i.find(s.el).length && (n = i.find(s.el));
            let a = n.find(`.${e.params.scrollbar.dragClass}`);
            0 === a.length && (a = Ce(`<div class="${e.params.scrollbar.dragClass}"></div>`), n.append(a)), Ie.extend(t, {
                $el: n,
                el: n[0],
                $dragEl: a,
                dragEl: a[0]
            }), s.draggable && t.enableDraggable()
        },
        destroy() {
            this.scrollbar.disableDraggable()
        }
    };
    const ht = {
        setTransform(e, t) {
            const {
                rtl: i
            } = this, s = Ce(e), n = i ? -1 : 1, a = s.attr("data-swiper-parallax") || "0";
            let r = s.attr("data-swiper-parallax-x"),
                o = s.attr("data-swiper-parallax-y");
            const l = s.attr("data-swiper-parallax-scale"),
                d = s.attr("data-swiper-parallax-opacity");
            if (r || o ? (r = r || "0", o = o || "0") : this.isHorizontal() ? (r = a, o = "0") : (o = a, r = "0"), r = r.indexOf("%") >= 0 ? `${parseInt(r,10)*t*n}%` : `${r*t*n}px`, o = o.indexOf("%") >= 0 ? `${parseInt(o,10)*t}%` : `${o*t}px`, null != d) {
                const e = d - (d - 1) * (1 - Math.abs(t));
                s[0].style.opacity = e
            }
            if (null == l) s.transform(`translate3d(${r}, ${o}, 0px)`);
            else {
                const e = l - (l - 1) * (1 - Math.abs(t));
                s.transform(`translate3d(${r}, ${o}, 0px) scale(${e})`)
            }
        },
        setTranslate() {
            const e = this,
                {
                    $el: t,
                    slides: i,
                    progress: s,
                    snapGrid: n
                } = e;
            t.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, i) => {
                e.parallax.setTransform(i, s)
            }), i.each((t, i) => {
                let a = i.progress;
                e.params.slidesPerGroup > 1 && "auto" !== e.params.slidesPerView && (a += Math.ceil(t / 2) - s * (n.length - 1)), a = Math.min(Math.max(a, -1), 1), Ce(i).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, i) => {
                    e.parallax.setTransform(i, a)
                })
            })
        },
        setTransition(e = this.params.speed) {
            const {
                $el: t
            } = this;
            t.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t, i) => {
                const s = Ce(i);
                let n = parseInt(s.attr("data-swiper-parallax-duration"), 10) || e;
                0 === e && (n = 0), s.transition(n)
            })
        }
    };
    const ut = {
        getDistanceBetweenTouches(e) {
            if (e.targetTouches.length < 2) return 1;
            const t = e.targetTouches[0].pageX,
                i = e.targetTouches[0].pageY,
                s = e.targetTouches[1].pageX,
                n = e.targetTouches[1].pageY;
            return Math.sqrt((s - t) ** 2 + (n - i) ** 2)
        },
        onGestureStart(e) {
            const t = this,
                i = t.params.zoom,
                s = t.zoom,
                {
                    gesture: n
                } = s;
            if (s.fakeGestureTouched = !1, s.fakeGestureMoved = !1, !$e.gestures) {
                if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return;
                s.fakeGestureTouched = !0, n.scaleStart = ut.getDistanceBetweenTouches(e)
            }
            n.$slideEl && n.$slideEl.length || (n.$slideEl = Ce(e.target).closest(".swiper-slide"), 0 === n.$slideEl.length && (n.$slideEl = t.slides.eq(t.activeIndex)), n.$imageEl = n.$slideEl.find("img, svg, canvas"), n.$imageWrapEl = n.$imageEl.parent(`.${i.containerClass}`), n.maxRatio = n.$imageWrapEl.attr("data-swiper-zoom") || i.maxRatio, 0 !== n.$imageWrapEl.length) ? (n.$imageEl.transition(0), t.zoom.isScaling = !0) : n.$imageEl = void 0
        },
        onGestureChange(e) {
            const t = this.params.zoom,
                i = this.zoom,
                {
                    gesture: s
                } = i;
            if (!$e.gestures) {
                if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                i.fakeGestureMoved = !0, s.scaleMove = ut.getDistanceBetweenTouches(e)
            }
            s.$imageEl && 0 !== s.$imageEl.length && ($e.gestures ? i.scale = e.scale * i.currentScale : i.scale = s.scaleMove / s.scaleStart * i.currentScale, i.scale > s.maxRatio && (i.scale = s.maxRatio - 1 + (i.scale - s.maxRatio + 1) ** .5), i.scale < t.minRatio && (i.scale = t.minRatio + 1 - (t.minRatio - i.scale + 1) ** .5), s.$imageEl.transform(`translate3d(0,0,0) scale(${i.scale})`))
        },
        onGestureEnd(e) {
            const t = this.params.zoom,
                i = this.zoom,
                {
                    gesture: s
                } = i;
            if (!$e.gestures) {
                if (!i.fakeGestureTouched || !i.fakeGestureMoved) return;
                if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !He.android) return;
                i.fakeGestureTouched = !1, i.fakeGestureMoved = !1
            }
            s.$imageEl && 0 !== s.$imageEl.length && (i.scale = Math.max(Math.min(i.scale, s.maxRatio), t.minRatio), s.$imageEl.transition(this.params.speed).transform(`translate3d(0,0,0) scale(${i.scale})`), i.currentScale = i.scale, i.isScaling = !1, 1 === i.scale && (s.$slideEl = void 0))
        },
        onTouchStart(e) {
            const t = this.zoom,
                {
                    gesture: i,
                    image: s
                } = t;
            i.$imageEl && 0 !== i.$imageEl.length && (s.isTouched || (He.android && e.preventDefault(), s.isTouched = !0, s.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, s.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
        },
        onTouchMove(e) {
            const t = this,
                i = t.zoom,
                {
                    gesture: s,
                    image: n,
                    velocity: a
                } = i;
            if (!s.$imageEl || 0 === s.$imageEl.length) return;
            if (t.allowClick = !1, !n.isTouched || !s.$slideEl) return;
            n.isMoved || (n.width = s.$imageEl[0].offsetWidth, n.height = s.$imageEl[0].offsetHeight, n.startX = Ie.getTranslate(s.$imageWrapEl[0], "x") || 0, n.startY = Ie.getTranslate(s.$imageWrapEl[0], "y") || 0, s.slideWidth = s.$slideEl[0].offsetWidth, s.slideHeight = s.$slideEl[0].offsetHeight, s.$imageWrapEl.transition(0), t.rtl && (n.startX = -n.startX, n.startY = -n.startY));
            const r = n.width * i.scale,
                o = n.height * i.scale;
            if (!(r < s.slideWidth && o < s.slideHeight)) {
                if (n.minX = Math.min(s.slideWidth / 2 - r / 2, 0), n.maxX = -n.minX, n.minY = Math.min(s.slideHeight / 2 - o / 2, 0), n.maxY = -n.minY, n.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, n.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !n.isMoved && !i.isScaling) {
                    if (t.isHorizontal() && (Math.floor(n.minX) === Math.floor(n.startX) && n.touchesCurrent.x < n.touchesStart.x || Math.floor(n.maxX) === Math.floor(n.startX) && n.touchesCurrent.x > n.touchesStart.x)) return void(n.isTouched = !1);
                    if (!t.isHorizontal() && (Math.floor(n.minY) === Math.floor(n.startY) && n.touchesCurrent.y < n.touchesStart.y || Math.floor(n.maxY) === Math.floor(n.startY) && n.touchesCurrent.y > n.touchesStart.y)) return void(n.isTouched = !1)
                }
                e.preventDefault(), e.stopPropagation(), n.isMoved = !0, n.currentX = n.touchesCurrent.x - n.touchesStart.x + n.startX, n.currentY = n.touchesCurrent.y - n.touchesStart.y + n.startY, n.currentX < n.minX && (n.currentX = n.minX + 1 - (n.minX - n.currentX + 1) ** .8), n.currentX > n.maxX && (n.currentX = n.maxX - 1 + (n.currentX - n.maxX + 1) ** .8), n.currentY < n.minY && (n.currentY = n.minY + 1 - (n.minY - n.currentY + 1) ** .8), n.currentY > n.maxY && (n.currentY = n.maxY - 1 + (n.currentY - n.maxY + 1) ** .8), a.prevPositionX || (a.prevPositionX = n.touchesCurrent.x), a.prevPositionY || (a.prevPositionY = n.touchesCurrent.y), a.prevTime || (a.prevTime = Date.now()), a.x = (n.touchesCurrent.x - a.prevPositionX) / (Date.now() - a.prevTime) / 2, a.y = (n.touchesCurrent.y - a.prevPositionY) / (Date.now() - a.prevTime) / 2, Math.abs(n.touchesCurrent.x - a.prevPositionX) < 2 && (a.x = 0), Math.abs(n.touchesCurrent.y - a.prevPositionY) < 2 && (a.y = 0), a.prevPositionX = n.touchesCurrent.x, a.prevPositionY = n.touchesCurrent.y, a.prevTime = Date.now(), s.$imageWrapEl.transform(`translate3d(${n.currentX}px, ${n.currentY}px,0)`)
            }
        },
        onTouchEnd() {
            const e = this.zoom,
                {
                    gesture: t,
                    image: i,
                    velocity: s
                } = e;
            if (!t.$imageEl || 0 === t.$imageEl.length) return;
            if (!i.isTouched || !i.isMoved) return i.isTouched = !1, void(i.isMoved = !1);
            i.isTouched = !1, i.isMoved = !1;
            let n = 300,
                a = 300;
            const r = s.x * n,
                o = i.currentX + r,
                l = s.y * a,
                d = i.currentY + l;
            0 !== s.x && (n = Math.abs((o - i.currentX) / s.x)), 0 !== s.y && (a = Math.abs((d - i.currentY) / s.y));
            const c = Math.max(n, a);
            i.currentX = o, i.currentY = d;
            const h = i.width * e.scale,
                u = i.height * e.scale;
            i.minX = Math.min(t.slideWidth / 2 - h / 2, 0), i.maxX = -i.minX, i.minY = Math.min(t.slideHeight / 2 - u / 2, 0), i.maxY = -i.minY, i.currentX = Math.max(Math.min(i.currentX, i.maxX), i.minX), i.currentY = Math.max(Math.min(i.currentY, i.maxY), i.minY), t.$imageWrapEl.transition(c).transform(`translate3d(${i.currentX}px, ${i.currentY}px,0)`)
        },
        onTransitionEnd() {
            const e = this.zoom,
                {
                    gesture: t
                } = e;
            t.$slideEl && this.previousIndex !== this.activeIndex && (t.$imageEl.transform("translate3d(0,0,0) scale(1)"), t.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, e.currentScale = 1, t.$slideEl = void 0, t.$imageEl = void 0, t.$imageWrapEl = void 0)
        },
        toggle(e) {
            const t = this.zoom;
            t.scale && 1 !== t.scale ? t.out() : t.in(e)
        },
        in (e) {
            const t = this,
                i = t.zoom,
                s = t.params.zoom,
                {
                    gesture: n,
                    image: a
                } = i;
            if (n.$slideEl || (n.$slideEl = t.clickedSlide ? Ce(t.clickedSlide) : t.slides.eq(t.activeIndex), n.$imageEl = n.$slideEl.find("img, svg, canvas"), n.$imageWrapEl = n.$imageEl.parent(`.${s.containerClass}`)), !n.$imageEl || 0 === n.$imageEl.length) return;
            let r, o, l, d, c, h, u, p, m, f, g, v, y, b, w, x, E, S;
            n.$slideEl.addClass(`${s.zoomedSlideClass}`), void 0 === a.touchesStart.x && e ? (r = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, o = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (r = a.touchesStart.x, o = a.touchesStart.y), i.scale = n.$imageWrapEl.attr("data-swiper-zoom") || s.maxRatio, i.currentScale = n.$imageWrapEl.attr("data-swiper-zoom") || s.maxRatio, e ? (E = n.$slideEl[0].offsetWidth, S = n.$slideEl[0].offsetHeight, c = (l = n.$slideEl.offset().left) + E / 2 - r, h = (d = n.$slideEl.offset().top) + S / 2 - o, m = n.$imageEl[0].offsetWidth, f = n.$imageEl[0].offsetHeight, g = m * i.scale, v = f * i.scale, w = -(y = Math.min(E / 2 - g / 2, 0)), x = -(b = Math.min(S / 2 - v / 2, 0)), (u = c * i.scale) < y && (u = y), u > w && (u = w), (p = h * i.scale) < b && (p = b), p > x && (p = x)) : (u = 0, p = 0), n.$imageWrapEl.transition(300).transform(`translate3d(${u}px, ${p}px,0)`), n.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${i.scale})`)
        },
        out() {
            const e = this,
                t = e.zoom,
                i = e.params.zoom,
                {
                    gesture: s
                } = t;
            s.$slideEl || (s.$slideEl = e.clickedSlide ? Ce(e.clickedSlide) : e.slides.eq(e.activeIndex), s.$imageEl = s.$slideEl.find("img, svg, canvas"), s.$imageWrapEl = s.$imageEl.parent(`.${i.containerClass}`)), s.$imageEl && 0 !== s.$imageEl.length && (t.scale = 1, t.currentScale = 1, s.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), s.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), s.$slideEl.removeClass(`${i.zoomedSlideClass}`), s.$slideEl = void 0)
        },
        enable() {
            const e = this,
                t = e.zoom;
            if (t.enabled) return;
            t.enabled = !0;
            const i = !("touchstart" !== e.touchEvents.start || !$e.passiveListener || !e.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                },
                s = !$e.passiveListener || {
                    passive: !1,
                    capture: !0
                };
            $e.gestures ? (e.$wrapperEl.on("gesturestart", ".swiper-slide", t.onGestureStart, i), e.$wrapperEl.on("gesturechange", ".swiper-slide", t.onGestureChange, i), e.$wrapperEl.on("gestureend", ".swiper-slide", t.onGestureEnd, i)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.on(e.touchEvents.start, ".swiper-slide", t.onGestureStart, i), e.$wrapperEl.on(e.touchEvents.move, ".swiper-slide", t.onGestureChange, s), e.$wrapperEl.on(e.touchEvents.end, ".swiper-slide", t.onGestureEnd, i), e.touchEvents.cancel && e.$wrapperEl.on(e.touchEvents.cancel, ".swiper-slide", t.onGestureEnd, i)), e.$wrapperEl.on(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove, s)
        },
        disable() {
            const e = this,
                t = e.zoom;
            if (!t.enabled) return;
            e.zoom.enabled = !1;
            const i = !("touchstart" !== e.touchEvents.start || !$e.passiveListener || !e.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                },
                s = !$e.passiveListener || {
                    passive: !1,
                    capture: !0
                };
            $e.gestures ? (e.$wrapperEl.off("gesturestart", ".swiper-slide", t.onGestureStart, i), e.$wrapperEl.off("gesturechange", ".swiper-slide", t.onGestureChange, i), e.$wrapperEl.off("gestureend", ".swiper-slide", t.onGestureEnd, i)) : "touchstart" === e.touchEvents.start && (e.$wrapperEl.off(e.touchEvents.start, ".swiper-slide", t.onGestureStart, i), e.$wrapperEl.off(e.touchEvents.move, ".swiper-slide", t.onGestureChange, s), e.$wrapperEl.off(e.touchEvents.end, ".swiper-slide", t.onGestureEnd, i), e.touchEvents.cancel && e.$wrapperEl.off(e.touchEvents.cancel, ".swiper-slide", t.onGestureEnd, i)), e.$wrapperEl.off(e.touchEvents.move, `.${e.params.zoom.containerClass}`, t.onTouchMove, s)
        }
    };
    const pt = {
        loadInSlide(e, t = !0) {
            const i = this,
                s = i.params.lazy;
            if (void 0 === e) return;
            if (0 === i.slides.length) return;
            const n = i.virtual && i.params.virtual.enabled ? i.$wrapperEl.children(`.${i.params.slideClass}[data-swiper-slide-index="${e}"]`) : i.slides.eq(e);
            let a = n.find(`.${s.elementClass}:not(.${s.loadedClass}):not(.${s.loadingClass})`);
            !n.hasClass(s.elementClass) || n.hasClass(s.loadedClass) || n.hasClass(s.loadingClass) || (a = a.add(n[0])), 0 !== a.length && a.each((e, a) => {
                const r = Ce(a);
                r.addClass(s.loadingClass);
                const o = r.attr("data-background"),
                    l = r.attr("data-src"),
                    d = r.attr("data-srcset"),
                    c = r.attr("data-sizes");
                i.loadImage(r[0], l || o, d, c, !1, () => {
                    if (null != i && i && (!i || i.params) && !i.destroyed) {
                        if (o ? (r.css("background-image", `url("${o}")`), r.removeAttr("data-background")) : (d && (r.attr("srcset", d), r.removeAttr("data-srcset")), c && (r.attr("sizes", c), r.removeAttr("data-sizes")), l && (r.attr("src", l), r.removeAttr("data-src"))), r.addClass(s.loadedClass).removeClass(s.loadingClass), n.find(`.${s.preloaderClass}`).remove(), i.params.loop && t) {
                            const e = n.attr("data-swiper-slide-index");
                            if (n.hasClass(i.params.slideDuplicateClass)) {
                                const t = i.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${i.params.slideDuplicateClass})`);
                                i.lazy.loadInSlide(t.index(), !1)
                            } else {
                                const t = i.$wrapperEl.children(`.${i.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`);
                                i.lazy.loadInSlide(t.index(), !1)
                            }
                        }
                        i.emit("lazyImageReady", n[0], r[0])
                    }
                }), i.emit("lazyImageLoad", n[0], r[0])
            })
        },
        load() {
            const e = this,
                {
                    $wrapperEl: t,
                    params: i,
                    slides: s,
                    activeIndex: n
                } = e,
                a = e.virtual && i.virtual.enabled,
                r = i.lazy;
            let o = i.slidesPerView;

            function l(e) {
                if (a) {
                    if (t.children(`.${i.slideClass}[data-swiper-slide-index="${e}"]`).length) return !0
                } else if (s[e]) return !0;
                return !1
            }

            function d(e) {
                return a ? Ce(e).attr("data-swiper-slide-index") : Ce(e).index()
            }
            if ("auto" === o && (o = 0), e.lazy.initialImageLoaded || (e.lazy.initialImageLoaded = !0), e.params.watchSlidesVisibility) t.children(`.${i.slideVisibleClass}`).each((t, i) => {
                const s = a ? Ce(i).attr("data-swiper-slide-index") : Ce(i).index();
                e.lazy.loadInSlide(s)
            });
            else if (o > 1)
                for (let t = n; t < n + o; t += 1) l(t) && e.lazy.loadInSlide(t);
            else e.lazy.loadInSlide(n);
            if (r.loadPrevNext)
                if (o > 1 || r.loadPrevNextAmount && r.loadPrevNextAmount > 1) {
                    const t = r.loadPrevNextAmount,
                        i = o,
                        a = Math.min(n + i + Math.max(t, i), s.length),
                        d = Math.max(n - Math.max(i, t), 0);
                    for (let t = n + o; t < a; t += 1) l(t) && e.lazy.loadInSlide(t);
                    for (let t = d; t < n; t += 1) l(t) && e.lazy.loadInSlide(t)
                } else {
                    const s = t.children(`.${i.slideNextClass}`);
                    s.length > 0 && e.lazy.loadInSlide(d(s));
                    const n = t.children(`.${i.slidePrevClass}`);
                    n.length > 0 && e.lazy.loadInSlide(d(n))
                }
        }
    };
    const mt = {
        LinearSpline: function (e, t) {
            const i = function () {
                let e, t, i;
                return (s, n) => {
                    for (t = -1, e = s.length; e - t > 1;) s[i = e + t >> 1] <= n ? t = i : e = i;
                    return e
                }
            }();
            let s, n;
            return this.x = e, this.y = t, this.lastIndex = e.length - 1, this.interpolate = function (e) {
                return e ? (n = i(this.x, e), s = n - 1, (e - this.x[s]) * (this.y[n] - this.y[s]) / (this.x[n] - this.x[s]) + this.y[s]) : 0
            }, this
        },
        getInterpolateFunction(e) {
            const t = this;
            t.controller.spline || (t.controller.spline = t.params.loop ? new mt.LinearSpline(t.slidesGrid, e.slidesGrid) : new mt.LinearSpline(t.snapGrid, e.snapGrid))
        },
        setTranslate(e, t) {
            const i = this,
                s = i.controller.control;
            let n, a;

            function r(e) {
                const t = i.rtlTranslate ? -i.translate : i.translate;
                "slide" === i.params.controller.by && (i.controller.getInterpolateFunction(e), a = -i.controller.spline.interpolate(-t)), a && "container" !== i.params.controller.by || (n = (e.maxTranslate() - e.minTranslate()) / (i.maxTranslate() - i.minTranslate()), a = (t - i.minTranslate()) * n + e.minTranslate()), i.params.controller.inverse && (a = e.maxTranslate() - a), e.updateProgress(a), e.setTranslate(a, i), e.updateActiveIndex(), e.updateSlidesClasses()
            }
            if (Array.isArray(s))
                for (let e = 0; e < s.length; e += 1) s[e] !== t && s[e] instanceof Ue && r(s[e]);
            else s instanceof Ue && t !== s && r(s)
        },
        setTransition(e, t) {
            const i = this,
                s = i.controller.control;
            let n;

            function a(t) {
                t.setTransition(e, i), 0 !== e && (t.transitionStart(), t.params.autoHeight && Ie.nextTick(() => {
                    t.updateAutoHeight()
                }), t.$wrapperEl.transitionEnd(() => {
                    s && (t.params.loop && "slide" === i.params.controller.by && t.loopFix(), t.transitionEnd())
                }))
            }
            if (Array.isArray(s))
                for (n = 0; n < s.length; n += 1) s[n] !== t && s[n] instanceof Ue && a(s[n]);
            else s instanceof Ue && t !== s && a(s)
        }
    };
    const ft = {
        makeElFocusable: e => (e.attr("tabIndex", "0"), e),
        addElRole: (e, t) => (e.attr("role", t), e),
        addElLabel: (e, t) => (e.attr("aria-label", t), e),
        disableEl: e => (e.attr("aria-disabled", !0), e),
        enableEl: e => (e.attr("aria-disabled", !1), e),
        onEnterKey(e) {
            const t = this,
                i = t.params.a11y;
            if (13 !== e.keyCode) return;
            const s = Ce(e.target);
            t.navigation && t.navigation.$nextEl && s.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? t.a11y.notify(i.lastSlideMessage) : t.a11y.notify(i.nextSlideMessage)), t.navigation && t.navigation.$prevEl && s.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? t.a11y.notify(i.firstSlideMessage) : t.a11y.notify(i.prevSlideMessage)), t.pagination && s.is(`.${t.params.pagination.bulletClass}`) && s[0].click()
        },
        notify(e) {
            const t = this.a11y.liveRegion;
            0 !== t.length && (t.html(""), t.html(e))
        },
        updateNavigation() {
            const e = this;
            if (e.params.loop) return;
            const {
                $nextEl: t,
                $prevEl: i
            } = e.navigation;
            i && i.length > 0 && (e.isBeginning ? e.a11y.disableEl(i) : e.a11y.enableEl(i)), t && t.length > 0 && (e.isEnd ? e.a11y.disableEl(t) : e.a11y.enableEl(t))
        },
        updatePagination() {
            const e = this,
                t = e.params.a11y;
            e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.bullets.each((i, s) => {
                const n = Ce(s);
                e.a11y.makeElFocusable(n), e.a11y.addElRole(n, "button"), e.a11y.addElLabel(n, t.paginationBulletMessage.replace(/{{index}}/, n.index() + 1))
            })
        },
        init() {
            const e = this;
            e.$el.append(e.a11y.liveRegion);
            const t = e.params.a11y;
            let i, s;
            e.navigation && e.navigation.$nextEl && (i = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (s = e.navigation.$prevEl), i && (e.a11y.makeElFocusable(i), e.a11y.addElRole(i, "button"), e.a11y.addElLabel(i, t.nextSlideMessage), i.on("keydown", e.a11y.onEnterKey)), s && (e.a11y.makeElFocusable(s), e.a11y.addElRole(s, "button"), e.a11y.addElLabel(s, t.prevSlideMessage), s.on("keydown", e.a11y.onEnterKey)), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.on("keydown", `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey)
        },
        destroy() {
            const e = this;
            let t, i;
            e.a11y.liveRegion && e.a11y.liveRegion.length > 0 && e.a11y.liveRegion.remove(), e.navigation && e.navigation.$nextEl && (t = e.navigation.$nextEl), e.navigation && e.navigation.$prevEl && (i = e.navigation.$prevEl), t && t.off("keydown", e.a11y.onEnterKey), i && i.off("keydown", e.a11y.onEnterKey), e.pagination && e.params.pagination.clickable && e.pagination.bullets && e.pagination.bullets.length && e.pagination.$el.off("keydown", `.${e.params.pagination.bulletClass}`, e.a11y.onEnterKey)
        }
    };
    const gt = {
        init() {
            const e = this;
            if (!e.params.history) return;
            if (!Ee.history || !Ee.history.pushState) return e.params.history.enabled = !1, void(e.params.hashNavigation.enabled = !0);
            const t = e.history;
            t.initialized = !0, t.paths = gt.getPathValues(), (t.paths.key || t.paths.value) && (t.scrollToSlide(0, t.paths.value, e.params.runCallbacksOnInit), e.params.history.replaceState || Ee.addEventListener("popstate", e.history.setHistoryPopState))
        },
        destroy() {
            const e = this;
            e.params.history.replaceState || Ee.removeEventListener("popstate", e.history.setHistoryPopState)
        },
        setHistoryPopState() {
            this.history.paths = gt.getPathValues(), this.history.scrollToSlide(this.params.speed, this.history.paths.value, !1)
        },
        getPathValues() {
            const e = Ee.location.pathname.slice(1).split("/").filter(e => "" !== e),
                t = e.length;
            return {
                key: e[t - 2],
                value: e[t - 1]
            }
        },
        setHistory(e, t) {
            if (!this.history.initialized || !this.params.history.enabled) return;
            const i = this.slides.eq(t);
            let s = gt.slugify(i.attr("data-history"));
            Ee.location.pathname.includes(e) || (s = `${e}/${s}`);
            const n = Ee.history.state;
            n && n.value === s || (this.params.history.replaceState ? Ee.history.replaceState({
                value: s
            }, null, s) : Ee.history.pushState({
                value: s
            }, null, s))
        },
        slugify: e => e.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
        scrollToSlide(e, t, i) {
            const s = this;
            if (t)
                for (let n = 0, a = s.slides.length; n < a; n += 1) {
                    const a = s.slides.eq(n);
                    if (gt.slugify(a.attr("data-history")) === t && !a.hasClass(s.params.slideDuplicateClass)) {
                        const t = a.index();
                        s.slideTo(t, e, i)
                    }
                } else s.slideTo(0, e, i)
        }
    };
    const vt = {
        onHashCange() {
            const e = this,
                t = xe.location.hash.replace("#", "");
            if (t !== e.slides.eq(e.activeIndex).attr("data-hash")) {
                const i = e.$wrapperEl.children(`.${e.params.slideClass}[data-hash="${t}"]`).index();
                if (void 0 === i) return;
                e.slideTo(i)
            }
        },
        setHash() {
            const e = this;
            if (e.hashNavigation.initialized && e.params.hashNavigation.enabled)
                if (e.params.hashNavigation.replaceState && Ee.history && Ee.history.replaceState) Ee.history.replaceState(null, null, `#${e.slides.eq(e.activeIndex).attr("data-hash")}` || "");
                else {
                    const t = e.slides.eq(e.activeIndex),
                        i = t.attr("data-hash") || t.attr("data-history");
                    xe.location.hash = i || ""
                }
        },
        init() {
            const e = this;
            if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return;
            e.hashNavigation.initialized = !0;
            const t = xe.location.hash.replace("#", "");
            if (t) {
                const i = 0;
                for (let s = 0, n = e.slides.length; s < n; s += 1) {
                    const n = e.slides.eq(s);
                    if ((n.attr("data-hash") || n.attr("data-history")) === t && !n.hasClass(e.params.slideDuplicateClass)) {
                        const t = n.index();
                        e.slideTo(t, i, e.params.runCallbacksOnInit, !0)
                    }
                }
            }
            e.params.hashNavigation.watchState && Ce(Ee).on("hashchange", e.hashNavigation.onHashCange)
        },
        destroy() {
            const e = this;
            e.params.hashNavigation.watchState && Ce(Ee).off("hashchange", e.hashNavigation.onHashCange)
        }
    };
    const yt = {
        run() {
            const e = this,
                t = e.slides.eq(e.activeIndex);
            let i = e.params.autoplay.delay;
            t.attr("data-swiper-autoplay") && (i = t.attr("data-swiper-autoplay") || e.params.autoplay.delay), clearTimeout(e.autoplay.timeout), e.autoplay.timeout = Ie.nextTick(() => {
                e.params.autoplay.reverseDirection ? e.params.loop ? (e.loopFix(), e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.isBeginning ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(e.slides.length - 1, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slidePrev(e.params.speed, !0, !0), e.emit("autoplay")) : e.params.loop ? (e.loopFix(), e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")) : e.isEnd ? e.params.autoplay.stopOnLastSlide ? e.autoplay.stop() : (e.slideTo(0, e.params.speed, !0, !0), e.emit("autoplay")) : (e.slideNext(e.params.speed, !0, !0), e.emit("autoplay")), e.params.cssMode && e.autoplay.running && e.autoplay.run()
            }, i)
        },
        start() {
            return void 0 === this.autoplay.timeout && (!this.autoplay.running && (this.autoplay.running = !0, this.emit("autoplayStart"), this.autoplay.run(), !0))
        },
        stop() {
            const e = this;
            return !!e.autoplay.running && (void 0 !== e.autoplay.timeout && (e.autoplay.timeout && (clearTimeout(e.autoplay.timeout), e.autoplay.timeout = void 0), e.autoplay.running = !1, e.emit("autoplayStop"), !0))
        },
        pause(e) {
            const t = this;
            t.autoplay.running && (t.autoplay.paused || (t.autoplay.timeout && clearTimeout(t.autoplay.timeout), t.autoplay.paused = !0, 0 !== e && t.params.autoplay.waitForTransition ? (t.$wrapperEl[0].addEventListener("transitionend", t.autoplay.onTransitionEnd), t.$wrapperEl[0].addEventListener("webkitTransitionEnd", t.autoplay.onTransitionEnd)) : (t.autoplay.paused = !1, t.autoplay.run())))
        }
    };
    const bt = {
        setTranslate() {
            const e = this,
                {
                    slides: t
                } = e;
            for (let i = 0; i < t.length; i += 1) {
                const t = e.slides.eq(i);
                let s = -t[0].swiperSlideOffset;
                e.params.virtualTranslate || (s -= e.translate);
                let n = 0;
                e.isHorizontal() || (n = s, s = 0);
                const a = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(t[0].progress), 0) : 1 + Math.min(Math.max(t[0].progress, -1), 0);
                t.css({
                    opacity: a
                }).transform(`translate3d(${s}px, ${n}px, 0px)`)
            }
        },
        setTransition(e) {
            const t = this,
                {
                    slides: i,
                    $wrapperEl: s
                } = t;
            if (i.transition(e), t.params.virtualTranslate && 0 !== e) {
                let e = !1;
                i.transitionEnd(() => {
                    if (e) return;
                    if (!t || t.destroyed) return;
                    e = !0, t.animating = !1;
                    const i = ["webkitTransitionEnd", "transitionend"];
                    for (let e = 0; e < i.length; e += 1) s.trigger(i[e])
                })
            }
        }
    };
    const wt = {
        setTranslate() {
            const {
                $el: e,
                $wrapperEl: t,
                slides: i,
                width: s,
                height: n,
                rtlTranslate: a,
                size: r
            } = this, o = this.params.cubeEffect, l = this.isHorizontal(), d = this.virtual && this.params.virtual.enabled;
            let c, h = 0;
            o.shadow && (l ? (0 === (c = t.find(".swiper-cube-shadow")).length && (c = Ce('<div class="swiper-cube-shadow"></div>'), t.append(c)), c.css({
                height: `${s}px`
            })) : 0 === (c = e.find(".swiper-cube-shadow")).length && (c = Ce('<div class="swiper-cube-shadow"></div>'), e.append(c)));
            for (let e = 0; e < i.length; e += 1) {
                const t = i.eq(e);
                let s = e;
                d && (s = parseInt(t.attr("data-swiper-slide-index"), 10));
                let n = 90 * s,
                    c = Math.floor(n / 360);
                a && (n = -n, c = Math.floor(-n / 360));
                const u = Math.max(Math.min(t[0].progress, 1), -1);
                let p = 0,
                    m = 0,
                    f = 0;
                s % 4 == 0 ? (p = 4 * -c * r, f = 0) : (s - 1) % 4 == 0 ? (p = 0, f = 4 * -c * r) : (s - 2) % 4 == 0 ? (p = r + 4 * c * r, f = r) : (s - 3) % 4 == 0 && (p = -r, f = 3 * r + 4 * r * c), a && (p = -p), l || (m = p, p = 0);
                const g = `rotateX(${l?0:-n}deg) rotateY(${l?n:0}deg) translate3d(${p}px, ${m}px, ${f}px)`;
                if (u <= 1 && u > -1 && (h = 90 * s + 90 * u, a && (h = 90 * -s - 90 * u)), t.transform(g), o.slideShadows) {
                    let e = l ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                        i = l ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                    0 === e.length && (e = Ce(`<div class="swiper-slide-shadow-${l?"left":"top"}"></div>`), t.append(e)), 0 === i.length && (i = Ce(`<div class="swiper-slide-shadow-${l?"right":"bottom"}"></div>`), t.append(i)), e.length && (e[0].style.opacity = Math.max(-u, 0)), i.length && (i[0].style.opacity = Math.max(u, 0))
                }
            }
            if (t.css({
                    "-webkit-transform-origin": `50% 50% -${r/2}px`,
                    "-moz-transform-origin": `50% 50% -${r/2}px`,
                    "-ms-transform-origin": `50% 50% -${r/2}px`,
                    "transform-origin": `50% 50% -${r/2}px`
                }), o.shadow)
                if (l) c.transform(`translate3d(0px, ${s/2+o.shadowOffset}px, ${-s/2}px) rotateX(90deg) rotateZ(0deg) scale(${o.shadowScale})`);
                else {
                    const e = Math.abs(h) - 90 * Math.floor(Math.abs(h) / 90),
                        t = 1.5 - (Math.sin(2 * e * Math.PI / 360) / 2 + Math.cos(2 * e * Math.PI / 360) / 2),
                        i = o.shadowScale,
                        s = o.shadowScale / t,
                        a = o.shadowOffset;
                    c.transform(`scale3d(${i}, 1, ${s}) translate3d(0px, ${n/2+a}px, ${-n/2/s}px) rotateX(-90deg)`)
                } const u = Je.isSafari || Je.isUiWebView ? -r / 2 : 0;
            t.transform(`translate3d(0px,0,${u}px) rotateX(${this.isHorizontal()?0:h}deg) rotateY(${this.isHorizontal()?-h:0}deg)`)
        },
        setTransition(e) {
            const {
                $el: t,
                slides: i
            } = this;
            i.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), this.params.cubeEffect.shadow && !this.isHorizontal() && t.find(".swiper-cube-shadow").transition(e)
        }
    };
    const xt = {
        setTranslate() {
            const e = this,
                {
                    slides: t,
                    rtlTranslate: i
                } = e;
            for (let s = 0; s < t.length; s += 1) {
                const n = t.eq(s);
                let a = n[0].progress;
                e.params.flipEffect.limitRotation && (a = Math.max(Math.min(n[0].progress, 1), -1));
                let r = -180 * a,
                    o = 0,
                    l = -n[0].swiperSlideOffset,
                    d = 0;
                if (e.isHorizontal() ? i && (r = -r) : (d = l, l = 0, o = -r, r = 0), n[0].style.zIndex = -Math.abs(Math.round(a)) + t.length, e.params.flipEffect.slideShadows) {
                    let t = e.isHorizontal() ? n.find(".swiper-slide-shadow-left") : n.find(".swiper-slide-shadow-top"),
                        i = e.isHorizontal() ? n.find(".swiper-slide-shadow-right") : n.find(".swiper-slide-shadow-bottom");
                    0 === t.length && (t = Ce(`<div class="swiper-slide-shadow-${e.isHorizontal()?"left":"top"}"></div>`), n.append(t)), 0 === i.length && (i = Ce(`<div class="swiper-slide-shadow-${e.isHorizontal()?"right":"bottom"}"></div>`), n.append(i)), t.length && (t[0].style.opacity = Math.max(-a, 0)), i.length && (i[0].style.opacity = Math.max(a, 0))
                }
                n.transform(`translate3d(${l}px, ${d}px, 0px) rotateX(${o}deg) rotateY(${r}deg)`)
            }
        },
        setTransition(e) {
            const t = this,
                {
                    slides: i,
                    activeIndex: s,
                    $wrapperEl: n
                } = t;
            if (i.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.virtualTranslate && 0 !== e) {
                let e = !1;
                i.eq(s).transitionEnd((function () {
                    if (e) return;
                    if (!t || t.destroyed) return;
                    e = !0, t.animating = !1;
                    const i = ["webkitTransitionEnd", "transitionend"];
                    for (let e = 0; e < i.length; e += 1) n.trigger(i[e])
                }))
            }
        }
    };
    const Et = {
        setTranslate() {
            const {
                width: e,
                height: t,
                slides: i,
                $wrapperEl: s,
                slidesSizesGrid: n
            } = this, a = this.params.coverflowEffect, r = this.isHorizontal(), o = this.translate, l = r ? e / 2 - o : t / 2 - o, d = r ? a.rotate : -a.rotate, c = a.depth;
            for (let e = 0, t = i.length; e < t; e += 1) {
                const t = i.eq(e),
                    s = n[e],
                    o = (l - t[0].swiperSlideOffset - s / 2) / s * a.modifier;
                let h = r ? d * o : 0,
                    u = r ? 0 : d * o,
                    p = -c * Math.abs(o),
                    m = r ? 0 : a.stretch * o,
                    f = r ? a.stretch * o : 0;
                Math.abs(f) < .001 && (f = 0), Math.abs(m) < .001 && (m = 0), Math.abs(p) < .001 && (p = 0), Math.abs(h) < .001 && (h = 0), Math.abs(u) < .001 && (u = 0);
                const g = `translate3d(${f}px,${m}px,${p}px)  rotateX(${u}deg) rotateY(${h}deg)`;
                if (t.transform(g), t[0].style.zIndex = 1 - Math.abs(Math.round(o)), a.slideShadows) {
                    let e = r ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                        i = r ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                    0 === e.length && (e = Ce(`<div class="swiper-slide-shadow-${r?"left":"top"}"></div>`), t.append(e)), 0 === i.length && (i = Ce(`<div class="swiper-slide-shadow-${r?"right":"bottom"}"></div>`), t.append(i)), e.length && (e[0].style.opacity = o > 0 ? o : 0), i.length && (i[0].style.opacity = -o > 0 ? -o : 0)
                }
            }
            if ($e.pointerEvents || $e.prefixedPointerEvents) {
                s[0].style.perspectiveOrigin = `${l}px 50%`
            }
        },
        setTransition(e) {
            this.slides.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)
        }
    };
    const St = {
        init() {
            const e = this,
                {
                    thumbs: t
                } = e.params,
                i = e.constructor;
            t.swiper instanceof i ? (e.thumbs.swiper = t.swiper, Ie.extend(e.thumbs.swiper.originalParams, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            }), Ie.extend(e.thumbs.swiper.params, {
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            })) : Ie.isObject(t.swiper) && (e.thumbs.swiper = new i(Ie.extend({}, t.swiper, {
                watchSlidesVisibility: !0,
                watchSlidesProgress: !0,
                slideToClickedSlide: !1
            })), e.thumbs.swiperCreated = !0), e.thumbs.swiper.$el.addClass(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", e.thumbs.onThumbClick)
        },
        onThumbClick() {
            const e = this,
                t = e.thumbs.swiper;
            if (!t) return;
            const i = t.clickedIndex,
                s = t.clickedSlide;
            if (s && Ce(s).hasClass(e.params.thumbs.slideThumbActiveClass)) return;
            if (null == i) return;
            let n;
            if (n = t.params.loop ? parseInt(Ce(t.clickedSlide).attr("data-swiper-slide-index"), 10) : i, e.params.loop) {
                let t = e.activeIndex;
                e.slides.eq(t).hasClass(e.params.slideDuplicateClass) && (e.loopFix(), e._clientLeft = e.$wrapperEl[0].clientLeft, t = e.activeIndex);
                const i = e.slides.eq(t).prevAll(`[data-swiper-slide-index="${n}"]`).eq(0).index(),
                    s = e.slides.eq(t).nextAll(`[data-swiper-slide-index="${n}"]`).eq(0).index();
                n = void 0 === i ? s : void 0 === s ? i : s - t < t - i ? s : i
            }
            e.slideTo(n)
        },
        update(e) {
            const t = this,
                i = t.thumbs.swiper;
            if (!i) return;
            const s = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView;
            if (t.realIndex !== i.realIndex) {
                let n, a = i.activeIndex;
                if (i.params.loop) {
                    i.slides.eq(a).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, a = i.activeIndex);
                    const e = i.slides.eq(a).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(),
                        s = i.slides.eq(a).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index();
                    n = void 0 === e ? s : void 0 === s ? e : s - a == a - e ? a : s - a < a - e ? s : e
                } else n = t.realIndex;
                i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(n) < 0 && (i.params.centeredSlides ? n = n > a ? n - Math.floor(s / 2) + 1 : n + Math.floor(s / 2) - 1 : n > a && (n = n - s + 1), i.slideTo(n, e ? 0 : void 0))
            }
            let n = 1;
            const a = t.params.thumbs.slideThumbActiveClass;
            if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (n = t.params.slidesPerView), i.slides.removeClass(a), i.params.loop || i.params.virtual && i.params.virtual.enabled)
                for (let e = 0; e < n; e += 1) i.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex+e}"]`).addClass(a);
            else
                for (let e = 0; e < n; e += 1) i.slides.eq(t.realIndex + e).addClass(a)
        }
    };
    const Ct = [Ke, Qe, Ze, et, it, nt, rt, {
        name: "mousewheel",
        params: {
            mousewheel: {
                enabled: !1,
                releaseOnEdges: !1,
                invert: !1,
                forceToAxis: !1,
                sensitivity: 1,
                eventsTarged: "container"
            }
        },
        create() {
            Ie.extend(this, {
                mousewheel: {
                    enabled: !1,
                    enable: ot.enable.bind(this),
                    disable: ot.disable.bind(this),
                    handle: ot.handle.bind(this),
                    handleMouseEnter: ot.handleMouseEnter.bind(this),
                    handleMouseLeave: ot.handleMouseLeave.bind(this),
                    lastScrollTime: Ie.now(),
                    lastEventBeforeSnap: void 0,
                    recentWheelEvents: []
                }
            })
        },
        on: {
            init() {
                const e = this;
                !e.params.mousewheel.enabled && e.params.cssMode && e.mousewheel.disable(), e.params.mousewheel.enabled && e.mousewheel.enable()
            },
            destroy() {
                const e = this;
                e.params.cssMode && e.mousewheel.enable(), e.mousewheel.enabled && e.mousewheel.disable()
            }
        }
    }, {
        name: "navigation",
        params: {
            navigation: {
                nextEl: null,
                prevEl: null,
                hideOnClick: !1,
                disabledClass: "swiper-button-disabled",
                hiddenClass: "swiper-button-hidden",
                lockClass: "swiper-button-lock"
            }
        },
        create() {
            Ie.extend(this, {
                navigation: {
                    init: lt.init.bind(this),
                    update: lt.update.bind(this),
                    destroy: lt.destroy.bind(this),
                    onNextClick: lt.onNextClick.bind(this),
                    onPrevClick: lt.onPrevClick.bind(this)
                }
            })
        },
        on: {
            init() {
                this.navigation.init(), this.navigation.update()
            },
            toEdge() {
                this.navigation.update()
            },
            fromEdge() {
                this.navigation.update()
            },
            destroy() {
                this.navigation.destroy()
            },
            click(e) {
                const t = this,
                    {
                        $nextEl: i,
                        $prevEl: s
                    } = t.navigation;
                if (t.params.navigation.hideOnClick && !Ce(e.target).is(s) && !Ce(e.target).is(i)) {
                    let e;
                    i ? e = i.hasClass(t.params.navigation.hiddenClass) : s && (e = s.hasClass(t.params.navigation.hiddenClass)), !0 === e ? t.emit("navigationShow", t) : t.emit("navigationHide", t), i && i.toggleClass(t.params.navigation.hiddenClass), s && s.toggleClass(t.params.navigation.hiddenClass)
                }
            }
        }
    }, {
        name: "pagination",
        params: {
            pagination: {
                el: null,
                bulletElement: "span",
                clickable: !1,
                hideOnClick: !1,
                renderBullet: null,
                renderProgressbar: null,
                renderFraction: null,
                renderCustom: null,
                progressbarOpposite: !1,
                type: "bullets",
                dynamicBullets: !1,
                dynamicMainBullets: 1,
                formatFractionCurrent: e => e,
                formatFractionTotal: e => e,
                bulletClass: "swiper-pagination-bullet",
                bulletActiveClass: "swiper-pagination-bullet-active",
                modifierClass: "swiper-pagination-",
                currentClass: "swiper-pagination-current",
                totalClass: "swiper-pagination-total",
                hiddenClass: "swiper-pagination-hidden",
                progressbarFillClass: "swiper-pagination-progressbar-fill",
                progressbarOppositeClass: "swiper-pagination-progressbar-opposite",
                clickableClass: "swiper-pagination-clickable",
                lockClass: "swiper-pagination-lock"
            }
        },
        create() {
            Ie.extend(this, {
                pagination: {
                    init: dt.init.bind(this),
                    render: dt.render.bind(this),
                    update: dt.update.bind(this),
                    destroy: dt.destroy.bind(this),
                    dynamicBulletIndex: 0
                }
            })
        },
        on: {
            init() {
                this.pagination.init(), this.pagination.render(), this.pagination.update()
            },
            activeIndexChange() {
                const e = this;
                e.params.loop ? e.pagination.update() : void 0 === e.snapIndex && e.pagination.update()
            },
            snapIndexChange() {
                const e = this;
                e.params.loop || e.pagination.update()
            },
            slidesLengthChange() {
                const e = this;
                e.params.loop && (e.pagination.render(), e.pagination.update())
            },
            snapGridLengthChange() {
                const e = this;
                e.params.loop || (e.pagination.render(), e.pagination.update())
            },
            destroy() {
                this.pagination.destroy()
            },
            click(e) {
                const t = this;
                if (t.params.pagination.el && t.params.pagination.hideOnClick && t.pagination.$el.length > 0 && !Ce(e.target).hasClass(t.params.pagination.bulletClass)) {
                    !0 === t.pagination.$el.hasClass(t.params.pagination.hiddenClass) ? t.emit("paginationShow", t) : t.emit("paginationHide", t), t.pagination.$el.toggleClass(t.params.pagination.hiddenClass)
                }
            }
        }
    }, {
        name: "scrollbar",
        params: {
            scrollbar: {
                el: null,
                dragSize: "auto",
                hide: !1,
                draggable: !1,
                snapOnRelease: !0,
                lockClass: "swiper-scrollbar-lock",
                dragClass: "swiper-scrollbar-drag"
            }
        },
        create() {
            Ie.extend(this, {
                scrollbar: {
                    init: ct.init.bind(this),
                    destroy: ct.destroy.bind(this),
                    updateSize: ct.updateSize.bind(this),
                    setTranslate: ct.setTranslate.bind(this),
                    setTransition: ct.setTransition.bind(this),
                    enableDraggable: ct.enableDraggable.bind(this),
                    disableDraggable: ct.disableDraggable.bind(this),
                    setDragPosition: ct.setDragPosition.bind(this),
                    getPointerPosition: ct.getPointerPosition.bind(this),
                    onDragStart: ct.onDragStart.bind(this),
                    onDragMove: ct.onDragMove.bind(this),
                    onDragEnd: ct.onDragEnd.bind(this),
                    isTouched: !1,
                    timeout: null,
                    dragTimeout: null
                }
            })
        },
        on: {
            init() {
                this.scrollbar.init(), this.scrollbar.updateSize(), this.scrollbar.setTranslate()
            },
            update() {
                this.scrollbar.updateSize()
            },
            resize() {
                this.scrollbar.updateSize()
            },
            observerUpdate() {
                this.scrollbar.updateSize()
            },
            setTranslate() {
                this.scrollbar.setTranslate()
            },
            setTransition(e) {
                this.scrollbar.setTransition(e)
            },
            destroy() {
                this.scrollbar.destroy()
            }
        }
    }, {
        name: "parallax",
        params: {
            parallax: {
                enabled: !1
            }
        },
        create() {
            Ie.extend(this, {
                parallax: {
                    setTransform: ht.setTransform.bind(this),
                    setTranslate: ht.setTranslate.bind(this),
                    setTransition: ht.setTransition.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                this.params.parallax.enabled && (this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0)
            },
            init() {
                this.params.parallax.enabled && this.parallax.setTranslate()
            },
            setTranslate() {
                this.params.parallax.enabled && this.parallax.setTranslate()
            },
            setTransition(e) {
                this.params.parallax.enabled && this.parallax.setTransition(e)
            }
        }
    }, {
        name: "zoom",
        params: {
            zoom: {
                enabled: !1,
                maxRatio: 3,
                minRatio: 1,
                toggle: !0,
                containerClass: "swiper-zoom-container",
                zoomedSlideClass: "swiper-slide-zoomed"
            }
        },
        create() {
            const e = this,
                t = {
                    enabled: !1,
                    scale: 1,
                    currentScale: 1,
                    isScaling: !1,
                    gesture: {
                        $slideEl: void 0,
                        slideWidth: void 0,
                        slideHeight: void 0,
                        $imageEl: void 0,
                        $imageWrapEl: void 0,
                        maxRatio: 3
                    },
                    image: {
                        isTouched: void 0,
                        isMoved: void 0,
                        currentX: void 0,
                        currentY: void 0,
                        minX: void 0,
                        minY: void 0,
                        maxX: void 0,
                        maxY: void 0,
                        width: void 0,
                        height: void 0,
                        startX: void 0,
                        startY: void 0,
                        touchesStart: {},
                        touchesCurrent: {}
                    },
                    velocity: {
                        x: void 0,
                        y: void 0,
                        prevPositionX: void 0,
                        prevPositionY: void 0,
                        prevTime: void 0
                    }
                };
            "onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out".split(" ").forEach(i => {
                t[i] = ut[i].bind(e)
            }), Ie.extend(e, {
                zoom: t
            });
            let i = 1;
            Object.defineProperty(e.zoom, "scale", {
                get: () => i,
                set(t) {
                    if (i !== t) {
                        const i = e.zoom.gesture.$imageEl ? e.zoom.gesture.$imageEl[0] : void 0,
                            s = e.zoom.gesture.$slideEl ? e.zoom.gesture.$slideEl[0] : void 0;
                        e.emit("zoomChange", t, i, s)
                    }
                    i = t
                }
            })
        },
        on: {
            init() {
                const e = this;
                e.params.zoom.enabled && e.zoom.enable()
            },
            destroy() {
                this.zoom.disable()
            },
            touchStart(e) {
                this.zoom.enabled && this.zoom.onTouchStart(e)
            },
            touchEnd(e) {
                this.zoom.enabled && this.zoom.onTouchEnd(e)
            },
            doubleTap(e) {
                const t = this;
                t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && t.zoom.toggle(e)
            },
            transitionEnd() {
                const e = this;
                e.zoom.enabled && e.params.zoom.enabled && e.zoom.onTransitionEnd()
            },
            slideChange() {
                const e = this;
                e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && e.zoom.onTransitionEnd()
            }
        }
    }, {
        name: "lazy",
        params: {
            lazy: {
                enabled: !1,
                loadPrevNext: !1,
                loadPrevNextAmount: 1,
                loadOnTransitionStart: !1,
                elementClass: "swiper-lazy",
                loadingClass: "swiper-lazy-loading",
                loadedClass: "swiper-lazy-loaded",
                preloaderClass: "swiper-lazy-preloader"
            }
        },
        create() {
            Ie.extend(this, {
                lazy: {
                    initialImageLoaded: !1,
                    load: pt.load.bind(this),
                    loadInSlide: pt.loadInSlide.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                const e = this;
                e.params.lazy.enabled && e.params.preloadImages && (e.params.preloadImages = !1)
            },
            init() {
                const e = this;
                e.params.lazy.enabled && !e.params.loop && 0 === e.params.initialSlide && e.lazy.load()
            },
            scroll() {
                const e = this;
                e.params.freeMode && !e.params.freeModeSticky && e.lazy.load()
            },
            resize() {
                const e = this;
                e.params.lazy.enabled && e.lazy.load()
            },
            scrollbarDragMove() {
                const e = this;
                e.params.lazy.enabled && e.lazy.load()
            },
            transitionStart() {
                const e = this;
                e.params.lazy.enabled && (e.params.lazy.loadOnTransitionStart || !e.params.lazy.loadOnTransitionStart && !e.lazy.initialImageLoaded) && e.lazy.load()
            },
            transitionEnd() {
                const e = this;
                e.params.lazy.enabled && !e.params.lazy.loadOnTransitionStart && e.lazy.load()
            },
            slideChange() {
                const e = this;
                e.params.lazy.enabled && e.params.cssMode && e.lazy.load()
            }
        }
    }, {
        name: "controller",
        params: {
            controller: {
                control: void 0,
                inverse: !1,
                by: "slide"
            }
        },
        create() {
            Ie.extend(this, {
                controller: {
                    control: this.params.controller.control,
                    getInterpolateFunction: mt.getInterpolateFunction.bind(this),
                    setTranslate: mt.setTranslate.bind(this),
                    setTransition: mt.setTransition.bind(this)
                }
            })
        },
        on: {
            update() {
                const e = this;
                e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
            },
            resize() {
                const e = this;
                e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
            },
            observerUpdate() {
                const e = this;
                e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline)
            },
            setTranslate(e, t) {
                this.controller.control && this.controller.setTranslate(e, t)
            },
            setTransition(e, t) {
                this.controller.control && this.controller.setTransition(e, t)
            }
        }
    }, {
        name: "a11y",
        params: {
            a11y: {
                enabled: !0,
                notificationClass: "swiper-notification",
                prevSlideMessage: "Previous slide",
                nextSlideMessage: "Next slide",
                firstSlideMessage: "This is the first slide",
                lastSlideMessage: "This is the last slide",
                paginationBulletMessage: "Go to slide {{index}}"
            }
        },
        create() {
            const e = this;
            Ie.extend(e, {
                a11y: {
                    liveRegion: Ce(`<span class="${e.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
                }
            }), Object.keys(ft).forEach(t => {
                e.a11y[t] = ft[t].bind(e)
            })
        },
        on: {
            init() {
                this.params.a11y.enabled && (this.a11y.init(), this.a11y.updateNavigation())
            },
            toEdge() {
                this.params.a11y.enabled && this.a11y.updateNavigation()
            },
            fromEdge() {
                this.params.a11y.enabled && this.a11y.updateNavigation()
            },
            paginationUpdate() {
                this.params.a11y.enabled && this.a11y.updatePagination()
            },
            destroy() {
                this.params.a11y.enabled && this.a11y.destroy()
            }
        }
    }, {
        name: "history",
        params: {
            history: {
                enabled: !1,
                replaceState: !1,
                key: "slides"
            }
        },
        create() {
            Ie.extend(this, {
                history: {
                    init: gt.init.bind(this),
                    setHistory: gt.setHistory.bind(this),
                    setHistoryPopState: gt.setHistoryPopState.bind(this),
                    scrollToSlide: gt.scrollToSlide.bind(this),
                    destroy: gt.destroy.bind(this)
                }
            })
        },
        on: {
            init() {
                const e = this;
                e.params.history.enabled && e.history.init()
            },
            destroy() {
                const e = this;
                e.params.history.enabled && e.history.destroy()
            },
            transitionEnd() {
                const e = this;
                e.history.initialized && e.history.setHistory(e.params.history.key, e.activeIndex)
            },
            slideChange() {
                const e = this;
                e.history.initialized && e.params.cssMode && e.history.setHistory(e.params.history.key, e.activeIndex)
            }
        }
    }, {
        name: "hash-navigation",
        params: {
            hashNavigation: {
                enabled: !1,
                replaceState: !1,
                watchState: !1
            }
        },
        create() {
            Ie.extend(this, {
                hashNavigation: {
                    initialized: !1,
                    init: vt.init.bind(this),
                    destroy: vt.destroy.bind(this),
                    setHash: vt.setHash.bind(this),
                    onHashCange: vt.onHashCange.bind(this)
                }
            })
        },
        on: {
            init() {
                const e = this;
                e.params.hashNavigation.enabled && e.hashNavigation.init()
            },
            destroy() {
                const e = this;
                e.params.hashNavigation.enabled && e.hashNavigation.destroy()
            },
            transitionEnd() {
                const e = this;
                e.hashNavigation.initialized && e.hashNavigation.setHash()
            },
            slideChange() {
                const e = this;
                e.hashNavigation.initialized && e.params.cssMode && e.hashNavigation.setHash()
            }
        }
    }, {
        name: "autoplay",
        params: {
            autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1
            }
        },
        create() {
            const e = this;
            Ie.extend(e, {
                autoplay: {
                    running: !1,
                    paused: !1,
                    run: yt.run.bind(e),
                    start: yt.start.bind(e),
                    stop: yt.stop.bind(e),
                    pause: yt.pause.bind(e),
                    onVisibilityChange() {
                        "hidden" === document.visibilityState && e.autoplay.running && e.autoplay.pause(), "visible" === document.visibilityState && e.autoplay.paused && (e.autoplay.run(), e.autoplay.paused = !1)
                    },
                    onTransitionEnd(t) {
                        e && !e.destroyed && e.$wrapperEl && t.target === this && (e.$wrapperEl[0].removeEventListener("transitionend", e.autoplay.onTransitionEnd), e.$wrapperEl[0].removeEventListener("webkitTransitionEnd", e.autoplay.onTransitionEnd), e.autoplay.paused = !1, e.autoplay.running ? e.autoplay.run() : e.autoplay.stop())
                    }
                }
            })
        },
        on: {
            init() {
                const e = this;
                e.params.autoplay.enabled && (e.autoplay.start(), document.addEventListener("visibilitychange", e.autoplay.onVisibilityChange))
            },
            beforeTransitionStart(e, t) {
                const i = this;
                i.autoplay.running && (t || !i.params.autoplay.disableOnInteraction ? i.autoplay.pause(e) : i.autoplay.stop())
            },
            sliderFirstMove() {
                const e = this;
                e.autoplay.running && (e.params.autoplay.disableOnInteraction ? e.autoplay.stop() : e.autoplay.pause())
            },
            touchEnd() {
                const e = this;
                e.params.cssMode && e.autoplay.paused && !e.params.autoplay.disableOnInteraction && e.autoplay.run()
            },
            destroy() {
                const e = this;
                e.autoplay.running && e.autoplay.stop(), document.removeEventListener("visibilitychange", e.autoplay.onVisibilityChange)
            }
        }
    }, {
        name: "effect-fade",
        params: {
            fadeEffect: {
                crossFade: !1
            }
        },
        create() {
            Ie.extend(this, {
                fadeEffect: {
                    setTranslate: bt.setTranslate.bind(this),
                    setTransition: bt.setTransition.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                if ("fade" !== this.params.effect) return;
                this.classNames.push(`${this.params.containerModifierClass}fade`);
                const e = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    spaceBetween: 0,
                    virtualTranslate: !0
                };
                Ie.extend(this.params, e), Ie.extend(this.originalParams, e)
            },
            setTranslate() {
                "fade" === this.params.effect && this.fadeEffect.setTranslate()
            },
            setTransition(e) {
                "fade" === this.params.effect && this.fadeEffect.setTransition(e)
            }
        }
    }, {
        name: "effect-cube",
        params: {
            cubeEffect: {
                slideShadows: !0,
                shadow: !0,
                shadowOffset: 20,
                shadowScale: .94
            }
        },
        create() {
            Ie.extend(this, {
                cubeEffect: {
                    setTranslate: wt.setTranslate.bind(this),
                    setTransition: wt.setTransition.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                if ("cube" !== this.params.effect) return;
                this.classNames.push(`${this.params.containerModifierClass}cube`), this.classNames.push(`${this.params.containerModifierClass}3d`);
                const e = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    resistanceRatio: 0,
                    spaceBetween: 0,
                    centeredSlides: !1,
                    virtualTranslate: !0
                };
                Ie.extend(this.params, e), Ie.extend(this.originalParams, e)
            },
            setTranslate() {
                "cube" === this.params.effect && this.cubeEffect.setTranslate()
            },
            setTransition(e) {
                "cube" === this.params.effect && this.cubeEffect.setTransition(e)
            }
        }
    }, {
        name: "effect-flip",
        params: {
            flipEffect: {
                slideShadows: !0,
                limitRotation: !0
            }
        },
        create() {
            Ie.extend(this, {
                flipEffect: {
                    setTranslate: xt.setTranslate.bind(this),
                    setTransition: xt.setTransition.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                if ("flip" !== this.params.effect) return;
                this.classNames.push(`${this.params.containerModifierClass}flip`), this.classNames.push(`${this.params.containerModifierClass}3d`);
                const e = {
                    slidesPerView: 1,
                    slidesPerColumn: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    spaceBetween: 0,
                    virtualTranslate: !0
                };
                Ie.extend(this.params, e), Ie.extend(this.originalParams, e)
            },
            setTranslate() {
                "flip" === this.params.effect && this.flipEffect.setTranslate()
            },
            setTransition(e) {
                "flip" === this.params.effect && this.flipEffect.setTransition(e)
            }
        }
    }, {
        name: "effect-coverflow",
        params: {
            coverflowEffect: {
                rotate: 50,
                stretch: 0,
                depth: 100,
                modifier: 1,
                slideShadows: !0
            }
        },
        create() {
            Ie.extend(this, {
                coverflowEffect: {
                    setTranslate: Et.setTranslate.bind(this),
                    setTransition: Et.setTransition.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                "coverflow" === this.params.effect && (this.classNames.push(`${this.params.containerModifierClass}coverflow`), this.classNames.push(`${this.params.containerModifierClass}3d`), this.params.watchSlidesProgress = !0, this.originalParams.watchSlidesProgress = !0)
            },
            setTranslate() {
                "coverflow" === this.params.effect && this.coverflowEffect.setTranslate()
            },
            setTransition(e) {
                "coverflow" === this.params.effect && this.coverflowEffect.setTransition(e)
            }
        }
    }, {
        name: "thumbs",
        params: {
            thumbs: {
                swiper: null,
                slideThumbActiveClass: "swiper-slide-thumb-active",
                thumbsContainerClass: "swiper-container-thumbs"
            }
        },
        create() {
            Ie.extend(this, {
                thumbs: {
                    swiper: null,
                    init: St.init.bind(this),
                    update: St.update.bind(this),
                    onThumbClick: St.onThumbClick.bind(this)
                }
            })
        },
        on: {
            beforeInit() {
                const {
                    thumbs: e
                } = this.params;
                e && e.swiper && (this.thumbs.init(), this.thumbs.update(!0))
            },
            slideChange() {
                this.thumbs.swiper && this.thumbs.update()
            },
            update() {
                this.thumbs.swiper && this.thumbs.update()
            },
            resize() {
                this.thumbs.swiper && this.thumbs.update()
            },
            observerUpdate() {
                this.thumbs.swiper && this.thumbs.update()
            },
            setTransition(e) {
                const t = this.thumbs.swiper;
                t && t.setTransition(e)
            },
            beforeDestroy() {
                const e = this.thumbs.swiper;
                e && this.thumbs.swiperCreated && e && e.destroy()
            }
        }
    }];
    void 0 === Ue.use && (Ue.use = Ue.Class.use, Ue.installModule = Ue.Class.installModule), Ue.use(Ct);
    const Tt = {
            slideDuration: 5e3,
            isAutoPlaying: !0,
            prevCurrent: ""
        },
        Lt = () => {
            const e = document.querySelector(".sz-custom-slide-pagination"),
                t = document.createElement("DIV"),
                i = document.createElement("DIV");
            t.className = "sz-pagination-bar", i.className = "sz-pagination-timer", t.appendChild(i), e.appendChild(t)
        },
        It = e => {
            let t = Date.now(),
                i = setInterval((function () {
                    let s = Date.now() - t;
                    s >= Tt.slideDuration || !1 === Tt.isAutoPlaying ? clearInterval(i) : e.children[0].style.width = s / (Tt.slideDuration / 100) + "%"
                }), 20)
        };
    const $t = (e = ".sz-draggable-slider-container", t = {}) => {
            new Ue(e, {
                wrapperClass: "sz-draggable-slider-wrapper",
                slideClass: "sz-draggable-slide-wrapper",
                direction: "horizontal",
                slidesPerView: "auto",
                freeMode: !0,
                grabCursor: !0,
                navigation: t,
                on: {
                    fromEdge: () => {
                        let e = document.querySelector(".sz-drag-slider-next"),
                            t = document.querySelector(".sz-drag-slider-prev");
                        e.classList.remove("disabled"), t.classList.remove("disabled")
                    },
                    reachBeginning: () => {
                        document.querySelector(".sz-drag-slider-prev").classList.add("disabled")
                    },
                    reachEnd: () => {
                        document.querySelector(".sz-drag-slider-next").classList.add("disabled")
                    }
                }
            })
        },
        zt = (e, t, i = !1) => {
            new Ue(".sz-fixed-slider-container", {
                wrapperClass: "sz-fixed-slider-wrapper",
                slideClass: "sz-fixed-slide-wrapper",
                direction: "horizontal",
                spaceBetween: t,
                keyboard: !0,
                slideToClickedSlide: !0,
                loop: e,
                loopAdditionalSlides: 4,
                pagination: i ? {
                    el: ".swiper-pagination",
                    type: "bullets",
                    clickable: !0,
                    renderBullet: function (e, t) {
                        return '<span class="' + t + '">' + (e + 1) + "</span>"
                    }
                } : {},
                navigation: {
                    nextEl: ".sz-fixed-slider-next",
                    prevEl: ".sz-fixed-slider-prev"
                }
            })
        },
        Mt = () => {
            var e = 0,
                t = !1;
            new Ue(".sz-fixed-slider-container", {
                wrapperClass: "sz-fixed-slider-wrapper",
                slideClass: "sz-fixed-slide-wrapper",
                direction: "horizontal",
                spaceBetween: 160,
                keyboard: !0,
                loop: !0,
                slidesPerView: 1,
                speed: 600,
                navigation: {
                    nextEl: ".sz-fixed-slider-next",
                    prevEl: ".sz-fixed-slider-prev"
                },
                autoplay: {
                    delay: Tt.slideDuration
                },
                pagination: {
                    type: "custom",
                    el: ".sz-custom-slide-pagination",
                    renderCustom: (i, s, n) => {
                        for (; e < n; e++) t || Lt();
                        t = !0, (e => {
                            document.querySelectorAll(".sz-pagination-bar").forEach((t, i) => {
                                i === e - 1 && Tt.prevCurrent != e ? (Tt.prevCurrent = e, t.classList.add("sz-pagination-bar-active"), Tt.isAutoPlaying ? It(t) : t.children[0].style.width = "100%") : (t.classList.remove("sz-pagination-bar-active"), t.children[0].style.width = "0%")
                            })
                        })(s)
                    }
                },
                on: {
                    autoplayStop: function () {
                        Tt.isAutoPlaying = !1
                    }
                }
            })
        },
        Pt = (e, t, i, s) => fetch(t, {
            method: e,
            headers: {
                "Content-Type": i
            },
            body: s
        }),
        kt = e => {
            const t = e.recenttracks.track;
            var i = [];
            t.forEach((e, t) => {
                var s, n, a;
                if (0 === t && !e.hasOwnProperty("@attr")) return s = "No music playing", void(n = "Were having an instrumental break. Ba dum tss!");
                s = e.name, n = e.artist["#text"], e.image.forEach((e, t, i) => {
                    a = t === i.length - 1 && "" != e["#text"] && null != e["#text"] ? e["#text"] : "../../images/about/music/albumcover.png"
                }), i.push([s, n, a])
            }), (e => {
                var t = document.querySelector(".artist"),
                    i = document.querySelector(".tracktitle"),
                    s = document.querySelector(".album.front img"),
                    n = document.querySelector(".album.back img"),
                    a = document.querySelector(".album.front source"),
                    r = document.querySelector(".album.back source");
                t.innerHTML = e[0][1], i.innerHTML = e[0][0], s.src = e[0][2], n.src = e[1][2], r.setAttribute("srcset", e[1][2]), a.setAttribute("srcset", e[0][2])
            })(i)
        },
        Ot = () => {
            Pt("GET", "https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks&user=strakzat&limit=3&api_key=ff90249958cb9b6a973b24765554bdcd&format=json", "application/json", null).then(e => e.json()).then(e => {
                kt(e)
            }).catch(e => {
                console.error(e)
            })
        },
        At = e => {
            const t = e.items,
                i = e.feed.url,
                s = i.substr(0, i.lastIndexOf("/"));
            var n = [];
            t.forEach(e => {
                var t, i, s, a, r;
                t = e.title, i = (e => {
                    var t;
                    return e.filter(e => {
                        "design" !== e && "business" !== e && "process" !== e || (t = e)
                    }), t
                })(e.categories), s = (e => {
                    var t;
                    return t = e.split("-")[0], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][parseInt(e.split("-")[1] - 1)] + " " + e.split("-")[2] + ", " + t
                })(e.pubDate.split(" ")[0]), a = e.author, r = e.link, n.push([t, i, a, s, r])
            }), ((e, t) => {
                var i = document.querySelectorAll(".article-url"),
                    s = document.querySelectorAll(".article-content"),
                    n = document.querySelector(".medium-button"),
                    a = document.querySelector(".article-meta .subtitle.small"),
                    r = document.querySelector(".article-meta .body.small");
                s.forEach((t, s) => {
                    t.children[0].innerHTML = e[s][1], t.children[1].innerHTML = e[s][0], a.innerHTML = e[s][2], r.innerHTML = e[s][3], i[s].href = e[s][4]
                }), n.href = t
            })(n, s)
        },
        Dt = () => {
            Pt("GET", "https://api.rss2json.com/v1/api.json?rss_url=https://blog.strakzat.com/feed", "application/json", null).then(e => e.json()).then(e => {
                At(e)
            }).catch(e => {
                console.log("Network error:", e)
            })
        };
    var _t = de((function (e, t) {
        e.exports = function (e) {
            function t(e, t) {
                return e.hasOwnProperty(t) && (!0 === e[t] || e[t].length)
            }

            function i(e, t, i) {
                e.parentNode ? e.parentNode.parentNode || t.appendChild(e.parentNode) : t.appendChild(e), n.removeClass(e, "excluded"), i || (e.innerHTML = e.textContent)
            }
            var s = function () {};
            s.prototype = {
                on: function (e, t) {
                    this._events = this._events || {}, this._events[e] = this._events[e] || [], this._events[e].push(t)
                },
                off: function (e, t) {
                    this._events = this._events || {}, 0 != e in this._events && this._events[e].splice(this._events[e].indexOf(t), 1)
                },
                emit: function (e) {
                    if (this._events = this._events || {}, 0 != e in this._events)
                        for (var t = 0; t < this._events[e].length; t++) this._events[e][t].apply(this, Array.prototype.slice.call(arguments, 1))
                }
            }, s.mixin = function (e) {
                for (var t = ["on", "off", "emit"], i = 0; i < t.length; i++) "function" == typeof e ? e.prototype[t[i]] = s.prototype[t[i]] : e[t[i]] = s.prototype[t[i]];
                return e
            };
            var n = {
                    extend: function (e, t) {
                        for (var i in t)
                            if (t.hasOwnProperty(i)) {
                                var s = t[i];
                                s && "[object Object]" === Object.prototype.toString.call(s) ? (e[i] = e[i] || {}, n.extend(e[i], s)) : e[i] = s
                            } return e
                    },
                    each: function (e, t, i) {
                        if ("[object Object]" === Object.prototype.toString.call(e))
                            for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && t.call(i, s, e[s], e);
                        else {
                            s = 0;
                            for (var n = e.length; s < n; s++) t.call(i, s, e[s], e)
                        }
                    },
                    createElement: function (e, t) {
                        var i = document,
                            s = i.createElement(e);
                        if (t && "[object Object]" === Object.prototype.toString.call(t))
                            for (var n in t)
                                if (n in s) s[n] = t[n];
                                else if ("html" === n) s.innerHTML = t[n];
                        else if ("text" === n) {
                            var a = i.createTextNode(t[n]);
                            s.appendChild(a)
                        } else s.setAttribute(n, t[n]);
                        return s
                    },
                    hasClass: function (e, t) {
                        if (e) return e.classList ? e.classList.contains(t) : !!e.className && !!e.className.match(new RegExp("(\\s|^)" + t + "(\\s|$)"))
                    },
                    addClass: function (e, t) {
                        n.hasClass(e, t) || (e.classList ? e.classList.add(t) : e.className = e.className.trim() + " " + t)
                    },
                    removeClass: function (e, t) {
                        n.hasClass(e, t) && (e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\s)" + t.split(" ").join("|") + "(\\s|$)", "gi"), " "))
                    },
                    closest: function (e, t) {
                        return e && e !== document.body && (t(e) ? e : n.closest(e.parentNode, t))
                    },
                    isInt: function (e) {
                        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
                    },
                    debounce: function (e, t, i) {
                        var s;
                        return function () {
                            var n = this,
                                a = arguments,
                                r = i && !s;
                            clearTimeout(s), s = setTimeout((function () {
                                s = null, i || e.apply(n, a)
                            }), t), r && e.apply(n, a)
                        }
                    },
                    rect: function (e, t) {
                        var i = window,
                            s = e.getBoundingClientRect(),
                            n = t ? i.pageXOffset : 0;
                        return i = t ? i.pageYOffset : 0, {
                            bottom: s.bottom + i,
                            height: s.height,
                            left: s.left + n,
                            right: s.right + n,
                            top: s.top + i,
                            width: s.width
                        }
                    },
                    includes: function (e, t) {
                        return -1 < e.indexOf(t)
                    },
                    startsWith: function (e, t) {
                        return e.substr(0, t.length) === t
                    },
                    truncate: function (e) {
                        for (; e.firstChild;) e.removeChild(e.firstChild)
                    }
                },
                a = function () {
                    if (this.items.length) {
                        var e = document.createDocumentFragment();
                        if (this.config.pagination) {
                            var t = this.pages.slice(0, this.pageIndex);
                            n.each(t, (function (t, s) {
                                n.each(s, (function (t, s) {
                                    i(s, e, this.customOption)
                                }), this)
                            }), this)
                        } else n.each(this.items, (function (t, s) {
                            i(s, e, this.customOption)
                        }), this);
                        e.childElementCount && (n.removeClass(this.items[this.navIndex], "active"), this.navIndex = (e.querySelector(".selectr-option.selected") || e.querySelector(".selectr-option")).idx, n.addClass(this.items[this.navIndex], "active")), this.tree.appendChild(e)
                    }
                },
                r = function (e) {
                    this.container.contains(e.target) || !this.opened && !n.hasClass(this.container, "notice") || this.close()
                },
                o = function (e, t) {
                    var i = this.customOption ? this.config.renderOption(t || e) : e.textContent;
                    return (i = n.createElement("li", {
                        class: "selectr-option",
                        html: i,
                        role: "treeitem",
                        "aria-selected": !1
                    })).idx = e.idx, this.items.push(i), e.defaultSelected && this.defaultSelected.push(e.idx), e.disabled && (i.disabled = !0, n.addClass(i, "disabled")), i
                },
                l = function () {
                    this.requiresPagination = this.config.pagination && 0 < this.config.pagination, t(this.config, "width") && (n.isInt(this.config.width) ? this.width = this.config.width + "px" : "auto" === this.config.width ? this.width = "100%" : n.includes(this.config.width, "%") && (this.width = this.config.width)), this.container = n.createElement("div", {
                        class: "selectr-container"
                    }), this.config.customClass && n.addClass(this.container, this.config.customClass), this.mobileDevice ? n.addClass(this.container, "selectr-mobile") : n.addClass(this.container, "selectr-desktop"), this.el.tabIndex = -1, this.config.nativeDropdown || this.mobileDevice ? n.addClass(this.el, "selectr-visible") : n.addClass(this.el, "selectr-hidden"), this.selected = n.createElement("div", {
                        class: "selectr-selected",
                        disabled: this.disabled,
                        tabIndex: 0,
                        "aria-expanded": !1
                    }), this.label = n.createElement(this.el.multiple ? "ul" : "span", {
                        class: "selectr-label"
                    });
                    var e = n.createElement("div", {
                        class: "selectr-options-container"
                    });
                    if (this.tree = n.createElement("ul", {
                            class: "selectr-options",
                            role: "tree",
                            "aria-hidden": !0,
                            "aria-expanded": !1
                        }), this.notice = n.createElement("div", {
                            class: "selectr-notice"
                        }), this.el.setAttribute("aria-hidden", !0), this.disabled && (this.el.disabled = !0), this.el.multiple && (n.addClass(this.label, "selectr-tags"), n.addClass(this.container, "multiple"), this.tags = [], this.selectedValues = this.getSelectedProperties("value"), this.selectedIndexes = this.getSelectedProperties("idx")), this.selected.appendChild(this.label), this.config.clearable && (this.selectClear = n.createElement("button", {
                            class: "selectr-clear",
                            type: "button"
                        }), this.container.appendChild(this.selectClear), n.addClass(this.container, "clearable")), this.config.taggable) {
                        var i = n.createElement("li", {
                            class: "input-tag"
                        });
                        this.input = n.createElement("input", {
                            class: "selectr-tag-input",
                            placeholder: this.config.tagPlaceholder,
                            tagIndex: 0,
                            autocomplete: "off",
                            autocorrect: "off",
                            autocapitalize: "off",
                            spellcheck: "false",
                            role: "textbox",
                            type: "search"
                        }), i.appendChild(this.input), this.label.appendChild(i), n.addClass(this.container, "taggable"), this.tagSeperators = [","], this.config.tagSeperators && (this.tagSeperators = this.tagSeperators.concat(this.config.tagSeperators))
                    }
                    this.config.searchable && (this.input = n.createElement("input", {
                        class: "selectr-input",
                        tagIndex: -1,
                        autocomplete: "off",
                        autocorrect: "off",
                        autocapitalize: "off",
                        spellcheck: "false",
                        role: "textbox",
                        type: "search"
                    }), this.inputClear = n.createElement("button", {
                        class: "selectr-input-clear",
                        type: "button"
                    }), this.inputContainer = n.createElement("div", {
                        class: "selectr-input-container"
                    }), this.inputContainer.appendChild(this.input), this.inputContainer.appendChild(this.inputClear), e.appendChild(this.inputContainer)), e.appendChild(this.notice), e.appendChild(this.tree), this.items = [], this.options = [], this.el.options.length && (this.options = [].slice.call(this.el.options));
                    var s = !1,
                        a = 0;
                    if (this.el.children.length && n.each(this.el.children, (function (e, t) {
                            "OPTGROUP" === t.nodeName ? (s = n.createElement("ul", {
                                class: "selectr-optgroup",
                                role: "group",
                                html: "<li class='selectr-optgroup--label'>" + t.label + "</li>"
                            }), n.each(t.children, (function (e, t) {
                                t.idx = a, s.appendChild(o.call(this, t, s)), a++
                            }), this)) : (t.idx = a, o.call(this, t), a++)
                        }), this), this.config.data && Array.isArray(this.config.data)) {
                        this.data = [];
                        var r, l = !1;
                        s = !1, a = 0, n.each(this.config.data, (function (e, i) {
                            t(i, "children") ? (l = n.createElement("optgroup", {
                                label: i.text
                            }), s = n.createElement("ul", {
                                class: "selectr-optgroup",
                                role: "group",
                                html: "<li class='selectr-optgroup--label'>" + i.text + "</li>"
                            }), n.each(i.children, (function (e, i) {
                                (r = new Option(i.text, i.value, !1, i.hasOwnProperty("selected") && !0 === i.selected)).disabled = t(i, "disabled"), this.options.push(r), l.appendChild(r), r.idx = a, s.appendChild(o.call(this, r, i)), this.data[a] = i, a++
                            }), this), this.el.appendChild(l)) : ((r = new Option(i.text, i.value, !1, i.hasOwnProperty("selected") && !0 === i.selected)).disabled = t(i, "disabled"), this.options.push(r), r.idx = a, o.call(this, r, i), this.data[a] = i, a++)
                        }), this)
                    }
                    this.setSelected(!0);
                    for (var d = this.navIndex = 0; d < this.items.length; d++)
                        if (i = this.items[d], !n.hasClass(i, "disabled")) {
                            n.addClass(i, "active"), this.navIndex = d;
                            break
                        } this.requiresPagination && (this.pageIndex = 1, this.paginate()), this.container.appendChild(this.selected), this.container.appendChild(e), this.placeEl = n.createElement("div", {
                        class: "selectr-placeholder"
                    }), this.setPlaceholder(), this.selected.appendChild(this.placeEl), this.disabled && this.disable(), this.el.parentNode.insertBefore(this.container, this.el), this.container.appendChild(this.el)
                },
                d = function (e) {
                    if (e = e || window.event, this.items.length && this.opened && n.includes([13, 38, 40], e.which)) {
                        if (e.preventDefault(), 13 === e.which) return !(this.noResults || this.config.taggable && 0 < this.input.value.length) && this.change(this.navIndex);
                        var t = this.items[this.navIndex],
                            i = this.navIndex;
                        switch (e.which) {
                            case 38:
                                var s = 0;
                                0 < this.navIndex && this.navIndex--;
                                break;
                            case 40:
                                s = 1, this.navIndex < this.items.length - 1 && this.navIndex++
                        }
                        for (this.navigating = !0; n.hasClass(this.items[this.navIndex], "disabled") || n.hasClass(this.items[this.navIndex], "excluded");) {
                            if (!(0 < this.navIndex && this.navIndex < this.items.length - 1)) {
                                this.navIndex = i;
                                break
                            }
                            if (s ? this.navIndex++ : this.navIndex--, this.searching) {
                                if (this.navIndex > this.tree.lastElementChild.idx) {
                                    this.navIndex = this.tree.lastElementChild.idx;
                                    break
                                }
                                if (this.navIndex < this.tree.firstElementChild.idx) {
                                    this.navIndex = this.tree.firstElementChild.idx;
                                    break
                                }
                            }
                        }
                        e = n.rect(this.items[this.navIndex]), s ? (0 === this.navIndex ? this.tree.scrollTop = 0 : e.top + e.height > this.optsRect.top + this.optsRect.height && (this.tree.scrollTop += e.top + e.height - (this.optsRect.top + this.optsRect.height)), this.navIndex === this.tree.childElementCount - 1 && this.requiresPagination && u.call(this)) : 0 === this.navIndex ? this.tree.scrollTop = 0 : 0 > e.top - this.optsRect.top && (this.tree.scrollTop += e.top - this.optsRect.top), t && n.removeClass(t, "active"), n.addClass(this.items[this.navIndex], "active")
                    } else this.navigating = !1
                },
                c = function (e) {
                    var t = this,
                        i = document.createDocumentFragment(),
                        s = this.options[e.idx],
                        a = this.data ? this.data[e.idx] : s;
                    a = this.customSelected ? this.config.renderSelection(a) : s.textContent, a = n.createElement("li", {
                        class: "selectr-tag",
                        html: a
                    });
                    var r = n.createElement("button", {
                        class: "selectr-tag-remove",
                        type: "button"
                    });
                    if (a.appendChild(r), a.idx = e.idx, a.tag = s.value, this.tags.push(a), this.config.sortSelected) {
                        e = this.tags.slice();
                        var o = function (e, t) {
                            e.replace(/(\d+)|(\D+)/g, (function (e, i, s) {
                                t.push([i || 1 / 0, s || ""])
                            }))
                        };
                        e.sort((function (e, i) {
                            var s = [],
                                n = [];
                            if (!0 === t.config.sortSelected) var a = e.tag,
                                r = i.tag;
                            else "text" === t.config.sortSelected && (a = e.textContent, r = i.textContent);
                            for (o(a, s), o(r, n); s.length && n.length;)
                                if (a = s.shift(), r = n.shift(), a = a[0] - r[0] || a[1].localeCompare(r[1])) return a;
                            return s.length - n.length
                        })), n.each(e, (function (e, t) {
                            i.appendChild(t)
                        })), this.label.innerHTML = ""
                    } else i.appendChild(a);
                    this.config.taggable ? this.label.insertBefore(i, this.input.parentNode) : this.label.appendChild(i)
                },
                h = function (e) {
                    var t = !1;
                    n.each(this.tags, (function (i, s) {
                        s.idx === e.idx && (t = s)
                    }), this), t && (this.label.removeChild(t), this.tags.splice(this.tags.indexOf(t), 1))
                },
                u = function () {
                    var e = this.tree;
                    if (e.scrollTop >= e.scrollHeight - e.offsetHeight && this.pageIndex < this.pages.length) {
                        var t = document.createDocumentFragment();
                        n.each(this.pages[this.pageIndex], (function (e, s) {
                            i(s, t, this.customOption)
                        }), this), e.appendChild(t), this.pageIndex++, this.emit("selectr.paginate", {
                            items: this.items.length,
                            total: this.data.length,
                            page: this.pageIndex,
                            pages: this.pages.length
                        })
                    }
                },
                p = function () {
                    (this.config.searchable || this.config.taggable) && (this.input.value = null, this.searching = !1, this.config.searchable && n.removeClass(this.inputContainer, "active"), n.hasClass(this.container, "notice") && (n.removeClass(this.container, "notice"), n.addClass(this.container, "open"), this.input.focus()), n.each(this.items, (function (e, t) {
                        n.removeClass(t, "excluded"), this.customOption || (t.innerHTML = t.textContent)
                    }), this))
                };
            return (e = function (e, t) {
                if (this.defaultConfig = {
                        defaultSelected: !0,
                        width: "auto",
                        disabled: !1,
                        searchable: !0,
                        clearable: !1,
                        sortSelected: !1,
                        allowDeselect: !1,
                        closeOnScroll: !1,
                        nativeDropdown: !1,
                        nativeKeyboard: !1,
                        placeholder: "Select an option...",
                        taggable: !1,
                        tagPlaceholder: "Enter a tag...",
                        messages: {
                            noResults: "No results.",
                            noOptions: "No options available.",
                            maxSelections: "A maximum of {max} items can be selected.",
                            tagDuplicate: "That tag is already in use."
                        }
                    }, !e) throw Error("You must supply either a HTMLSelectElement or a CSS3 selector string.");
                if (this.el = e, "string" == typeof e && (this.el = document.querySelector(e)), null === this.el) throw Error("The element you passed to Selectr can not be found.");
                if ("select" !== this.el.nodeName.toLowerCase()) throw Error("The element you passed to Selectr is not a HTMLSelectElement.");
                this.render(t)
            }).prototype.render = function (e) {
                if (!this.rendered) {
                    this.el.selectr = this, this.config = n.extend(this.defaultConfig, e), this.originalType = this.el.type, this.originalIndex = this.el.tabIndex, this.defaultSelected = [], this.originalOptionCount = this.el.options.length, (this.config.multiple || this.config.taggable) && (this.el.multiple = !0), this.disabled = t(this.config, "disabled"), this.opened = !1, this.config.taggable && (this.config.searchable = !1), this.mobileDevice = this.navigating = !1, /Android|webOS|iPhone|iPad|BlackBerry|Windows Phone|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent) && (this.mobileDevice = !0), this.customOption = this.config.hasOwnProperty("renderOption") && "function" == typeof this.config.renderOption, this.customSelected = this.config.hasOwnProperty("renderSelection") && "function" == typeof this.config.renderSelection, this.supportsEventPassiveOption = this.detectEventPassiveOption(), s.mixin(this), l.call(this), this.bindEvents(), this.update(), this.optsRect = n.rect(this.tree), this.rendered = !0, this.el.multiple || (this.el.selectedIndex = this.selectedIndex);
                    var i = this;
                    setTimeout((function () {
                        i.emit("selectr.init")
                    }), 20)
                }
            }, e.prototype.getSelected = function () {
                return this.el.querySelectorAll("option:checked")
            }, e.prototype.getSelectedProperties = function (e) {
                var t = this.getSelected();
                return [].slice.call(t).map((function (t) {
                    return t[e]
                })).filter((function (e) {
                    return null != e
                }))
            }, e.prototype.detectEventPassiveOption = function () {
                var e = !1;
                try {
                    var t = Object.defineProperty({}, "passive", {
                        get: function () {
                            e = !0
                        }
                    });
                    window.addEventListener("test", null, t)
                } catch (e) {}
                return e
            }, e.prototype.bindEvents = function () {
                var e = this;
                if (this.events = {}, this.events.dismiss = r.bind(this), this.events.navigate = d.bind(this), this.events.reset = this.reset.bind(this), (this.config.nativeDropdown || this.mobileDevice) && (this.container.addEventListener("touchstart", (function (t) {
                        t.changedTouches[0].target === e.el && e.toggle()
                    }), !!this.supportsEventPassiveOption && {
                        passive: !0
                    }), this.container.addEventListener("click", (function (t) {
                        t.target === e.el && e.toggle()
                    })), this.el.addEventListener("change", (function (t) {
                        e.el.multiple ? (t = e.getSelectedProperties("idx"), t = function (e, t) {
                            for (var i, s = [], n = e.slice(0), a = 0; a < t.length; a++) - 1 < (i = n.indexOf(t[a])) ? n.splice(i, 1) : s.push(t[a]);
                            return [s, n]
                        }(e.selectedIndexes, t), n.each(t[0], (function (t, i) {
                            e.select(i)
                        }), e), n.each(t[1], (function (t, i) {
                            e.deselect(i)
                        }), e)) : -1 < e.el.selectedIndex && e.select(e.el.selectedIndex)
                    }))), this.container.addEventListener("keydown", (function (t) {
                        "Escape" === t.key && e.close(), "Enter" === t.key && e.selected === document.activeElement && void 0 !== e.el.form.submit && e.el.form.submit(), " " !== t.key && "ArrowUp" !== t.key && "ArrowDown" !== t.key || e.selected !== document.activeElement || (setTimeout((function () {
                            e.toggle()
                        }), 200), e.config.nativeDropdown && setTimeout((function () {
                            e.el.focus()
                        }), 200))
                    })), this.selected.addEventListener("click", (function (t) {
                        e.disabled || e.toggle(), t.preventDefault()
                    })), this.config.nativeKeyboard) {
                    var t = "";
                    this.selected.addEventListener("keydown", (function (i) {
                        if (!(e.disabled || e.selected !== document.activeElement || i.altKey || i.ctrlKey || i.metaKey))
                            if (" " === i.key || !e.opened && -1 < ["Enter", "ArrowUp", "ArrowDown"].indexOf(i.key)) e.toggle(), i.preventDefault(), i.stopPropagation();
                            else if (2 >= i.key.length && String[String.fromCodePoint ? "fromCodePoint" : "fromCharCode"](i.key[String.codePointAt ? "codePointAt" : "charCodeAt"](0)) === i.key) {
                            if (e.config.multiple) e.open(), e.config.searchable && (e.input.value = i.key, e.input.focus(), e.search(null, !0));
                            else {
                                t += i.key;
                                var s = e.search(t, !0);
                                s && s.length && (e.clear(), e.setValue(s[0].value)), setTimeout((function () {
                                    t = ""
                                }), 1e3)
                            }
                            i.preventDefault(), i.stopPropagation()
                        }
                    })), this.container.addEventListener("keyup", (function (t) {
                        e.opened && "Escape" === t.key && (e.close(), t.stopPropagation(), e.selected.focus())
                    }))
                }
                this.label.addEventListener("click", (function (t) {
                    n.hasClass(t.target, "selectr-tag-remove") && e.deselect(t.target.parentNode.idx)
                })), this.selectClear && this.selectClear.addEventListener("click", this.clear.bind(this)), this.tree.addEventListener("mousedown", (function (e) {
                    e.preventDefault()
                })), this.tree.addEventListener("click", (function (t) {
                    var i = n.closest(t.target, (function (e) {
                        return e && n.hasClass(e, "selectr-option")
                    }));
                    i && !n.hasClass(i, "disabled") && (n.hasClass(i, "selected") ? (e.el.multiple || !e.el.multiple && e.config.allowDeselect) && e.deselect(i.idx) : e.select(i.idx), e.opened && !e.el.multiple && e.close()), t.preventDefault(), t.stopPropagation()
                })), this.tree.addEventListener("mouseover", (function (t) {
                    n.hasClass(t.target, "selectr-option") && !n.hasClass(t.target, "disabled") && (n.removeClass(e.items[e.navIndex], "active"), n.addClass(t.target, "active"), e.navIndex = [].slice.call(e.items).indexOf(t.target))
                })), this.config.searchable && (this.input.addEventListener("focus", (function (t) {
                    e.searching = !0
                })), this.input.addEventListener("blur", (function (t) {
                    e.searching = !1
                })), this.input.addEventListener("keyup", (function (t) {
                    e.search(), e.config.taggable || (this.value.length ? n.addClass(this.parentNode, "active") : n.removeClass(this.parentNode, "active"))
                })), this.inputClear.addEventListener("click", (function (t) {
                    e.input.value = null, p.call(e), e.tree.childElementCount || a.call(e)
                }))), this.config.taggable && this.input.addEventListener("keyup", (function (t) {
                    if (e.search(), e.config.taggable && this.value.length) {
                        var i = this.value.trim();
                        (13 === t.which || n.includes(e.tagSeperators, t.key)) && (n.each(e.tagSeperators, (function (e, t) {
                            i = i.replace(t, "")
                        })), e.add({
                            value: i,
                            text: i,
                            selected: !0
                        }, !0) ? (e.close(), p.call(e)) : (this.value = "", e.setMessage(e.config.messages.tagDuplicate)))
                    }
                })), this.update = n.debounce((function () {
                    e.opened && e.config.closeOnScroll && e.close(), e.width && (e.container.style.width = e.width), e.invert()
                }), 50), this.requiresPagination && (this.paginateItems = n.debounce((function () {
                    u.call(this)
                }), 50), this.tree.addEventListener("scroll", this.paginateItems.bind(this))), document.addEventListener("click", this.events.dismiss), window.addEventListener("keydown", this.events.navigate), window.addEventListener("resize", this.update), window.addEventListener("scroll", this.update), this.on("selectr.destroy", (function () {
                    document.removeEventListener("click", this.events.dismiss), window.removeEventListener("keydown", this.events.navigate), window.removeEventListener("resize", this.update), window.removeEventListener("scroll", this.update)
                })), this.el.form && (this.el.form.addEventListener("reset", this.events.reset), this.on("selectr.destroy", (function () {
                    this.el.form.removeEventListener("reset", this.events.reset)
                })))
            }, e.prototype.setSelected = function (e) {
                if (this.config.data || this.el.multiple || !this.el.options.length || (0 !== this.el.selectedIndex || this.el.options[0].defaultSelected || this.config.defaultSelected || (this.el.selectedIndex = -1), this.selectedIndex = this.el.selectedIndex, -1 < this.selectedIndex && this.select(this.selectedIndex)), this.config.multiple && "select-one" === this.originalType && !this.config.data && this.el.options[0].selected && !this.el.options[0].defaultSelected && (this.el.options[0].selected = !1), n.each(this.options, (function (e, t) {
                        t.selected && t.defaultSelected && this.select(t.idx)
                    }), this), this.config.selectedValue && this.setValue(this.config.selectedValue), this.config.data) {
                    !this.el.multiple && this.config.defaultSelected && 0 > this.el.selectedIndex && this.select(0);
                    var i = 0;
                    n.each(this.config.data, (function (e, s) {
                        t(s, "children") ? n.each(s.children, (function (e, t) {
                            t.hasOwnProperty("selected") && !0 === t.selected && this.select(i), i++
                        }), this) : (s.hasOwnProperty("selected") && !0 === s.selected && this.select(i), i++)
                    }), this)
                }
            }, e.prototype.destroy = function () {
                this.rendered && (this.emit("selectr.destroy"), "select-one" === this.originalType && (this.el.multiple = !1), this.config.data && (this.el.innerHTML = ""), n.removeClass(this.el, "selectr-hidden"), this.container.parentNode.replaceChild(this.el, this.container), this.rendered = !1, delete this.el.selectr)
            }, e.prototype.change = function (e) {
                var t = this.items[e],
                    i = this.options[e];
                i.disabled || (i.selected && n.hasClass(t, "selected") ? this.deselect(e) : this.select(e), this.opened && !this.el.multiple && this.close())
            }, e.prototype.select = function (e) {
                var t = this.items[e],
                    i = [].slice.call(this.el.options),
                    s = this.options[e];
                if (this.el.multiple) {
                    if (n.includes(this.selectedIndexes, e)) return !1;
                    if (this.config.maxSelections && this.tags.length === this.config.maxSelections) return this.setMessage(this.config.messages.maxSelections.replace("{max}", this.config.maxSelections), !0), !1;
                    this.selectedValues.push(s.value), this.selectedIndexes.push(e), c.call(this, t)
                } else {
                    var a = this.data ? this.data[e] : s;
                    this.label.innerHTML = this.customSelected ? this.config.renderSelection(a) : s.textContent, this.selectedValue = s.value, this.selectedIndex = e, n.each(this.options, (function (t, i) {
                        var s = this.items[t];
                        t !== e && (s && n.removeClass(s, "selected"), i.selected = !1, i.removeAttribute("selected"))
                    }), this)
                }
                n.includes(i, s) || this.el.add(s), t.setAttribute("aria-selected", !0), n.addClass(t, "selected"), n.addClass(this.container, "has-selected"), s.selected = !0, s.setAttribute("selected", ""), this.emit("selectr.change", s), this.emit("selectr.select", s), "createEvent" in document ? ((t = document.createEvent("HTMLEvents")).initEvent("change", !0, !0), this.el.dispatchEvent(t)) : this.el.fireEvent("onchange")
            }, e.prototype.deselect = function (e, t) {
                var i = this.items[e],
                    s = this.options[e];
                if (this.el.multiple) {
                    var a = this.selectedIndexes.indexOf(e);
                    this.selectedIndexes.splice(a, 1), a = this.selectedValues.indexOf(s.value), this.selectedValues.splice(a, 1), h.call(this, i), this.tags.length || n.removeClass(this.container, "has-selected")
                } else {
                    if (!t && !this.config.clearable && !this.config.allowDeselect) return !1;
                    this.label.innerHTML = "", this.selectedValue = null, this.el.selectedIndex = this.selectedIndex = -1, n.removeClass(this.container, "has-selected")
                }
                this.items[e].setAttribute("aria-selected", !1), n.removeClass(this.items[e], "selected"), s.selected = !1, s.removeAttribute("selected"), this.emit("selectr.change", null), this.emit("selectr.deselect", s), "createEvent" in document ? ((i = document.createEvent("HTMLEvents")).initEvent("change", !0, !0), this.el.dispatchEvent(i)) : this.el.fireEvent("onchange")
            }, e.prototype.setValue = function (e) {
                var t = Array.isArray(e);
                if (t || (e = e.toString().trim()), !this.el.multiple && t) return !1;
                n.each(this.options, (function (i, s) {
                    (t && -1 < e.indexOf(s.value) || s.value === e) && this.change(s.idx)
                }), this)
            }, e.prototype.getValue = function (e, t) {
                if (this.el.multiple)
                    if (e) {
                        if (this.selectedIndexes.length) {
                            var i = {
                                values: []
                            };
                            n.each(this.selectedIndexes, (function (e, t) {
                                var s = this.options[t];
                                i.values[e] = {
                                    value: s.value,
                                    text: s.textContent
                                }
                            }), this)
                        }
                    } else i = this.selectedValues.slice();
                else if (e) {
                    var s = this.options[this.selectedIndex];
                    i = {
                        value: s.value,
                        text: s.textContent
                    }
                } else i = this.selectedValue;
                return e && t && (i = JSON.stringify(i)), i
            }, e.prototype.add = function (e, t) {
                if (e) {
                    if (this.data = this.data || [], this.items = this.items || [], this.options = this.options || [], Array.isArray(e)) n.each(e, (function (e, i) {
                        this.add(i, t)
                    }), this);
                    else if ("[object Object]" === Object.prototype.toString.call(e)) {
                        if (t) {
                            var i = !1;
                            if (n.each(this.options, (function (t, s) {
                                    s.value.toLowerCase() === e.value.toLowerCase() && (i = !0)
                                })), i) return !1
                        }
                        var s = n.createElement("option", e);
                        return this.data.push(e), this.options.push(s), s.idx = 0 < this.options.length ? this.options.length - 1 : 0, o.call(this, s), e.selected && this.select(s.idx), this.setPlaceholder(), s
                    }
                    return this.config.pagination && this.paginate(), !0
                }
            }, e.prototype.remove = function (e) {
                var t, i = [];
                Array.isArray(e) ? n.each(e, (function (e, t) {
                    n.isInt(t) ? i.push(this.getOptionByIndex(t)) : "string" == typeof t && i.push(this.getOptionByValue(t))
                }), this) : n.isInt(e) ? i.push(this.getOptionByIndex(e)) : "string" == typeof e && i.push(this.getOptionByValue(e)), i.length && (n.each(i, (function (e, i) {
                    t = i.idx, this.el.remove(i), this.options.splice(t, 1);
                    var s = this.items[t].parentNode;
                    s && s.removeChild(this.items[t]), this.items.splice(t, 1), n.each(this.options, (function (e, t) {
                        t.idx = e, this.items[e].idx = e
                    }), this)
                }), this), this.setPlaceholder(), this.config.pagination && this.paginate())
            }, e.prototype.removeAll = function () {
                this.clear(!0), n.each(this.el.options, (function (e, t) {
                    this.el.remove(t)
                }), this), n.truncate(this.tree), this.items = [], this.options = [], this.data = [], this.navIndex = 0, this.requiresPagination && (this.requiresPagination = !1, this.pageIndex = 1, this.pages = []), this.setPlaceholder()
            }, e.prototype.search = function (e, t) {
                if (!this.navigating) {
                    var s = !1;
                    e || (e = this.input.value, s = !0, this.removeMessage(), n.truncate(this.tree));
                    var r = [],
                        o = document.createDocumentFragment();
                    if (0 < (e = e.trim().toLowerCase()).length) {
                        var l = t ? n.startsWith : n.includes;
                        if (n.each(this.options, (function (t, a) {
                                var d = this.items[a.idx];
                                if (l(a.textContent.trim().toLowerCase(), e) && !a.disabled) {
                                    if (r.push({
                                            text: a.textContent,
                                            value: a.value
                                        }), s && (i(d, o, this.customOption), n.removeClass(d, "excluded"), !this.customOption)) {
                                        var c = !!(c = new RegExp(e, "i").exec(a.textContent)) && a.textContent.replace(c[0], "<span class='selectr-match'>" + c[0] + "</span>");
                                        d.innerHTML = c
                                    }
                                } else s && n.addClass(d, "excluded")
                            }), this), s) {
                            if (o.childElementCount) {
                                var d = this.items[this.navIndex],
                                    c = o.querySelector(".selectr-option:not(.excluded)");
                                this.noResults = !1, n.removeClass(d, "active"), this.navIndex = c.idx, n.addClass(c, "active")
                            } else this.config.taggable || (this.noResults = !0, this.setMessage(this.config.messages.noResults));
                            this.tree.appendChild(o)
                        }
                    } else a.call(this);
                    return r
                }
            }, e.prototype.toggle = function () {
                this.disabled || (this.opened ? this.close() : this.open())
            }, e.prototype.open = function () {
                var e = this;
                if (!this.options.length) return !1;
                this.opened || this.emit("selectr.open"), this.opened = !0, this.mobileDevice || this.config.nativeDropdown ? (n.addClass(this.container, "native-open"), this.config.data && n.each(this.options, (function (e, t) {
                    this.el.add(t)
                }), this)) : (n.addClass(this.container, "open"), a.call(this), this.invert(), this.tree.scrollTop = 0, n.removeClass(this.container, "notice"), this.selected.setAttribute("aria-expanded", !0), this.tree.setAttribute("aria-hidden", !1), this.tree.setAttribute("aria-expanded", !0), this.config.searchable && !this.config.taggable && setTimeout((function () {
                    e.input.focus(), e.input.tabIndex = 0
                }), 10))
            }, e.prototype.close = function () {
                if (this.opened && this.emit("selectr.close"), this.navigating = this.opened = !1, this.mobileDevice || this.config.nativeDropdown) n.removeClass(this.container, "native-open");
                else {
                    var e = n.hasClass(this.container, "notice");
                    this.config.searchable && !e && (this.input.blur(), this.input.tabIndex = -1, this.searching = !1), e && (n.removeClass(this.container, "notice"), this.notice.textContent = ""), n.removeClass(this.container, "open"), n.removeClass(this.container, "native-open"), this.selected.setAttribute("aria-expanded", !1), this.tree.setAttribute("aria-hidden", !0), this.tree.setAttribute("aria-expanded", !1), n.truncate(this.tree), p.call(this), this.selected.focus()
                }
            }, e.prototype.enable = function () {
                this.disabled = !1, this.el.disabled = !1, this.selected.tabIndex = this.originalIndex, this.el.multiple && n.each(this.tags, (function (e, t) {
                    t.lastElementChild.tabIndex = 0
                })), n.removeClass(this.container, "selectr-disabled")
            }, e.prototype.disable = function (e) {
                e || (this.el.disabled = !0), this.selected.tabIndex = -1, this.el.multiple && n.each(this.tags, (function (e, t) {
                    t.lastElementChild.tabIndex = -1
                })), this.disabled = !0, n.addClass(this.container, "selectr-disabled")
            }, e.prototype.reset = function () {
                this.disabled || (this.clear(), this.setSelected(!0), n.each(this.defaultSelected, (function (e, t) {
                    this.select(t)
                }), this), this.emit("selectr.reset"))
            }, e.prototype.clear = function (e) {
                this.el.multiple ? this.selectedIndexes.length && (e = this.selectedIndexes.slice(), n.each(e, (function (e, t) {
                    this.deselect(t)
                }), this)) : -1 < this.selectedIndex && this.deselect(this.selectedIndex, e), this.emit("selectr.clear")
            }, e.prototype.serialise = function (e) {
                var t = [];
                return n.each(this.options, (function (e, i) {
                    var s = {
                        value: i.value,
                        text: i.textContent
                    };
                    i.selected && (s.selected = !0), i.disabled && (s.disabled = !0), t[e] = s
                })), e ? JSON.stringify(t) : t
            }, e.prototype.serialize = function (e) {
                return this.serialise(e)
            }, e.prototype.setPlaceholder = function (e) {
                e = e || this.config.placeholder || this.el.getAttribute("placeholder"), this.options.length || (e = this.config.messages.noOptions), this.placeEl.innerHTML = e
            }, e.prototype.paginate = function () {
                if (this.items.length) {
                    var e = this;
                    return this.pages = this.items.map((function (t, i) {
                        return 0 == i % e.config.pagination ? e.items.slice(i, i + e.config.pagination) : null
                    })).filter((function (e) {
                        return e
                    }))
                }
            }, e.prototype.setMessage = function (e, t) {
                t && this.close(), n.addClass(this.container, "notice"), this.notice.textContent = e
            }, e.prototype.removeMessage = function () {
                n.removeClass(this.container, "notice"), this.notice.innerHTML = ""
            }, e.prototype.invert = function () {
                var e = n.rect(this.selected);
                e.top + e.height + this.tree.parentNode.offsetHeight > window.innerHeight ? (n.addClass(this.container, "inverted"), this.isInverted = !0) : (n.removeClass(this.container, "inverted"), this.isInverted = !1), this.optsRect = n.rect(this.tree)
            }, e.prototype.getOptionByIndex = function (e) {
                return this.options[e]
            }, e.prototype.getOptionByValue = function (e) {
                for (var t = !1, i = 0, s = this.options.length; i < s; i++)
                    if (this.options[i].value.trim() === e.toString().trim()) {
                        t = this.options[i];
                        break
                    } return t
            }, e
        }("Selectr")
    }));
    const Ht = () => {
            Gt(), qt(), new _t("#interest", {
                searchable: !1,
                customClass: "fs-dropdown"
            })
        },
        Bt = () => {
            Gt();
            const e = document.getElementById("sz-send-sprint-form"),
                t = document.querySelector(".close-message-sent");
            e.addEventListener("click", Vt), t.addEventListener("click", Nt)
        },
        qt = () => {
            const e = document.querySelectorAll(".sz-input"),
                t = document.getElementById("sz-send-message"),
                i = document.querySelector(".close-message-sent");
            e.forEach((e, t, i) => {
                e.addEventListener("input", Wt), e.addEventListener("focus", Ft)
            }), t.addEventListener("click", Yt), i.addEventListener("click", Nt)
        },
        Nt = () => {
            const e = document.querySelector(".message-sent");
            e.classList.add("moved-out"), e.classList.remove("is-visible")
        },
        Rt = e => {
            e ? (document.getElementById("name").value = "", document.getElementById("email").value = "", document.getElementById("telephone").value = "", document.getElementById("message").value = "") : document.getElementById("email").value = ""
        },
        Wt = e => {
            const t = e.currentTarget,
                i = t.nextElementSibling;
            t.value ? i.classList.add("active") : i.classList.remove("active")
        },
        Ft = e => {
            const t = e.currentTarget.parentElement.querySelector(".sz-input-error-tooltip");
            null !== t && t.remove()
        },
        Gt = () => {
            var e = document.getElementById("sz-form-token");
            Pt("GET", "server/forms/CreateToken.php", "text/plain", null).then(e => e.text()).then(t => {
                e.value = t
            }).catch(e => {
                console.log("Token error:", e)
            })
        },
        Yt = e => {
            e.preventDefault(), Qt();
            var t = JSON.stringify({
                token: document.getElementById("sz-form-token").value,
                interest: document.getElementById("interest").value,
                name: document.getElementById("name").value,
                email: document.getElementById("email").value,
                telephone: document.getElementById("telephone").value,
                message: document.getElementById("message").value
            });
            Pt("POST", "server/forms/ContactForm.php", "application/json", t).then(e => e.json()).then(e => {
                Xt(e)
            }).catch(e => {
                console.log("Mail error:", e)
            })
        },
        Vt = e => {
            e.preventDefault();
            var t = JSON.stringify({
                email: document.getElementById("email").value
            });
            Pt("POST", "server/forms/SprintForm.php", "application/json", t).then(e => e.json()).then(e => {
                jt(e)
            })
        },
        jt = e => {
            const t = e.error,
                i = document.querySelector(".message-sent"),
                s = document.querySelector(".message-sent p");
            t ? s.innerHTML = `${e.status}` : (s.innerHTML = " Your sprint inquiry was successfully sent!", Rt()), i.classList.remove("moved-out"), i.classList.add("is-visible")
        },
        Xt = e => {
            const t = e.error,
                i = e.field,
                s = e.status;
            if (t) "" === i ? console.log("email error") : Ut(i, s);
            else {
                const e = document.querySelector(".message-sent");
                e.classList.remove("moved-out"), e.classList.add("is-visible"), Rt(!0)
            }
        },
        Ut = (e, t) => {
            const i = document.getElementById(e),
                s = Kt();
            s.children[0].innerHTML = t, i.parentElement.appendChild(s), s.classList.add("active")
        },
        Kt = () => {
            const e = document.createElement("div"),
                t = document.createElement("small"),
                i = document.createElement("span");
            return e.setAttribute("class", "sz-input-error-tooltip darkBlue"), i.setAttribute("class", "sz-input-error-tip"), e.appendChild(t), e.appendChild(i), e
        },
        Qt = () => {
            document.querySelectorAll(".sz-input-error-tooltip").forEach((e, t, i) => {
                e.remove()
            })
        };
    class Jt {
        constructor(e) {
            const t = [];
            return e.next.container.querySelectorAll("img").forEach(e => {
                t.push(new Promise(t => {
                    e.complete ? t() : e.addEventListener("load", e => {
                        t()
                    })
                }))
            }), t
        }
    }
    const Zt = (e, t) => {
            return {
                from: {
                    namespace: t
                },
                to: {
                    namespace: e
                },
                leave: e => Promise.all([ei(e)]),
                afterLeave: e => Promise.all(new Jt(e)),
                afterEnter: e => ti(e)
            }
        },
        ei = e => {
            var t, i = 0,
                s = 0;
            const n = e.current.container;
            switch (e.next.namespace) {
                case "casestudy-auto":
                    t = n.querySelector(".casestudy-card.auto"), s = 7;
                    break;
                case "casestudy-tempoteam":
                    t = n.querySelector(".casestudy-card.tempoteam"), s = 11;
                    break;
                case "casestudy-beatt":
                    t = n.querySelector(".casestudy-card.beatt"), s = 7;
                    break;
                case "casestudy-camptoo":
                    t = n.querySelector(".casestudy-card.camptoo"), s = 7;
                    break;
                case "casestudy-vvv-breda":
                    t = n.querySelector(".casestudy-card.vvv-breda"), s = 7;
                    break;
                case "casestudy-dekweker":
                    t = n.querySelector(".casestudy-card.dekweker"), s = 8
            }
            if (!t) {
                t = n.querySelector(".generic-casestudy-card-overlay");
                const i = e.next.url.path.substr(1);
                return t.classList.add(i), t.classList.remove("scale-down"), t.classList.remove("scaled"), t.classList.add("scale-up"), new Promise(e => {
                    setTimeout(e, 1e3)
                })
            }
            return t.classList.remove("scale-down"), t.parentNode.classList.add("disabled"), new Promise(e => {
                t.classList.add("scale-up"), t.addEventListener("transitionend", () => {
                    i === s ? e() : i++
                })
            })
        },
        ti = e => {
            const t = document.querySelectorAll(".header-reveal"),
                i = e.next.container.querySelector(".casestudy-overlay");
            i.offsetWidth, setTimeout(() => {
                i.classList.add("fade-out")
            }, 50), setTimeout(() => {
                t.forEach(e => {
                    e.classList.add("animate-in")
                })
            }, 250)
        },
        ii = (e, t) => {
            return {
                from: {
                    namespace: e
                },
                to: {
                    namespace: t
                },
                leave: e => Promise.all([si(e)]),
                beforeEnter: e => Promise.all([ni(e)]),
                after: e => ai(e)
            }
        },
        si = e => {
            const t = e.current.container.querySelector(".casestudy-overlay");
            return new Promise(e => {
                t.classList.add("fade-in"), t.addEventListener("transitionend", () => {
                    e()
                })
            })
        },
        ni = e => {
            var t;
            const i = e.next.container;
            switch (e.current.namespace) {
                case "casestudy-auto":
                    t = i.querySelector(".casestudy-card.auto");
                    break;
                case "casestudy-tempoteam":
                    t = i.querySelector(".casestudy-card.tempoteam");
                    break;
                case "casestudy-beatt":
                    t = i.querySelector(".casestudy-card.beatt");
                    break;
                case "casestudy-camptoo":
                    t = i.querySelector(".casestudy-card.camptoo");
                    break;
                case "casestudy-vvv-breda":
                    t = i.querySelector(".casestudy-card.vvv-breda");
                    break;
                case "casestudy-dekweker":
                    t = i.querySelector(".casestudy-card.dekweker")
            }
            if (!t) {
                t = i.querySelector(".generic-casestudy-card-overlay");
                const s = e.current.url.path.substr(1);
                t.classList.add(s)
            }
            return t.classList.contains("scale-up") && t.classList.remove("scale-up"), new Promise(e => {
                t.classList.add("scaled"), e()
            })
        },
        ai = e => {
            var t, i = 0,
                s = 0;
            const n = e.next.container;
            switch (e.current.namespace) {
                case "casestudy-auto":
                    t = n.querySelector(".casestudy-card.auto"), i = 7;
                    break;
                case "casestudy-tempoteam":
                    t = n.querySelector(".casestudy-card.tempoteam"), i = 9;
                    break;
                case "casestudy-beatt":
                    t = n.querySelector(".casestudy-card.beatt"), i = 7;
                    break;
                case "casestudy-vvv-breda":
                    t = n.querySelector(".casestudy-card.vvv-breda"), i = 7;
                    break;
                case "casestudy-dekweker":
                    t = n.querySelector(".casestudy-card.dekweker"), i = 8;
                    break;
                case "casestudy-camptoo":
                    i = 7, t = n.querySelector(".casestudy-card.camptoo")
            }
            if (!t) {
                t = n.querySelector(".generic-casestudy-card-overlay");
                const i = e.current.url.path.substr(1);
                return t.classList.add(i), void t.classList.add("scale-down")
            }
            setTimeout(() => {
                ri(t)
            }, 50), t.parentNode.classList.add("disabled"), t.offsetWidth, t.classList.add("scale-down"), t.addEventListener("transitionend", () => {
                s === i ? (t.parentNode.classList.remove("disabled"), t.classList.remove("scaled"), t.classList.remove("scale-down")) : s++
            })
        },
        ri = e => {
            const t = oi(e),
                i = e.offsetHeight,
                s = window.innerHeight;
            document.body.scrollTop = document.documentElement.scrollTop = t + (i - s) / 2
        },
        oi = e => {
            for (var t = 0; null != e; t += e.offsetTop, e = e.offsetParent);
            return t
        },
        li = e => {
            return {
                from: {
                    namespace: e
                },
                to: {
                    namespace: e
                },
                beforeEnter: e => di(e),
                afterLeave: e => Promise.all(new Jt(e)),
                afterEnter: () => ci()
            }
        },
        di = e => {
            (null != e ? e.next.container : document).querySelector(".casestudy-overlay").classList.add("fade-out")
        },
        ci = () => {
            setTimeout(() => {
                document.querySelectorAll(".header-reveal").forEach(e => {
                    e.classList.add("animate-in")
                })
            }, 50)
        },
        hi = e => {
            return {
                from: {
                    namespace: e
                },
                beforeLeave: e => {
                    fi(e)
                },
                leave: e => Promise.all([pi(e)]),
                afterLeave: e => Promise.all(new Jt(e), ui(e)),
                afterEnter: e => mi(e)
            }
        },
        ui = e => new Promise(t => {
            const i = e.next.container.querySelector("main"),
                s = e.next.container.querySelector("footer");
            i.classList.add("animateMainOut"), s.classList.add("animateMainOut"), t()
        }),
        pi = e => {
            const t = e.current.container.querySelector("main"),
                i = e.current.container.querySelector("footer");
            return t.classList.add("animateMainOut"), i.classList.add("animateMainOut"), new Promise(e => {
                i.addEventListener("transitionend", () => {
                    e()
                })
            })
        },
        mi = e => {
            const t = e.next.container.querySelector("main"),
                i = e.next.container.querySelector("footer");
            setTimeout(() => {
                t.classList.remove("animateMainOut"), i.classList.remove("animateMainOut")
            }, 100)
        },
        fi = e => {
            const t = e.next.namespace,
                i = e.next.container.querySelector(".sz-menu-items ul").children;
            for (let e of i) e.className === t ? e.classList.add("active") : e.classList.remove("active")
        },
        gi = e => {
            var t = document.querySelector(".sz-main-nav");
            null != t && (e ? t.style.display = "none" : setTimeout(() => {
                t.style.display = "block"
            }, 100))
        },
        vi = () => {
            document.querySelectorAll("img.svg").forEach((function (e) {
                var t = e.id,
                    i = e.className,
                    s = e.src;
                fetch(s).then((function (e) {
                    return e.text()
                })).then((function (s) {
                    var n = (new DOMParser).parseFromString(s, "text/xml").getElementsByTagName("svg")[0];
                    void 0 !== t && n.setAttribute("id", t), void 0 !== i && n.setAttribute("class", i + " replaced-svg"), n.removeAttribute("xmlns:a"), !n.getAttribute("viewBox") && n.getAttribute("height") && n.getAttribute("width") && n.setAttribute("viewBox", "0 0 " + n.getAttribute("width") + " " + n.getAttribute("height")), e.parentNode.replaceChild(n, e)
                }))
            }))
        },
        yi = e => {
            var t;
            let i;
            const s = (t = null != e ? e.next.container : document).querySelector(".sz-menu-button-wrapper"),
                n = t.querySelector(".sz-menu-overlay"),
                a = t.querySelector(".sz-menu-items"),
                r = t.querySelector("nav");
            null != s && (s.addEventListener("click", e => {
                document.documentElement.classList.toggle("sz-no-scroll"), e.target.classList.toggle("active"), n.classList.toggle("active"), a.classList.toggle("active"), r.classList.toggle("active");
                const t = document.querySelector(".banner--availability");
                t && (t.classList.contains("is-visible") ? t.classList.remove("is-visible") : t.classList.add("is-visible")), r.classList.contains("active") ? (clearTimeout(i), r.style.zIndex = 3) : i = setTimeout(() => {
                    r.style.zIndex = 1
                }, 3e3)
            }), re(), window.addEventListener("optimizedResize", () => {
                bi(s, n, a)
            }))
        },
        bi = (e, t, i) => {
            window.innerWidth >= 768 && (document.documentElement.classList.remove("sz-no-scroll"), e.classList.remove("active"), t.classList.remove("active"), i.classList.remove("active"))
        };
    class wi {
        constructor(e, t) {
            this.container = t || document, this.columnIndex = 0, this.gridContainer = this.container.querySelector(e), this.columnsAmount = this.gridContainer.dataset.columns, this.clients = Array.from(this.gridContainer.children), this.swapClientBound = this.swapClient.bind(this), this.rotateTimeOut = 4e3, this.breakpoints = {
                small: 640,
                medium: 960,
                large: 1280
            }, this.getColumnsAmount(), this.distribute(), this.initTimer(), window.addEventListener("resize", () => {
                this.resizeHandler()
            })
        }
        getColumnsAmount() {
            this.columnsAmount = this.gridContainer.dataset.columns;
            for (let e in this.breakpoints)
                if (window.innerWidth < this.breakpoints[e]) {
                    this.columnsAmount = parseInt(this.gridContainer.dataset[`columns${e.charAt(0).toUpperCase()+e.slice(1)}`]);
                    break
                }
        }
        resizeHandler() {
            const e = this.columnsAmount;
            this.getColumnsAmount(), e !== this.columnsAmount && this.distribute()
        }
        distribute() {
            this.grid && this.grid.remove(), this.columns = [], this.columnIndex = 0, this.grid = document.createElement("div"), this.grid.classList.add("client-grid"), this.gridContainer.appendChild(this.grid);
            for (let e = 0; e < this.columnsAmount; e++) {
                const e = document.createElement("div");
                e.classList.add("client-grid__column"), this.columns.push(e), this.grid.appendChild(e)
            }
            let e = 0;
            for (let t = 0; t < this.clients.length; t++) {
                const i = this.clients[t],
                    s = this.columns[e];
                s.appendChild(i), e < this.columnsAmount - 1 ? e++ : e = 0, 1 === s.children.length ? (i.hidden = !1, i.classList.remove("is-hidden")) : (i.hidden = !0, i.classList.add("is-hidden"))
            }
            this.grid.offsetWidth, this.grid.classList.add("is-visible")
        }
        initTimer() {
            clearTimeout(this.timer), this.timer = setTimeout(() => {
                this.rotateClient()
            }, this.rotateTimeOut)
        }
        destroy() {
            clearTimeout(this.timer)
        }
        swapClient() {
            this.currentLogo.hidden = !0, this.nextLogo.hidden = !1, this.nextLogo.offsetWidth, this.nextLogo.classList.remove("is-hidden")
        }
        rotateClient() {
            const e = this.columns[this.columnIndex];
            e.clientIndex || (e.clientIndex = 0);
            const t = e.children[e.clientIndex];
            e.children[e.clientIndex + 1] ? e.clientIndex++ : e.clientIndex = 0;
            const i = e.children[e.clientIndex];
            this.columns[this.columnIndex + 1] ? this.columnIndex++ : this.columnIndex = 0, t !== i ? (t.classList.add("is-hidden"), this.currentLogo = t, this.nextLogo = i, setTimeout(this.swapClientBound, 400), this.initTimer()) : this.rotateClient()
        }
    }
    class xi {
        constructor(e, t) {
            this.container = t || document, this.timelineContainer = this.container.querySelector(e), this.tabs = this.timelineContainer.querySelectorAll(".timeline-tab"), this.arrowButtonPrev = this.timelineContainer.querySelector(".sz-arrow-button.reversed"), this.arrowButtonNext = this.timelineContainer.querySelector(".sz-arrow-button:not(.reversed)"), this.tabsAmount = this.tabs.length, this.activeSlide = 1, this.attachEventListeners(), this.gotoSlide(this.timelineContainer.dataset.slideActive || this.activeSlide)
        }
        attachEventListeners() {
            this.tabs.forEach(e => {
                e.addEventListener("click", () => {
                    this.gotoSlide(e.dataset.forSlide)
                })
            }), this.arrowButtonPrev.addEventListener("click", () => {
                let e = this.activeSlide - 1;
                e < 1 && (e = this.tabs[this.tabs.length - 1].dataset.forSlide), this.gotoSlide(e)
            }), this.arrowButtonNext.addEventListener("click", () => {
                let e = this.activeSlide + 1;
                e > this.tabs[this.tabs.length - 1].dataset.forSlide && (e = 1), this.gotoSlide(e)
            })
        }
        gotoSlide(e) {
            this.tabs.forEach(t => {
                t.classList.remove("timeline-tab--active"), t.dataset.forSlide == e && t.classList.add("timeline-tab--active")
            }), this.activeSlideElement && this.activeSlideElement.classList.remove("is-active"), this.activeSlideElement = this.timelineContainer.querySelector(`[data-slide='${e}']`), this.activeSlideElement.classList.add("is-active"), this.activeSlide = parseInt(e)
        }
    }
    class Ei {
        constructor(e, t = document.body) {
            this.header = t.querySelector(e), this.header && (this.scrollHandlerBound = this.throttleScroll.bind(this), this.debounceTimer, this.debounceTimeOut = 150, this.throttleTimeOut = 100, this.prev = 0, this.prevScrollY = 0, window.addEventListener("scroll", this.scrollHandlerBound, {
                passive: !0
            }))
        }
        throttleScroll() {
            requestAnimationFrame(e => {
                e - this.prev > this.throttleTimeOut && (this.scrollHandler(), clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(this.scrollHandler.bind(this), this.debounceTimeOut), this.prev = e)
            })
        }
        scrollHandler() {
            const e = Math.max(0, window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop),
                t = this.prevScrollY - e;
            t < 0 ? (this.header.classList.add("is-hidden"), this.header.classList.add("is-stuck")) : t > 0 && (this.header.classList.contains("is-stuck") || this.header.classList.add("is-stuck"), this.header.classList.remove("is-hidden")), e < 1 && (this.header.classList.remove("is-stuck"), this.header.classList.remove("is-hidden")), this.prevScrollY = e
        }
        destroy() {
            window.removeEventListener("scroll", this.scrollHandlerBound)
        }
    }
    class Si {
        constructor(e, t) {
            this.container = t || document, this.parallaxContainer = this.container.querySelector(e), this.layers = this.parallaxContainer.querySelectorAll(".parallax-layer"), this.ticking = !1, this.attachEventListeners()
        }
        attachEventListeners() {
            window.addEventListener("scroll", e => {
                const t = Math.max(0, window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop);
                this.ticking || (window.requestAnimationFrame(() => {
                    this.positionLayers(t), this.ticking = !1
                }), this.ticking = !0)
            }, {
                passive: !0
            })
        }
        positionLayers(e) {
            this.layers.forEach(t => {
                const i = e * parseFloat(t.dataset.depth);
                t.style.transform = `translateY(${i}px)`
            })
        }
    }
    let Ci = null,
        Ti = null;

    function Li(e) {
        let t = !1;
        t = e ? e.matches : window.matchMedia("(prefers-color-scheme: dark)").matches;
        let i = document.querySelector("link[rel='icon'][sizes='32x32']") || document.createElement("link");
        i.type = "image/png", i.href = t ? "images/favicons/32.png" : "images/favicons/32-dark.png", i.parentNode || (i.rel = "icon", document.querySelector("head").appendChild(i))
    }
    const Ii = () => {
            document.querySelector(".close-bar").addEventListener("click", () => {
                zi()
            })
        },
        $i = () => {
            const e = document.querySelector(".sz-banner.cookie");
            Mi("acceptCookies") ? e.classList.remove("visible") : e.classList.add("visible")
        },
        zi = () => {
            var e, t = new Date;
            t.setFullYear(t.getFullYear() + 1), e = "expires=" + t.toUTCString(), document.cookie = "acceptCookies=true;" + e + ";path=/;", document.querySelector(".sz-banner.cookie").classList.remove("visible")
        },
        Mi = e => {
            var t = RegExp(e + "=.[^;]*"),
                i = document.cookie.match(t);
            return !!i && i[0].split("=")[1]
        };
    window.onload = () => {
        yi(null), $i(), Ii(), window.matchMedia("(prefers-color-scheme: dark)").addListener(Li), Li(),
            function () {
                const e = ["sz-index", "sz-work"],
                    t = ["casestudy-tempoteam", "casestudy-auto", "casestudy-beatt", "casestudy-camptoo", "casestudy-vvv-breda", "casestudy-dekweker"];
                let i, s;
                ae.hooks.before(s => {
                    t.indexOf(s.next.namespace) > -1 && e.indexOf(s.current.namespace) > -1 && (i = s.current)
                }), ae.hooks.beforeEnter(() => {
                    Ci && (Ci.destroy(), Ci = null)
                }), ae.hooks.afterEnter(e => {
                    document.documentElement.classList.remove("sz-no-scroll");
                    const i = e.next.url.path.substr(1);
                    Ci = new Ei(".sz-casestudy-nav", e.next.container), Ti && document.body.classList.remove(Ti), i.length > 0 && (document.body.classList.add(i), Ti = i), e.current.namespace !== e.next.namespace && gtag("config", "UA-56661684-1", {
                        page_path: "/" === e.next.url.href[0] ? e.next.url.href : `/${e.next.url.href}`
                    });
                    const s = e.next.namespace;
                    t.includes(s) ? (gi(!0), document.body.style.backgroundColor = "#FFFFFF") : (gi(!1), document.body.style.backgroundColor = "#08101F")
                }), ae.hooks.after(e => {
                    if (document.body.scrollTop = document.documentElement.scrollTop = 0, vi(), yi(e), i) {
                        const e = document.querySelector(".sz-close-case");
                        e && (e.href = i.url.href)
                    }
                }), ae.init({
                    debug: !0,
                    transitions: [Zt(t, e), ii(t, e), li(t), hi(["sz-index", "sz-about", "sz-work", "sz-contact", "sz-privacy", "sz-services"])],
                    views: [{
                        namespace: "sz-index",
                        afterEnter(e) {
                            zt(!0, 160), Dt(), s = new wi(".client-brands-grid", e.next.container), new we(".casestudy-container", e.next.container), e.next.container.querySelector(".casestudy-container").classList.remove("is-hidden"), document.querySelector(".banner--availability").classList.add("is-visible")
                        },
                        beforeLeave() {
                            document.querySelector(".banner--availability").classList.remove("is-visible")
                        },
                        afterLeave() {
                            s && (s.destroy(), s = null)
                        }
                    }, {
                        namespace: "sz-work",
                        afterEnter(e) {
                            this.grid = new we(".casestudy-container", e.next.container), e.next.container.querySelector(".casestudy-container").classList.remove("is-hidden")
                        }
                    }, {
                        namespace: "sz-services",
                        afterEnter() {
                            Bt()
                        }
                    }, {
                        namespace: "sz-about",
                        afterEnter() {
                            zt(!1, 160, !0), $t(".introduction-hero .sz-draggable-slider-container"), $t(".teammembers .sz-draggable-slider-container", {
                                nextEl: ".sz-drag-slider-next",
                                prevEl: ".sz-drag-slider-prev"
                            }), Ot()
                        }
                    }, {
                        namespace: "sz-contact",
                        afterEnter() {
                            Ht()
                        }
                    }, {
                        namespace: "casestudy-auto",
                        afterEnter() {
                            Mt()
                        }
                    }, {
                        namespace: "casestudy-tempoteam",
                        afterEnter() {
                            setTimeout(() => {
                                new oe({
                                    compareSliderClass: "sz-compare-slider tempoteam"
                                }).init()
                            }, 500)
                        }
                    }, {
                        namespace: "casestudy-camptoo",
                        afterEnter() {
                            Mt(), document.querySelectorAll(".header-reveal").forEach(e => e.classList.add("animate-in")), setTimeout(() => {
                                new oe({
                                    compareSliderClass: "sz-compare-slider camptoo"
                                }).init()
                            }, 500)
                        }
                    }, {
                        namespace: "casestudy-vvv-breda",
                        afterEnter(e) {
                            this.timeline = new xi(".sz-timeline", e.next.container), this.parallax = new Si(".vvv-breda-hero-parallax", e.next.container)
                        }
                    }]
                })
            }(),
            function () {
                switch (document.querySelector("[data-barba-namespace]").getAttribute("data-barba-namespace").toString()) {
                    case "casestudy-auto":
                    case "casestudy-tempoteam":
                    case "casestudy-beatt":
                    case "casestudy-camptoo":
                    case "casestudy-dekweker":
                    case "casestudy-vvv-breda":
                        di(null), ci(), document.body.style.backgroundColor = "#FFFFFF"
                }
                vi()
            }()
    }
}();
